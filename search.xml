<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AJAX的XMLHttpRequest对象使用</title>
    <url>/2016/05/20/AJAX%E7%9A%84XMLHttpRequest%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3></blockquote>
<span id="more"></span>
<blockquote>
<pre><code>   //1 创建XHR对象
    var xhr = null;
    if(window.XMLHttpRequest)&#123;  //新IE、其它浏览器
        xhr = new XMLHttpRequest();  
    &#125;else &#123; //老IE
        xhr = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;);
    &#125;
//2 监听XHR的状态改变
    xhr.onreadystatechange = function()&#123;
      if(xhr.readyState===4)&#123; //DONE响应消息接收完成
        if(xhr.status===200)&#123;
          console.log(&#39;响应接收完成且成功&#39;);
          console.log(&#39;响应主体：&#39;+xhr.responseText);
          doResponse(xhr.responseText);//调用自定义的函数，处理响应数据
        &#125;else &#123;
          console.log(&#39;响应接收完成但不成功&#39;);
          console.log(&#39;响应状态码为：&#39;+xhr.status);
        &#125;
      &#125;
    &#125;
//3 打开连接
    xhr.open(&#39;GET&#39;,&#39;test.php?uname=&#39;+n, true);
//4 发送请求消息
    xhr.send( null );
</code></pre>
</blockquote>
]]></content>
      <tags>
        <tag>AJAX</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>关于JS的模块化开发总结</title>
    <url>/2017/04/10/CommonJSAMDCMD%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>一直都在说JS的模块化开发，以前研究和使用过require之类的方法，但是一直不是很明确，今天还是在总结一下：</p>
<ul>
<li><strong>知识点一</strong> ：AMD/CMD/CommonJs是JS模块化开发的标准；</li>
<li><strong>知识点二</strong> ：commonjs是用在服务器端的，同步的，如nodejs；amd, cmd是用在浏览器端的，异步的，如requirejs和seajs；</li>
<li><strong>知识点三</strong> ：AMD/CMD区别，虽然都是并行加载js文件，但还是有所区别，AMD是预加载，在并行加载js文件同时，还会解析执行该模块（因为还需要执行，所以在加载某个模块前，这个模块的依赖模块需要先加载完成）；而CMD是懒加载，虽然会一开始就并行加载js文件，但是不会执行，而是在需要的时候才执行。<span id="more"></span></li>
</ul>
<p><strong>CommonJS</strong></p>
<blockquote>
<p>CommonJs 是服务器端模块的规范。<br>根据CommonJS规范，一个单独的文件就是一个模块。加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的exports对象。<br>例如:<br>// foobar.js</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//私有变量</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公有方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foobar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// do someing ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//do someing ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>//exports对象上的方法和变量是公有的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foobar = <span class="keyword">new</span> foobar();</span><br><span class="line"><span class="built_in">exports</span>.foobar = foobar;</span><br></pre></td></tr></table></figure>
<p>//require方法默认读取js文件，所以可以省略js后缀</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="built_in">require</span>(<span class="string">&#x27;./boobar&#x27;</span>).foobar;</span><br><span class="line">test.bar();</span><br></pre></td></tr></table></figure>
<p>CommonJS 加载模块是同步的，所以只有加载完成才能执行后面的操作。像Node.js主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式，所以CommonJS规范比较适用。但如果是浏览器环境，要从服务器加载模块，这是就必须采用异步模式。所以就有了 AMD  CMD 解决方案。</p>
<p><strong>AMD</strong></p>
<blockquote>
<p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出<br>AMD异步加载模块。它的模块支持对象 函数 构造器 字符串 JSON等各种类型的模块。<br>适用AMD规范适用define方法定义模块。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过数组引入依赖 ，回调函数通过形参传入依赖</span></span><br><span class="line">define([<span class="string">&#x27;someModule1&#x27;</span>, ‘someModule2’], <span class="function"><span class="keyword">function</span> (<span class="params">someModule1, someModule2</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">/// someing</span></span><br><span class="line">        someModule1.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">foo</span>: foo&#125;</span><br><span class="line">&#125;);</span><br><span class="line">AMD规范允许输出模块兼容CommonJS规范，这时define方法如下：</span><br><span class="line"></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> reqModule = <span class="built_in">require</span>(<span class="string">&quot;./someModule&quot;</span>);</span><br><span class="line">    requModule.test();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exports</span>.asplode = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//someing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>CMD</strong></p>
<blockquote>
<p>CMD是SeaJS 在推广过程中对模块定义的规范化产出</p>
</blockquote>
<p>CMD和AMD的区别有以下几点：</p>
<blockquote>
<p>1.对于依赖的模块AMD是提前执行，CMD是延迟执行。不过RequireJS从2.0开始，也改成可以延迟执行（根据写法不同，处理方式不通过）。<br>2.CMD推崇依赖就近，AMD推崇依赖前置。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AMD</span></span><br><span class="line">define([<span class="string">&#x27;./a&#x27;</span>,<span class="string">&#x27;./b&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//依赖一开始就写好</span></span><br><span class="line">    a.test();</span><br><span class="line">    b.test();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//CMD</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">requie, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//依赖可以就近书写</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a&#x27;</span>);</span><br><span class="line">    a.test();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//软依赖</span></span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> b = requie(<span class="string">&#x27;./b&#x27;</span>);</span><br><span class="line">        b.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 虽然 AMD也支持CMD写法，但依赖前置是官方文档的默认模块定义写法。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>3.AMD的api默认是一个当多个用，CMD严格的区分推崇职责单一。例如：AMD里require分全局的和局部的。CMD里面没有全局的 require,提供 seajs.use()来实现模块系统的加载启动。CMD里每个API都简单纯粹。</p>
</blockquote>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>H5新特性</title>
    <url>/2016/07/10/H5%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h3 id="表单新特性————新的-input-type"><a href="#表单新特性————新的-input-type" class="headerlink" title="表单新特性————新的 input type"></a>表单新特性————新的 input type</h3><pre><code>&lt;input type=&quot;?&quot;&gt;
</code></pre>
<p>1.1 原有的 type:</p>
<pre><code>text、password、radio、checkbox、hidden、file、image、button、submit、reset
</code></pre>
<span id="more"></span>
<p>1.2 新增的 type:</p>
<pre><code>email、search、url、tel、number、range、color、date、week、month

1. email:  要求输入必需符合邮箱格式  xx@xx
2. url:  要求输入必需符合URL格式  xx:yy
3. tel:  无输入格式验证，在手机中弹出的数字键盘，而不是字母键盘
4. number: 要求输入一个整型数字，可以配合max/min/step新属性使用
5. search: Chrome中会显示一个x号
6. range: 范围选择器、滑块，可以配合max/min/step新属性使用
7. color：颜色选择器，Chrome/FF偷懒了，都直接使用操作系统自带的颜色选择器
8. date：日期选择器，FF不支持
9. month：月份选择器，FF不支持
10. week：星期选择器，FF不支持
</code></pre>
<!-- more -->

<blockquote>
<p>提示：<br>(1) HTML5 新添的 input type 存在严重的兼容性问题！<br>(2) 新特性弹出的提示消息本质是“窗口”，不是 HTML 元素，无法使用 JS、CSS 进行控制！</p>
</blockquote>
<h3 id="表单新特性————新的表单元素"><a href="#表单新特性————新的表单元素" class="headerlink" title="表单新特性————新的表单元素"></a>表单新特性————新的表单元素</h3><p>2.1 原有的表单输入元素：<br>input、textarea、select/option<br>2.2 新增的表单元素</p>
<pre><code>(1)&lt;datalist&gt;&lt;/datalist&gt;        数据列表，本身是不可见元素，为某个input提供可选输入的列表，使用方法：
    &lt;datalist id=&quot;LISTID&quot;&gt;&lt;option&gt;选项名&lt;/option&gt;&lt;/datalist&gt;
    &lt;input type=&quot;text&quot; list=&quot;LISTID&quot;&gt;

(2)&lt;progress&gt;&lt;/progress&gt;    进度条，仅用于进度的提示，不能被用户操作，也不会被提交。
    &lt;progress value=&quot;0.5&quot;&gt;&lt;/progress&gt;

(3)&lt;meter&gt;&lt;/meter&gt;        刻度尺，仅用于水平/数量的提示，不能被用户操作，也不会被提交。需要指定如下属性：
    &lt;meter min=&quot;最小值&quot; max=&quot;最大值&quot; low=&quot;下限值&quot; high=&quot;上限值&quot; optimum=&quot;最优值&quot;  value=&quot;当前实际值&quot;&gt;&lt;/meter&gt;
    如果最优值小于下限值，刻度尺颜色分配：
    min (绿色) low (黄色) high (红色) max
    如果最优值大于下限值且小于上限值，刻度尺颜色分配：
    min (黄色) low (绿色) high (黄色) max
    如果最优值大于上限值，刻度尺颜色分配：
    min (红色) low (黄色) high (绿色) max

(4)&lt;output&gt;&lt;/output&gt;    语义标签，表示一个计算的输出值，仅用于计算结果的提示，不能被用户操作，也不会被提交。
</code></pre>
<p>提示：上述四个新元素存在兼容性问题。</p>
<h3 id="表单新特性————input-的新属性"><a href="#表单新特性————input-的新属性" class="headerlink" title="表单新特性————input 的新属性"></a>表单新特性————input 的新属性</h3><p>3.1 原有的 input 属性</p>
<pre><code>&lt;input id=&quot;&quot; class=&quot;&quot; style=&quot;&quot; title=&quot;&quot; name=&quot;&quot; value=&quot;&quot; type=&quot;&quot; readonly  checked  selected  diabled &gt;
</code></pre>
<p>3.2 新增的 input 属性</p>
<pre><code>&lt;input type=&quot;number&quot; max=&quot;最大值&quot; min=&quot;最小值&quot; step=&quot;步长&quot;&gt;
&lt;input type=&quot;text&quot; list=&quot;datalist元素的ID&quot;  autocomplete=&quot;on/off&quot;&gt;
&lt;meter min=&quot;最小值&quot; max=&quot;最大值&quot; low=&quot;下限值&quot; high=&quot;上限值&quot; optimum=&quot;最优值&quot;  value=&quot;当前实际值&quot;&gt;&lt;/meter&gt;

(1)placeholder：占位符，用于在input中显示提示性文字，注意：不是value
(2)autocomplete：可赋值为on或off，是否记录之前提交的内容，以实现下次输入时的自动提示
(3)autofocus：自动获得输入焦点
(4)multiple：用于email/url/tel等，允许使用逗号指定多个输入
(5)form：为input指定form属性，可以将input从form内部提到外部，且不影响输入域的提交
  与表单输入验证有关的属性：
(6)required：必填属性，若用户未填写内容，则无法提交
(7)minlength：限制最少的字符个数，非标准，FF不支持
(8)maxlength：限制最大的字符个数
(9)max：一般用于number、range、&lt;meter&gt;、&lt;progress&gt;，表示允许的数字最大值
(10)min：一般用于number、range、&lt;meter&gt;、&lt;progress&gt;，表示允许的数字最小值
(11)step：一般用于number、range，表示步长
(12)pattern：使用正则表达式进行验证
&lt;input type=&quot;text&quot; name=&quot;cellphone&quot; placeholder=&quot;请输入手机号&quot; pattern=&quot;^1[358]\d&#123;9&#125;$&quot; required&gt;
</code></pre>
<h3 id="如何修改表单的提示消息"><a href="#如何修改表单的提示消息" class="headerlink" title="如何修改表单的提示消息"></a>如何修改表单的提示消息</h3><p>HTML5 表单可能在如下情形下弹出提示消息：<br>(1)特定的 input type 不被满足，如 email、url<br>(2)特定的验证属性不被满足，如 required、pattern、step、minlength<br>不同的浏览器会弹出不同的提示消息。如何自定义弹出的提示消息：<br>HTML5 为所有的表单输入域都添加了一个 validity 对象属性，该对象中包含如下的属性：</p>
<blockquote>
<p>1.badInput:false 无效的输入，如<br>2.customError:false 是否存在自定义错误<br>3.patternMismatch:false 正则表达式不匹配，违反 pattern 验证<br>4.rangeOverflow:false 数字范围过大，违反了 max 验证<br>5.rangeUnderflow:false 数字范围过小，违反了 min 验证<br>6.stepMismatch:false 步长不匹配，违反 step 验证<br>7.tooLong:false 字符个数太长，违反 maxlength 验证<br>8.tooShort:false 字符个数太短，违反 minlength 验证<br>9.typeMismatch:false 类型不匹配，如 email/url 格式错误<br>10.valid:true 当前输入值是否有效<br>11.valueMissing:false 缺少值，违反 required 验证</p>
</blockquote>
<p>上述属性会随着用户的输入即时的发生改变，只要有一项验证失败，对应的 boolean 值就会变成 true，导致 valid 属性变为 false；只有当所有其他属性都变为 false，valid 属性才会变为 true，该输入域是有效的，可以被提交了。<br>通过检查上述属性是否为 true，可以通过“设置自定义的有效性消息 setCustomValidity”设置自定义的错误消息——validity.customError 就会变为 true，自定义错误消息的优先级高于浏览器默认的消息优先级。<br>if( input.validity.xxx === true ){<br>input.setCustomValidity(“自定义消息”);<br>}else {<br>input.setCustomValidity(“”);<br>}</p>
]]></content>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>Canvas绘图技术</title>
    <url>/2016/07/12/H5%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94Canvas/</url>
    <content><![CDATA[<h2 id="HTML5-新特性——Canvas-绘图技术"><a href="#HTML5-新特性——Canvas-绘图技术" class="headerlink" title="HTML5 新特性——Canvas 绘图技术"></a>HTML5 新特性——Canvas 绘图技术</h2><p>提示：Canvas 绘图的难点在方法和属性的记忆上！<br>Canvas 技术用于在网页上实现绘图，主要应用领域：</p>
<span id="more"></span>

<blockquote>
<ul>
<li>绘制各种统计图表，柱状图、饼图、曲线图、分布图…</li>
<li>动画和游戏</li>
</ul>
</blockquote>
<p>使用 Canvas 的方法：<br><canvas width="500"  height="400"><br>您的浏览器不支持 Canvas 标签！<br></canvas><br>提示：</p>
<ol>
<li><p> Canvas 的宽和高只能用属性方式声明！若使用样式来声明则无效。</p>
</li>
<li><p> Canvas 的本意是“画布/画板”，可以盛放绘制的内容；真正执行绘图任务的是“画笔/绘图上下文对象”——Context</p>
</li>
<li><p> 每一个画布，有且只有一个画笔对象：</p>
<pre>
var ctx = canvas.getContext( '2d' );
</pre></li>
<li><p>画笔/绘图上下文对象的成员：</p>
 <pre>
     1.fillStyle:"#000000"            填充颜色
     2.font:"10px sans-serif"            字体
     3.globalAlpha:1                    全局透明度
     4.lineCap:"butt"                    线的端点样式
     5.lineJoin:"miter"                线的连接处样式
     6.lineWidth:1                    线条的宽度
     7.shadowBlur:0                    阴影部分模糊距离
     8.shadowColor:"rgba(0, 0, 0, 0)"    阴影部分颜色
     9.shadowOffsetX:0                阴影水平偏移量
     10.shadowOffsetY:0                阴影竖直偏移量
     11.strokeStyle:"#000000"            轮廓/描边颜色
     12.arc:arc()                    绘制一个弧线
     13.beginPath:beginPath()        开始绘制路径
     14.clearRect:clearRect()        清除一个矩形范围
     15.clip:clip()                裁切
     16.closePath:closePath()        闭合一条路径
     17.createLinearGradient:createLinearGradient() 创建一个线性渐变色
     18.createRadialGradient:createRadialGradient() 创建一个径向渐变色
     19.drawImage:drawImage()        绘制一幅图像
     20.ellipse:ellipse()            绘制一个椭圆
     21.fill:fill()                填充一条路径
     22.fillRect:fillRect()        填充一个矩形区域
     23.fillText:fillText()        填充一段文本
     24.lineTo:lineTo()            绘制一条直线
     25.measureText:measureText()    测量一段文本，得到宽度
     26.moveTo:moveTo()            移动画笔到指定点
     27.rect:rect()                绘制一个矩形路径
     28.rotate:rotate()            旋转
     29.scale:scale()                缩放
     30.stroke:stroke()            对一条路径描边
     31.strokeRect:strokeRect()    对一个矩形进行描边
     32.strokeText:strokeText()    对一段文本进行描边
     33.translate:translate()        进行位移
 </pre>

<p> 5.使用画笔在画布上绘制图形<br><br> 5.1 绘制矩形(长方形)——矩形以自己的左上角作定位点</p>
<pre><code> &lt;pre&gt;ctx.lineWidth = 10;                修改描边的宽度
 ctx.strokeStyle = &#39;颜色&#39;/渐变色;    修改描边的颜色
 ctx.strokeRect(x, y, w, h)            描边一个矩形
 ctx.fillStyle = &#39;颜色&#39;/渐变色对象;    填充样式
 ctx.fillRect(x, y, w, h)            填充一个矩形
 ctx.clearRect(x,y, w, h);            清除一个矩形范围内所有内容
</code></pre>
<p> </pre><br> 5.2  绘制文本——文字以自己的坐下角作定位点</p>
<pre><code> &lt;pre&gt;ctx.font = &#39;20px SimHei&#39;;        设置字体大小和样式
 var w = ctx.measureText(txt).width;    获取一段文本的宽度
 ctx.strokeStyle = &quot;颜色&quot;/渐变;
 ctx.strokeText(txt, x, y)            对文字进行描边
 ctx.fillStyle = &quot;颜色&quot;/渐变;
 ctx.fillText(txt, x, y)                对文字进行填充
 &lt;/pre&gt;
</code></pre>
<p> 5.3 绘制路径</p>
<pre><code>     ctx.beginPath( );        //开始一条新路径

 ...在路径上添加定位点...

     ctx.closePath( );        //闭合当前路径
 路径的两个用途：

     (1)ctx.stroke();    //描边刚刚绘制的路径
     (2)ctx.fill();        //填充刚刚绘制的路径
 常见的添加定位点的方法：

     ctx.moveTo(x,y);    //把画笔移动到指定点
     ctx.lineTo(x,y);        //从上一个点开始到当前点绘制一条直线
     ctx.arc(x,y,r,sAngle,eAngle);        //绘制一条圆弧线
     ctx.ellipse(x,y,rx,ry,sAngle,eAngle);    //绘制一条椭圆弧线
</code></pre>
<p> 5.4 绘制图像——以图像的左上角为定位点</p>
<pre><code>     ctx.rotate( angle );    //旋转画笔，此后绘制的图像/图像都会旋转——旋转围绕着画布的坐标原点为轴
     ctx.translate(x, y);    //平移坐标轴的原点
     ctx.drawImage(img, x, y);        //原宽原高的绘制图像
     ctx.drawImage(img, x, y, width, height);  //使用指定的宽和高绘制图像

 提示：
     1)创建图片： var img =new Image();  img.src=&quot;xx.jpg&quot;;
     2)使用图片必须等待加载完成！  img.onload = function()&#123; ... &#125;
</code></pre>
</li>
</ol>
]]></content>
      <tags>
        <tag>HTML5</tag>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>H5新特性——音视频</title>
    <url>/2016/07/11/H5%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<p>HTML5 之前在页面播放需要使用 flash 播放器；HTML5 添加两个标签：</p>
<pre><code>&lt;video&gt;&lt;/video&gt;
&lt;audio&gt;&lt;/audio&gt;
</code></pre>
<p>这两个标签有一些特殊属性、事件、方法。</p>
<span id="more"></span>
<h3 id="HTML5-新特性——视频"><a href="#HTML5-新特性——视频" class="headerlink" title="HTML5 新特性——视频"></a>HTML5 新特性——视频</h3><p>1.Video 标签可用的属性：</p>
<pre><code>(1)src：待播放的资源的URL
(2)width：播放区域的宽度
(3)height：播放区域的高度
(4)controls：是否显示播放控件，默认不显示
(5)autoplay：是否自动播放，默认不自动播放
(6)loop：是否循环播放，默认不循环
(7)preload：如何预加载视频，可以赋值为
    “none”：不预加载
    “metadata”：只预加载元数据，如影片宽、高、大小、时长
    “auto”：（默认值）自动预加载元数据以及部分影片数据
(8)poster：影片播放之前显示的“电影海报”
</code></pre>
<p>2.Video 对象的成员</p>
<pre><code>1.autoplay:false
2.controls:false
3.currentTime:0             当前播放到哪一秒
4.duration:NaN            总时长
5.ended:false
6.loop:false            是否循环
7.muted:false            是否静音
8.oncanplay:null            当能够播放时触发
9.oncanplaythrough:null    当能够顺利播放一段时间
10.onended:null            当播放的结尾时触发
11.onerror:null            当播放错误时触发
12.onloadeddata:null        当加载了影片数据时触发
13.onloadedmetadata:null    当加载了影片元数据时触发
14.onpause:null            当影片暂停时触发
15.onplay:null            当影片开始播放时触发
16.paused:true            当前是否处于暂停状态
17.poster:&quot;&quot;                电影海报
18.preload:&quot;auto&quot;            如何预加载
19.src:&quot;http://127.0.0.1/html5_day02/resource/birds.mp4&quot;
20.videoHeight:0
21.videoWidth:0
22.volume:1
23.play(): function()&#123;&#125;    使用JS控制影片播放
24.pause(): function()&#123;&#125;    使用JS控制影片暂停
</code></pre>
<h3 id="HTML5-新特性——音频"><a href="#HTML5-新特性——音频" class="headerlink" title="HTML5 新特性——音频"></a>HTML5 新特性——音频</h3><p>HTML5 之前，播放音频可以使用 flash 播放器，或者使用 bgsound（IE 专有，只能网页的背景音乐，不能使用 JS 控制播放、音量）。<br>HTML5 中，使用 audio 标签来播放音频。该标签的常用属性与 video 几乎一样，如：</p>
<pre><code>(1)src
(2)autoplay：是否自动播放，默认为false
(3)controls：是否显示播放控制条，默认为false
(4)loop：是否循环播放，默认为false
</code></pre>
]]></content>
      <tags>
        <tag>HTML5</tag>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5离线存储和本地缓存</title>
    <url>/2016/07/15/H5%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E5%92%8C%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="一、离线缓存"><a href="#一、离线缓存" class="headerlink" title="一、离线缓存"></a>一、离线缓存</h1><p>有一个 web 应用有三个文件 index.html,a.js,b.css，现在需要把 js 和 css 文件缓存起来</p>
<span id="more"></span>
<p>1.在 index.html 里加上<html manifest="test.manifest"></p>
<p>2.manifest 清单格式如下</p>
<blockquote>
<pre><code> CACHE MANIFEST
</code></pre>
</blockquote>
<pre><code>#上面一句必须
#v1.0.0
#需要缓存的文件
CACHE:
a.js
b.css
#不需要缓存的文件
NETWORK:
*
#无法访问页面
FALLBACK:
404.html
复制代码
</code></pre>
<p>3.manifest 文件的 mime-type 必须是 text/cache-manifest 类型</p>
<blockquote>
<p>注意点：<br>a.对于每个 index.html?id=1 或 index.html?id=2 都会分别缓存 index.html 页面，可以通过 chrome 浏览器 Resources/Application Cache 观察<br>b.如果想更新缓存内容，只要修改下 manifest 文件即可，如改版本号 v1.0.1</p>
</blockquote>
<!-- more -->

<p>4.离线存储如果资源有更新，可以通过如下代码来监听，但第一次加载还会是原来的版本</p>
<blockquote>
<pre><code> window.applicationCache.addEventListener(&#39;updateready&#39;,function(e)&#123;
</code></pre>
</blockquote>
<pre><code>    if(window.applicationCache.status == window.applicationCache.UPDATEREADY)&#123;
        window.applicationCache.swapCache();
        if(confirm(&quot;loding new?&quot;))&#123;
            window.location.reload()
        &#125;
    &#125;
&#125;,false)
</code></pre>
<h1 id="二、本地缓存"><a href="#二、本地缓存" class="headerlink" title="二、本地缓存"></a>二、本地缓存</h1><pre><code>localStorage.setItem(&quot;key&quot;,&quot;value&quot;)

localStorage.getItem(&quot;key&quot;,&quot;value&quot;)

localStorage.removeItem(&quot;key&quot;)

localStorage.clear()
</code></pre>
<p>1.本地存储永不过期，除非自己去清除</p>
<p>2.可以通过 chrome 浏览器 Resources/Local Storage 来查看</p>
<p>3.不同域下就算 key 相同取不到的值也不同，如 localhost 和 127.0.0.1</p>
]]></content>
      <tags>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title>Hamming Distance</title>
    <url>/2016/09/03/HammingDistance/</url>
    <content><![CDATA[<h1 style="color:#2dbe60"> Hamming Distance </h1>
The <a href="https://en.wikipedia.org/wiki/Hamming_distance" target="_blank" style="box-sizing: border-box; color: rgb(0, 136, 204); text-decoration: none; background-color: transparent;">Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.
Given two integers x and y, calculate the Hamming distance.
<span id="more"></span>
**Note:**
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> ≤ x, y &lt; <span class="number">2</span>^<span class="number">31.</span></span><br></pre></td></tr></table></figure>
**Example:**
``` flow
Input: x = 1, y = 4

<p>Output: 2</p>
<p>Explanation:<br>1 (0 0 0 1)<br>4 (0 1 0 0)<br>? ?</p>
<p>The above arrows point to positions where the corresponding bits are different.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**代码如下:**</span><br><span class="line">``` javascript</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;number&#125; x</span><br><span class="line"> * @param &#123;number&#125; y</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var  hammingDistance = function(x, y) &#123;</span><br><span class="line">         var z = x^y;</span><br><span class="line">         z = z.toString(2).split(&quot;&quot;);</span><br><span class="line">         var result = 0;</span><br><span class="line">         z.forEach(function(val)&#123;</span><br><span class="line">              if(val === &#x27;1&#x27;)&#123;</span><br><span class="line">                    result++;</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;)</span><br><span class="line">         return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>JS 算法</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript代码收集</title>
    <url>/2016/07/20/Javascript%E4%BB%A3%E7%A0%81%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<h2 id="1-根据userAgent判断是否手机"><a href="#1-根据userAgent判断是否手机" class="headerlink" title="1.根据userAgent判断是否手机"></a>1.根据userAgent判断是否手机</h2><span id="more"></span>
<pre><code>if(/AppleWebKit.*Mobile/i.test(navigator.userAgent) || (/MIDP|SymbianOS|NOKIA|SAMSUNG|LG|NEC|TCL|Alcatel|BIRD|DBTEL|Dopod|PHILIPS|HAIER|LENOVO|MOT-|Nokia|SonyEricsson|SIE-|Amoi|ZTE/.test(navigator.userAgent)))&#123;
    if(window.location.href.indexOf(&quot;?mobile&quot;)&lt;0)&#123;
        try&#123;
            if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent))&#123;
                //移动端
            &#125;else if(/iPad/i.test(navigator.userAgent))&#123;
                //这里对ipad做了处理
            &#125;else&#123;
                //移动端
            &#125;
        &#125;catch(e)&#123;&#125;
    &#125;
&#125;else&#123;
    //pc端
&#125;
var ISWP = !!(navigator.userAgent.match(/Windows\sPhone/i));
</code></pre>
<h2 id="2-this-constructor-prototype例子"><a href="#2-this-constructor-prototype例子" class="headerlink" title="2.this, constructor, prototype例子"></a>2.this, constructor, prototype例子</h2><pre><code>var Tinker = function()&#123;
    this.elements = [];

&#125;;
    Tinker.fn = Tinker.prototype = &#123;
        constructor: Tinker,
        extend: function(obj)&#123;
            var p;
            for(p in obj)&#123;
                this.constructor.prototype[p] = obj[p];//此处若看明白了, 那么前面的就理解了
            &#125;
        &#125;
    
    &#125;
    Tinker.fn.extend(&#123;
       get: function()&#123;
            var length = arguments.length,
            i = 0;
           for(; i &lt; length; i++)&#123;
               this.elements.push(arguments[i]); //此处若看明白了, 那么前面的就理解了
           &#125;
           return this;//此处若看明白了, 那么前面的就理解了
       &#125;,
       each: function(fn)&#123;
            var i = 0,
                length = this.elements.length;
            for(; i &lt; length; i++)&#123;
                fn.call(this.elements[i], i, this.elements[i]);
            &#125;
            return this;//此处若看明白了, 那么前面的就理解了
       &#125;
        
    &#125;);
</code></pre>
<h2 id="3-模仿jquery-each"><a href="#3-模仿jquery-each" class="headerlink" title="3.模仿jquery each"></a>3.模仿jquery each</h2><pre><code>function each(obj, fn)&#123;
    var i;
    if(Object.prototype.toString.call(obj) === &#39;[object Array]&#39;)&#123;
        for(i = 0, length = obj.length; i &lt; length; i++)&#123;
            fn.call(obj[i], i, obj[i]);
        &#125;
    &#125;
    else if(typeof obj === &#39;object&#39;)&#123;
        for(i in obj)&#123;
            if(obj.hasOwnProperty(i))&#123;
               fn.call(obj[i], i, obj[i]);
            &#125;
        &#125;
    &#125;
    else&#123;
        return false;
    &#125;
&#125;
    
</code></pre>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>aplly&amp;call方法的使用</title>
    <url>/2016/07/02/aplly&amp;call%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>在一个对象中绑定函数，称为这个对象的方法。<br>在JavaScript中，对象的定义是这样的：</p>
<pre><code>var xiaoming = &#123;
    name: ‘小明’,
    birth: 1990
&#125;;
</code></pre>
<p>但是，如果我们给xiaoming绑定一个函数，就可以做更多的事情。比如，写个age()方法，返回xiaoming的年龄：</p>
<span id="more"></span>

<pre><code>var xiaoming = &#123;
    name: ‘小明’,
    birth: 1990,
    age: function () &#123;
    var y = new Date().getFullYear();
        return y - this.birth;
    &#125;
&#125;;
xiaoming.age; // function xiaoming.age()
xiaoming.age(); // 今年调用是25,明年调用就变成26了
</code></pre>
<p>绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个this关键字，这个东东是什么？</p>
<p>在一个方法内部，this是一个特殊变量，它始终指向当前对象，也就是xiaoming这个变量。所以，this.birth可以拿到xiaoming的birth属性。<br>让我们拆开写：</p>
<pre><code>function getAge() &#123;
    var y = new Date().getFullYear();
r    eturn y - this.birth;
&#125;

var xiaoming = &#123;
    name: ‘小明’,
    birth: 1990,
    age: getAge
&#125;;
xiaoming.age(); // 25, 正常结果
getAge(); // NaN
</code></pre>
<p>单独调用函数getAge()怎么返回了NaN？请注意，我们已经进入到了JavaScript的一个大坑里。</p>
<p>JavaScript的函数内部如果调用了this，那么这个this到底指向谁？</p>
<p>答案是，视情况而定！</p>
<p>如果以对象的方法形式调用，比如xiaoming.age()，该函数的this指向被调用的对象，也就是xiaoming，这是符合我们预期的。</p>
<p>如果单独调用函数，比如getAge()，此时，该函数的this指向全局对象，也就是window。</p>
<p>坑爹啊！</p>
<p>更坑爹的是，如果这么写：</p>
<pre><code>var fn = xiaoming.age; // 先拿到xiaoming的age函数
fn(); // NaN
</code></pre>
<p>也是不行的！要保证this指向正确，必须用obj.xxx()的形式调用！</p>
<p>由于这是一个巨大的设计错误，要想纠正可没那么简单。ECMA决定，在strict模式下让函数的this指向undefined，因此，在strict模式下，你会得到一个错误：</p>
<pre><code>‘use strict’;

var xiaoming = &#123;
    name: ‘小明’,
    birth: 1990,
    age: function () &#123;
        var y = new Date().getFullYear();
        return y - this.birth;
    &#125;
&#125;;
var fn = xiaoming.age;
fn(); // Uncaught TypeError: Cannot read property ‘birth’ of undefined
</code></pre>
<p>这个决定只是让错误及时暴露出来，并没有解决this应该指向的正确位置。</p>
<p>有些时候，喜欢重构的你把方法重构了一下：</p>
<pre><code>‘use strict’;

var xiaoming = &#123;
    name: ‘小明’,
    birth: 1990,
    age: function () &#123;
    function getAgeFromBirth() &#123;
        var y = new Date().getFullYear();
        return y - this.birth;
    &#125;
    return getAgeFromBirth();
    &#125;
&#125;;
xiaoming.age(); // Uncaught TypeError: Cannot read property ‘birth’ of undefined
</code></pre>
<p>结果又报错了！原因是this指针只在age方法的函数内指向xiaoming，在函数内部定义的函数，this又指向undefined了！（在非strict模式下，它重新指向全局对象window！）</p>
<p>修复的办法也不是没有，我们用一个that变量首先捕获this：</p>
<pre><code>‘use strict’;

var xiaoming = &#123;
    name: ‘小明’,
    birth: 1990,
    age: function () &#123;
        var that = this; // 在方法内部一开始就捕获this
        function getAgeFromBirth() &#123;
            var y = new Date().getFullYear();
            return y - that.birth; // 用that而不是this
        &#125;
        return getAgeFromBirth();
    &#125;
&#125;;
xiaoming.age(); // 25
</code></pre>
<p>用var that = this;，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。</p>
<h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p>虽然在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window，不过，我们还是可以控制this的指向的！</p>
<p>要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。</p>
<p>用apply修复getAge()调用：</p>
<pre><code>function getAge() &#123;
    var y = new Date().getFullYear();
    return y - this.birth;
&#125;

var xiaoming = &#123;
    name: ‘小明’,
    birth: 1990,
    age: getAge
&#125;;
xiaoming.age(); // 25
getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空
</code></pre>
<p>另一个与apply()类似的方法是call()，唯一区别是：</p>
<p>apply()把参数打包成Array再传入；</p>
<p>call()把参数按顺序传入。</p>
<p>比如调用Math.max(3, 5, 4)，分别用apply()和call()实现如下：</p>
<p>Math.max.apply(null, [3, 5, 4]); // 5<br>Math.max.call(null, 3, 5, 4); // 5<br>对普通函数调用，我们通常把this绑定为null。</p>
<h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><p>利用apply()，我们还可以动态改变函数的行为。</p>
<p>JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。</p>
<p>现在假定我们想统计一下代码一共调用了多少次parseInt()，可以把所有的调用都找出来，然后手动加上count += 1，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的parseInt()：</p>
<pre><code>var count = 0;
var oldParseInt = parseInt; // 保存原函数

window.parseInt = function () &#123;
count += 1;
return oldParseInt.apply(null, arguments); // 调用原函数
&#125;;

// 测试:
parseInt(‘10’);
parseInt(‘20’);
parseInt(‘30’);
count; // 3
</code></pre>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>content换行符与打点loading效果实例页面</title>
    <url>/2020/06/19/content%E6%8D%A2%E8%A1%8C%E7%AC%A6%E4%B8%8E%E6%89%93%E7%82%B9loading%E6%95%88%E6%9E%9C%E5%AE%9E%E4%BE%8B%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<p>代码如下：</p>
<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><span id="more"></span>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">dot &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block; </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: left;</span><br><span class="line">    <span class="attribute">vertical-align</span>: -.<span class="number">25em</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line">dot<span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;...\A..\A.&#x27;</span>;</span><br><span class="line">    <span class="attribute">white-space</span>: pre-wrap;</span><br><span class="line">    <span class="attribute">animation</span>: dot <span class="number">3s</span> infinite step-start both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> dot &#123;</span><br><span class="line">    <span class="number">33%</span> &#123; <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">2em</span>); &#125;</span><br><span class="line">    <span class="number">66%</span> &#123; <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">1em</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span>正在加载中<span class="tag">&lt;<span class="name">dot</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dot</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题</title>
    <url>/2016/06/23/count%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="count方法"><a href="#count方法" class="headerlink" title="count方法"></a>count方法</h3><p>封装一个count方法，能实现如此调用：count(a)(b)(c)(d)(e)… 并且返回的值为参数连乘的结果，即abcde*…。如count(1)(3)(7) 得到21</p>
<span id="more"></span>

<pre><code>function count(x)&#123;
    var fn = function(y)&#123;
        return count(x*y);
    &#125;
    fn.toString = function()&#123;
        return x;
    &#125;;
    return fn;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>css中overflow滑动效果在IOS中不流畅</title>
    <url>/2017/04/23/css%E4%B8%ADoverflow%E6%BB%91%E5%8A%A8%E6%95%88%E6%9E%9C%E5%9C%A8IOS%E4%B8%AD%E4%B8%8D%E6%B5%81%E7%95%85/</url>
    <content><![CDATA[<p>最近新作的一个项目中遇到一个问题，有一段很长的表格，手机显示器展示不全，需要做滑动继续展示的效果；<br>OK，很简单，使用overflow-x:auto;谷歌模拟器一切正常，安卓正常，可是打完包在IOS上，滑动效果慢到完全跟随手指的移动而移动，这样是肯定不行的经过百度发现了解决之道；<br>-webkit-overflow-scrolling: touch;<br>度娘说这句话是启动了硬件加速的特性，所以滑动起来会非常流畅；不过会影响性能；经过测试，发现影响看不出，果断选择用它；<br>完美解决~~~~~~~</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Flex布局</title>
    <url>/2018/08/01/flex%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p>
<span id="more"></span>
<h3 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h3><h4 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h4><p><span style="color: cornflowerblue">flex-direction属性决定主轴的方向（即项目的排列方向）。</span></p>
<ul>
<li>row（默认值）：主轴为水平方向，起点在左端。</li>
<li>row-reverse：主轴为水平方向，起点在右端。</li>
<li>column：主轴为垂直方向，起点在上沿。</li>
<li>column-reverse：主轴为垂直方向，起点在下沿。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#89479B</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>:row;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box box1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h4><p><span style="color: cornflowerblue">默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</span></p>
<ul>
<li>nowrap（默认）：不换行。</li>
<li>wrap：换行，第一行在上方。</li>
<li>wrap-reverse：换行，第一行在下方。</li>
</ul>
<h4 id="flex-flow属性"><a href="#flex-flow属性" class="headerlink" title="flex-flow属性"></a>flex-flow属性</h4><p><span style="color: cornflowerblue">flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。。</span></p>
<h4 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h4><p><span style="color: cornflowerblue">justify-content属性定义了项目在主轴上的对齐方式。</span></p>
<ul>
<li>flex-start（默认值）：左对齐</li>
<li>flex-end：右对齐</li>
<li>center： 居中</li>
<li>space-between：两端对齐，项目之间的间隔都相等。</li>
<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
<h4 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h4><p><span style="color: cornflowerblue">align-items属性定义项目在交叉轴上如何对齐</span></p>
<ul>
<li>flex-start：交叉轴的起点对齐。</li>
<li>flex-end：交叉轴的终点对齐。</li>
<li>center：交叉轴的中点对齐。</li>
<li>baseline: 项目的第一行文字的基线对齐。</li>
<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
<h4 id="align-content属性"><a href="#align-content属性" class="headerlink" title="align-content属性"></a>align-content属性</h4><p><span style="color: cornflowerblue">align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</span></p>
<ul>
<li>flex-start：与交叉轴的起点对齐。</li>
<li>flex-end：与交叉轴的终点对齐。</li>
<li>center：与交叉轴的中点对齐。</li>
<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li>stretch（默认值）：轴线占满整个交叉轴。</li>
</ul>
<h3 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h3><h4 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h4><p><span style="color: cornflowerblue">order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</span></p>
<h4 id="flex-grow属性"><a href="#flex-grow属性" class="headerlink" title="flex-grow属性"></a>flex-grow属性</h4><p><span style="color: cornflowerblue">flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</span><br>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
<h4 id="flex-shrink属性"><a href="#flex-shrink属性" class="headerlink" title="flex-shrink属性"></a>flex-shrink属性</h4><p><span style="color: cornflowerblue">flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</span><br>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。</p>
<h4 id="flex-basis属性"><a href="#flex-basis属性" class="headerlink" title="flex-basis属性"></a>flex-basis属性</h4><p><span style="color: cornflowerblue">flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</span><br>它可以设为跟width或height属性一样的值（比如100px），则项目将占据固定空间。</p>
<h4 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h4><p><span style="color: cornflowerblue">flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</span><br>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>
<h4 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h4><p><span style="color: cornflowerblue">align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</span><br>该属性可能取6个值，除了auto，其他都与align-items属性完全一致</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2015/07/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>hexo 常用命令</title>
    <url>/2016/06/28/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="常用部署步骤"><a href="#常用部署步骤" class="headerlink" title="常用部署步骤"></a>常用部署步骤</h2><blockquote>
<p>每次部署的步骤，可按以下三步来进行。</p>
</blockquote>
<pre><code>hexo clean
hexo generate
hexo deploy
</code></pre>
<span id="more"></span>
<h6 id="一些常用命令："><a href="#一些常用命令：" class="headerlink" title="一些常用命令："></a>一些常用命令：</h6><pre><code>hexo new ”postName” #新建文章

hexo new page ”pageName” #新建页面

hexo generate #生成静态页面至public目录

hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）

hexo deploy #将.deploy目录部署到GitHub

hexo help # 查看帮助

hexo version #查看Hexo的版本
</code></pre>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Markdown的基本用法</title>
    <url>/2018/07/11/markerdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>Markdown 是一种文本格式。你可以用它来控制文档的显示。使用 markdown，你可以创建粗体的文字，斜体的文字，添加图片，并且创建列表 等等。基本上来讲，Markdown 就是普通的文字加上 # 或者 * 等符号。</p>
<span id="more"></span>

<h3 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h3><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># 这是</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">  一级标题 ## 这是</span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><br><span class="line">    二级标题 ### 这是</span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><br><span class="line">      三级标题 #### 这是</span><br><span class="line">      <span class="tag">&lt;<span class="name">h4</span>&gt;</span></span><br><span class="line">        四级标题 ##### 这是</span><br><span class="line">        <span class="tag">&lt;<span class="name">h5</span>&gt;</span></span><br><span class="line">          五级标题 ###### 这是</span><br><span class="line">          <span class="tag">&lt;<span class="name">h6</span>&gt;</span>六级标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">*这会是 斜体 的文字* _这会是 斜体 的文字_ **这会是 粗体 的文字** __这会是 粗体</span><br><span class="line">的文字__ _你也 **组合** 这些符号_ ~~这个文字将会被横线删除~~</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">- Item 1 - Item 2 - Item 2a - Item 2b</span><br></pre></td></tr></table></figure>

<h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1. Item 1 1. Item 2 1. Item 3 1. Item 3a 1. Item 3b</span><br></pre></td></tr></table></figure>

<h4 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">![GitHub Logo](/images/logo.png) Format: ![Alt Text](url)</span><br></pre></td></tr></table></figure>

<p>测试图片：<br><img src="/uploads/author.jpg" alt="GitHub Logo"></p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">https://github.com - 自动生成！ [GitHub](https://github.com)</span><br></pre></td></tr></table></figure>

<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">正如 Kanye West 所说： &gt; We&#x27;re living the future so &gt; the present is our past.</span><br></pre></td></tr></table></figure>

<h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">如下，三个或者更多的: 连字符: --- 星号: *** 下划线: ___</span><br></pre></td></tr></table></figure>

<h4 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">我觉得你应该在这里使用 `function()&#123;console.log(&#x27;行内代码&#x27;)&#125;` 才对。</span><br></pre></td></tr></table></figure>

<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>你可以在你的代码上面和下面添加 ``` 来表示代码块</p>
<h5 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h5><p>代码块可以添加任何一种语言的语法高亮，如：</p>
<figure class="highlight javascript"><figcaption><span>&#123;.class1 .class&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="代码行数"><a href="#代码行数" class="headerlink" title="代码行数"></a>代码行数</h5><p>如果你想要你的代码块显示代码行数，只要添加 line-numbers class 就可以了。例如：</p>
<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以通过添加 highlight 属性的方式来高亮代码行数，例如：</p>
<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers, highlight</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> number = add(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<h4 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">- [x] @mentions, #refs, [links](), **formatting**, and <span class="tag">&lt;<span class="name">del</span>&gt;</span>tags<span class="tag">&lt;/<span class="name">del</span>&gt;</span> supported</span><br><span class="line">- [x] list syntax required (any unordered or ordered list supported) - [x] this</span><br><span class="line">is a complete item - [ ] this is an incomplete item</span><br></pre></td></tr></table></figure>

<ul>
<li><input checked="" disabled="" type="checkbox"> @mentions, #refs, <a href="">links</a>, <strong>formatting</strong>, and <del>tags</del> supported</li>
<li><input checked="" disabled="" type="checkbox"> list syntax required (any unordered or ordered list supported)</li>
<li><input checked="" disabled="" type="checkbox"> this is a complete item</li>
<li><input disabled="" type="checkbox"> this is an incomplete item</li>
</ul>
<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">First Header | Second Header ------------ | ------------- Content from cell 1 |</span><br><span class="line">Content from cell 2 Content in the first column | Content in the second column</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>First Header</th>
<th>Second Header</th>
</tr>
</thead>
<tbody><tr>
<td>Content from cell 1</td>
<td>Content from cell 2</td>
</tr>
<tr>
<td>Content in the first column</td>
<td>Content in the second column</td>
</tr>
</tbody></table>
<h3 id="扩展的语法"><a href="#扩展的语法" class="headerlink" title="扩展的语法"></a>扩展的语法</h3><h4 id="Emoji-amp-Font-Awesome"><a href="#Emoji-amp-Font-Awesome" class="headerlink" title="Emoji &amp; Font-Awesome"></a>Emoji &amp; Font-Awesome</h4><p>只适用于 markdown-it parser 而不适用于 pandoc parser。 缺省下是启用的。你可以在插件设置里禁用此功能。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">:smile: :fa-car:</span><br></pre></td></tr></table></figure>

<p>:smile:<br>:fa-car:</p>
<h4 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">30^th^</span><br></pre></td></tr></table></figure>

<p>30^th^</p>
<h4 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">H~2~O</span><br></pre></td></tr></table></figure>

<p>H<del>2</del>O</p>
<h4 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Content [^1] [^1]: Hi! This is a footnote</span><br></pre></td></tr></table></figure>

<p>Content [^1]<br>[^1]: Hi! This is a footnote</p>
<h4 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">==marked==</span><br></pre></td></tr></table></figure>

<p>==marked==</p>
<h4 id="数字角标"><a href="#数字角标" class="headerlink" title="数字角标"></a>数字角标</h4><p>2⁻⁰¹²³⁴⁵⁶⁷⁸⁹</p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法学习</title>
    <url>/2016/06/13/next_study/</url>
    <content><![CDATA[<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><pre><code># 这是 H1 #

## 这是 H2 ##

### 这是 H3 ######
</code></pre>
<span id="more"></span>
<h3 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h3><pre><code>&gt;This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
&gt;&gt;Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
&gt; 
&gt; 1.   这是第一行列表项。
&gt; 2.   这是第二行列表项。
&gt; 
&gt; 给出一些例子代码：
&gt; 
&gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);
</code></pre>
<blockquote>
<p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,<br>consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</p>
<blockquote>
<p>Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>
</blockquote>
<ol>
<li>  这是第一行列表项。</li>
<li>  这是第二行列表项。</li>
</ol>
<p>给出一些例子代码：</p>
<pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);
</code></pre>
</blockquote>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><pre><code>&gt;&gt; * Red
* Green
* Blue
&gt;&gt; + Tom
+ Jack 
+ Jerry
&gt;&gt; + 张三丰
+ 张翠山
+ 张无忌
&gt; 有序列表 1.
&gt;&gt; 1.  Bird
2.  McHale
3.  Parish

&gt; 1.  This is a list item with two paragraphs. Lorem ipsum dolor
    sit amet, consectetuer adipiscing elit. Aliquam hendrerit
    mi posuere lectus.

&gt;   Vestibulum enim wisi, viverra nec, fringilla in, laoreet
    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
    sit amet velit.

&gt; 2.  Suspendisse id sem consectetuer libero luctus adipiscing.
1986\. What a great season.
</code></pre>
<blockquote>
<p>无序列表 *,+,-</p>
<blockquote>
<ul>
<li>Red</li>
</ul>
</blockquote>
</blockquote>
<ul>
<li>Green</li>
<li>Blue<blockquote>
<blockquote>
<ul>
<li>Tom</li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
<ul>
<li>Jack </li>
<li>Jerry<blockquote>
<blockquote>
<ul>
<li>张三丰</li>
</ul>
</blockquote>
</blockquote>
</li>
<li>张翠山</li>
<li>张无忌<blockquote>
<p>有序列表 1.</p>
<blockquote>
<ol>
<li> Bird</li>
</ol>
</blockquote>
</blockquote>
</li>
</ul>
<ol start="2">
<li> McHale</li>
<li> Parish</li>
</ol>
<blockquote>
<ol>
<li>This is a list item with two paragraphs. Lorem ipsum dolor<br> sit amet, consectetuer adipiscing elit. Aliquam hendrerit<br> mi posuere lectus.</li>
</ol>
</blockquote>
<blockquote>
<p>  Vestibulum enim wisi, viverra nec, fringilla in, laoreet<br>    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum<br>    sit amet velit.</p>
</blockquote>
<blockquote>
<ol start="2">
<li> Suspendisse id sem consectetuer libero luctus adipiscing.<br>1986. What a great season.</li>
</ol>
</blockquote>
<h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>这是一个普通的段落：</p>
<pre><code>这是一个代码区块
&lt;div class=&quot;footer&quot;&gt;
    &amp;copy; 2004 Foo Corporation
&lt;/div&gt;
</code></pre>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>

<pre><code>* * *

***

*****

- - -

---------------------------------------
</code></pre>
<hr/>

<h3>区段元素</h3>
> #### 链接
<p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。
不管是哪一种，链接文字都是用 [方括号] 来标记。
要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：</p>
>
>     This is [an example](http://example.com/ "Title") inline link.
> 
>     [This link](http://example.net/) has no title attribute.
> 会产生
> This is [an example](https://munachar.github.io/404.html "Title") inline link.
> 
> [This link](http://www.baidu.com/) has no title attribute.
> 下面是一个参考式链接的范例：
>
>      I get 10 times more traffic from [Google] [1] than from[Yahoo] [2] or [MSN] [3].
>
>          [1]: http://google.com/        "Google"
>          [2]: http://search.yahoo.com/  "Yahoo Search"
>          [3]: http://search.msn.com/    "MSN Search" 
> 或者：
>
>     I get 10 times more traffic from [Google][] than from[Yahoo][] or [MSN][].
>
>          [google]: http://google.com/        "Google"
>          [yahoo]:  http://search.yahoo.com/  "Yahoo Search"
>          [msn]:    http://search.msn.com/    "MSN Search"br
> #### 强调
<p>Markdown 使用星号（\*）和底线（\_）作为标记强调字词的符号，被 \* 或 \_ 包围的字词会被转成用 <\em\> 标签包围，用两个 \* 或 \_ 包起来的话，则会被转成 <strong>，例如：</p>
>
>     *single asterisks*
>
>     _single underscores_
>
>     **double asterisks**
>
>     __double underscores__
>效果如下：
> *single asterisks*
>
> _single underscores_
>
> **double asterisks**
>
> __double underscores__
> #### 代码
如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如：
>
>     Use the `printf()` function.
效果如下：
> Use the `printf()` function.
> A single backtick in a code span: `` ` ``
>
> A backtick-delimited string in a code span: `` `<foo>` ``
> #### 图片
Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。

<blockquote>
<p>行内式的图片语法看起来像是：</p>
<pre><code>![Alt text](/path/to/img.jpg)

![Alt text](/path/to/img.jpg &quot;Optional title&quot;)
</code></pre>
<p>详细叙述如下：</p>
<ul>
<li>一个惊叹号 !</li>
<li>接着一个方括号，里面放上图片的替代文字</li>
<li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。</li>
</ul>
</blockquote>
<blockquote>
<p>参考式的图片语法则长得像这样：</p>
</blockquote>
<pre>![Alt text][id]</pre>
<blockquote>
<p>「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：</p>
<pre><code>[id]: url/to/image  &quot;Optional title attribute&quot;
</code></pre>
<p>到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 <img> 标签。</p>
</blockquote>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><blockquote>
<h4 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h4><p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p>
<pre><code>&lt;http://example.com/&gt;
</code></pre>
<p>Markdown 会转为：</p>
<pre><code>&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;
</code></pre>
<p>邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：</p>
<pre><code>&lt;address@example.com&gt;
</code></pre>
<p>Markdown 会转成：</p>
<pre><code> &lt;a href=&quot;&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;
&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;
&amp;#109;&quot;&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;
&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;
</code></pre>
<p>在浏览器里面，这段字串（其实是 <a href="mailto:address@example.com">address@example.com</a>）会变成一个可以点击的「<a href="mailto:&#x61;&#100;&#x64;&#x72;&#x65;&#x73;&#115;&#x40;&#101;&#x78;&#x61;&#x6d;&#112;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;">&#x61;&#100;&#x64;&#x72;&#x65;&#x73;&#115;&#x40;&#101;&#x78;&#x61;&#x6d;&#112;&#108;&#x65;&#x2e;&#99;&#111;&#x6d;</a>」链接。</p>
</blockquote>
<p>（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）</p>
<blockquote>
<h4 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h4><p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 <em> 标签），你可以在星号的前面加上反斜杠：</p>
<pre><code>\*literal asterisks\*
</code></pre>
<p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p>
<pre><code>\   反斜线
`   反引号
*   星号
_   底线
&#123;&#125;  花括号
[]  方括号
()  括弧
#   井字号
+   加号
-   减号
.   英文句点
!   惊叹号
</code></pre>
</blockquote>
]]></content>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>postName</title>
    <url>/2015/08/12/postName/</url>
    <content><![CDATA[<pre><code>1. Git安装和Github设置
使用Mac电脑可以直brew安装,
</code></pre>
<span id="more"></span>

<pre><code>brew install git         #Mac电脑使用brew安装
sudo apt-get install git #Ubuntu系统使用这条命令安装
git操作和github上SSH设置请看这篇博文

使用Github Page搭建博客, 需要遵循一定的规则, 需要在github建立仓库,仓库名为Github用户.github.io, 更多详情请参考官方文档

2. Node.js安装
mac电脑可以直接通过brew安装

#安装命令
brew install node  #如果我没记错的话,最新版的node.js的包中已经集成了npm包管理工具

使用以下命令验证是否安装成功
node -v
npm -v

文／Andrew_liu（简书作者）
原文链接：http://www.jianshu.com/p/858ecf233db9
著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。
</code></pre>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>postcss-pxtorem的使用</title>
    <url>/2020/11/11/postcss-pxtorem%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>最近公司要开发一个H5的项目，这里用postcss-pxtorem来处理自适应的问题；</p>
<blockquote>
<p>postcss-pxtorem是PostCSS的插件，用于将像素单元生成rem单位。前端开发还原设计稿的重要性毋庸置疑，目前应用的单位最多还是rem,然而每次在制作过程中需要自己计算rem值，为了能够直接按照设计图的尺寸开发，并且能自动编译转换成rem，下面就来分享下postcss-pxtorem的使用。</p>
</blockquote>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install postcss-pxtorem -D</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="设置规则"><a href="#设置规则" class="headerlink" title="设置规则"></a>设置规则</h2><p>更改postcss.config.js,该文件为使用vue-cli3自动创建的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    &#x27;autoprefixer&#x27;: &#123; // autoprefixer 是自动补全代码用的</span><br><span class="line">      browsers: [&#x27;Android &gt;= 4.0&#x27;, &#x27;iOS &gt;= 7&#x27;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x27;postcss-pxtorem&#x27;: &#123;</span><br><span class="line">      rootValue: 16,//结果为：设计稿元素尺寸/16，比如元素宽320px,最终页面会换算成 20rem</span><br><span class="line">      propList: [&#x27;*&#x27;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="设置根节点"><a href="#设置根节点" class="headerlink" title="设置根节点"></a>设置根节点</h2><p>首先我们要在src目录下，新建 assets/js/rem.js文件；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> e = <span class="built_in">document</span>.documentElement || <span class="built_in">document</span>.body,</span><br><span class="line">    a = <span class="string">&quot;orientationchange&quot;</span> <span class="keyword">in</span> <span class="built_in">window</span> ? <span class="string">&quot;orientationchange&quot;</span> : <span class="string">&quot;resize&quot;</span>,</span><br><span class="line">    b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> f = e.clientWidth;</span><br><span class="line">      <span class="comment">// 320 默认大小16px; 320px = 20rem ;每个元素px基础上/16</span></span><br><span class="line">      e.style.fontSize = f / <span class="number">20</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  b();</span><br><span class="line">  c.addEventListener(a, b, <span class="literal">false</span>);</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后在main.js中引入rem.js就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;@assets/js/rem&quot;</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>vue</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>事件冒泡</title>
    <url>/2016/06/25/%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1/</url>
    <content><![CDATA[<h3 id="什么是JS事件冒泡？"><a href="#什么是JS事件冒泡？" class="headerlink" title="什么是JS事件冒泡？"></a>什么是JS事件冒泡？</h3><p>在一个对象上触发某类事件（比如单击onclick事件），如果此对象定义了此事件的处理程序，那么此事件就会调用这个处理程序，如果没有定义此事件处理程序或者事件返回true，那么这个事件会向这个对象的父级对象传播，从里到外，直至它被处理（父级对象所有同类事件都将被激活），或者它到达了对象层次的最顶层，即document对象（有些浏览器是window）。</p>
<span id="more"></span>

<ol>
<li><p>event.stopPropagation();<br>事件处理过程中，阻止了事件冒泡，但不会阻击默认行为（它就执行了超链接的跳转）</p>
</li>
<li><p>return false;<br>事件处理过程中，阻止了事件冒泡，也阻止了默认行为（比如刚才它就没有执行超链接的跳转）</p>
</li>
<li><p>event.preventDefault();<br>如果把它放在头部A标签的click事件中点击“点击我”。<br>会发现它依次弹出：我是最里层—-&gt;我是中间层—-&gt;我是最外层，但最后却没有跳转到百度<br>它的作用是：事件处理过程中，不阻击事件冒泡，但阻击默认行为（它只执行所有弹框，却没有执行超链接跳转）</p>
</li>
</ol>
<hr>
<h3 id="事件周期"><a href="#事件周期" class="headerlink" title="事件周期:"></a>事件周期:</h3><blockquote>
<p>DOM: 3个阶段:</p>
<blockquote>
<ul>
<li>捕获: 由最外层元素向内，逐级记录绑定的事件处理函数，只是记录，而不触发</li>
</ul>
</blockquote>
</blockquote>
<ul>
<li>目标触发: 首先触发实际发生事件的元素上绑定的处理函数（目标元素: 实际发生事件的元素）</li>
<li>冒泡: 由内层向外层依次执行各级绑定的处理函数<blockquote>
<p>鄙视:能否修改事件触发的顺序: ——能！</p>
<pre><code> elem.addEventListener(“事件名”,函数对象,false/true);
</code></pre>
<p>第三个参数: 是否在捕获阶段提前触发，<br>默认false，只能在冒泡阶段顺序触发<br>改为true，可在捕获阶段提前触发！<br>在捕获阶段提前触发的处理函数，冒泡阶段不会重复触发。<br>IE8: 2个阶段: 没有捕获！——不能修改事件触发的顺序<br>elem.attachEvent(“on事件名”,函数对象)</p>
</blockquote>
</li>
</ul>
<h3 id="取消冒泡"><a href="#取消冒泡" class="headerlink" title="取消冒泡"></a>取消冒泡</h3><blockquote>
<p>取消冒泡: 一般用于事件处理函数的末尾</p>
<pre><code>DOM: e.stopPropagation();
IE8: e.cancelBubble=true;
</code></pre>
<p>兼容: </p>
<pre><code>if(e.stopPropagation!==undefined)&#123;
    e.stopPropagation();
&#125;else&#123;
    e.cancelBubble=true;
&#125;
</code></pre>
<p>利用冒泡:<br>优化: 如果多个平级子元素都绑定了相同的事件处理函数，则只需要在父元素上绑定一次即可。不必反复绑定！<br>为什么: 绑定的事件处理函数越多，页面的执行效率越低。应尽量减少页面中绑定的事件处理函数个数。<br>核心问题：如何获得目标元素:</p>
<pre><code>var target=e.target||e.srcElement
</code></pre>
</blockquote>
<h3 id="DOM-IE8"><a href="#DOM-IE8" class="headerlink" title="DOM IE8"></a>DOM IE8</h3><blockquote>
<p>取消事件: 在事件处理函数执行过程中，发生了异常或错误，希望事件不再继续触发。<br>如何取消:<br>   js动态绑定事件处理函数: </p>
<pre><code>DOM: e.preventDefault();
IE8: e.returnValue=false;
</code></pre>
<p>兼容: </p>
<pre><code>if(e.preventDefault!==undefined)&#123;
    e.preventDefault();
&#125;else&#123;
    e.returnValue=false;
&#125; 
</code></pre>
</blockquote>
<p>参考网址：<a href="http://www.jb51.net/article/32792.htm">事件冒泡</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>关于CSS hacks的使用</title>
    <url>/2016/07/10/%E5%85%B3%E4%BA%8ECSS%20hack/</url>
    <content><![CDATA[<h4 id="讨论CSS-hacks，条件引用或者其他。"><a href="#讨论CSS-hacks，条件引用或者其他。" class="headerlink" title="讨论CSS hacks，条件引用或者其他。"></a>讨论CSS hacks，条件引用或者其他。</h4><span id="more"></span>
<pre><code>background-color:#f1ee18;/*所有识别*/

background-color:#00deff\9; /*IE6、7、8识别*/

+background-color:#a200ff;/*IE6、7识别*/

_background-color:#1e0bd1;/*IE6识别*/

:root#test&#123;background-color:purple\9;&#125;:root是给ie9的，

@media screen and (-webkit-min-device-pixel-ratio:0)&#123;
    .bb&#123;background-color:#f1ee18&#125;/* Safari(Chrome) 有效 */
&#125;&#123;&#125; 
@media all and (min-width: 0px)&#123; 
    .bb&#123;
        background-color:#f1ee18;/*opera and Safari(Chrome) and firefox*/ 
        background-color:#4cac70\0;/* 仅 Opera 有效 */ 
    &#125;
&#125;&#123;&#125; 

.bb, x:-moz-any-link, x:default&#123;
    background-color:#4eff00;/*IE7、Firefox3.5及以下 识别 */
&#125; 
@-moz-document url-prefix()&#123;
    .bb&#123;
        background-color:#4eff00;/*仅 Firefox 识别 */
    &#125;
&#125; 
* +html .bb&#123;background-color:#a200ff;&#125;/* 仅IE7 识别 */&lt;!-- more --&gt;    
</code></pre>
<p><img src="/uploads/CSS_hack.png" alt="GitHub Logo"></p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>关于vue中mixins混入的用法</title>
    <url>/2020/06/22/%E5%85%B3%E4%BA%8Emixins%E6%B7%B7%E5%85%A5%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>最近项目中要用到很多eCharts图表组件，需要在窗口尺寸发生变化时，重置图表的大小，此时如果在每个组件里面都去实现一段监听代码，代码重复太多了，此时就可以使用混入来解决这个问题，mixins是Vue提供的一种混合机制，用来更高效的实现组件内容的复用。</p>
<span id="more"></span>

<h1 id="JS代码："><a href="#JS代码：" class="headerlink" title="JS代码："></a>JS代码：</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 混入代码</span></span><br><span class="line"><span class="keyword">import</span> &#123; debounce &#125; <span class="keyword">from</span> <span class="string">&quot;lodash&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> resizeChartMethod = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 在组件内部将图表init的引用映射到chart属性上</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">myChart</span>: <span class="literal">null</span>,</span><br><span class="line">      [resizeChartMethod]: <span class="literal">null</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span>;</span><br><span class="line">    <span class="built_in">this</span>[resizeChartMethod] = debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (_this.myChart) &#123;</span><br><span class="line">        _this.myChart.resize();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, <span class="built_in">this</span>[resizeChartMethod]);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">beforeDestroy</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">&quot;reisze&quot;</span>, <span class="built_in">this</span>[resizeChartMethod]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="图表组件代码"><a href="#图表组件代码" class="headerlink" title="图表组件代码"></a>图表组件代码</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;chart&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> echartMixins <span class="keyword">from</span> <span class="string">&#x27;./echarts-mixins&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// mixins属性用于导入混入，是一个数组，数组可以传入多个混入对象</span></span><br><span class="line">  <span class="attr">mixins</span>: [echartMixins],</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">chart</span>: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.chart = echarts.init(<span class="built_in">this</span>.$el)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title>Web前端资源分享</title>
    <url>/2016/07/04/%E5%89%8D%E7%AB%AF%E8%B5%84%E6%BA%90%E7%BD%91/</url>
    <content><![CDATA[<p>Web前端资源分享：</p>
<ul>
<li>官方：<ul>
<li>W3C：<a href="http://www.w3.org/">http://www.w3.org/</a></li>
<li>ECMA：<a href="http://www.ecmascript.org/">http://www.ecmascript.org/</a></li>
<li>Mozilla：<a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a></li>
</ul>
</li>
<li>微软提供的H5实验室：<br><a href="http://html5labs.interoperabilitybridges.com/">http://html5labs.interoperabilitybridges.com/</a><span id="more"></span></li>
<li>第三方国内：<ul>
<li>前端网：<a href="http://www.w3cfuns.com/portal.php">http://www.w3cfuns.com/portal.php</a></li>
<li>H5基地：<a href="http://html5.360.cn/">http://html5.360.cn/</a></li>
<li>前端里：<a href="http://www.yyyweb.com/">http://www.yyyweb.com</a></li>
</ul>
</li>
<li>国内各大公司前端团队博客：<ul>
<li>携程：<a href="http://ued.ctrip.com/blog/">http://ued.ctrip.com/blog/</a></li>
<li>网易：<a href="http://uedc.163.com/">http://uedc.163.com</a></li>
<li>腾讯：<ul>
<li><a href="http://isux.tencent.com/">http://isux.tencent.com</a></li>
<li><a href="http://www.alloyteam.com/">http://www.alloyteam.com</a></li>
</ul>
</li>
<li>百度：<ul>
<li><a href="http://fex.baidu.com/">http://fex.baidu.com</a></li>
<li><a href="http://efe.baidu.com/">http://efe.baidu.com</a></li>
<li><a href="http://mweb.baidu.com/">http://mweb.baidu.com</a></li>
</ul>
</li>
<li>淘宝：<a href="http://ued.taobao.org/blog/">http://ued.taobao.org/blog/</a></li>
<li>360：<a href="http://www.75team.com/">http://www.75team.com</a></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title>【加载更多】插件</title>
    <url>/2017/08/15/%E5%8A%A0%E8%BD%BD%E6%9B%B4%E5%A4%9A%E6%8F%92%E4%BB%B6%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<p>关于如何实现『加载更多』功能，网上有插件可用，例如比较著名的使用iscroll.js实现的上拉加载更多、下拉刷新功能。</p>
<p>但实际用起来却是很麻烦。由于是第三方插件，要按照对方定义的方法使用，用起来总感觉很不顺心。再加上iscroll.js本身并没有集成加载更多的功能，需要进行自行扩展。想继续使用iscroll.js实现加载更多功能的，上面给的链接可以看看。</p>
<p>h5项目里需要实现简单的分页功能，由于是移动端，考虑用『加载更多』会更好，而不是PC端的翻页。</p>
<hr>
<span id="more"></span>
<p><strong>JS代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * loadmore.js</span></span><br><span class="line"><span class="comment"> * 加载更多</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @time 2017-7-08 15:40:25</span></span><br><span class="line"><span class="comment"> * @author munachar</span></span><br><span class="line"><span class="comment"> * 可以传的参数默认有：size,scroll 可以自定义</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">w,$</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">var</span> loadmore = &#123;</span><br><span class="line">         <span class="comment">/*单页加载更多 通用方法</span></span><br><span class="line"><span class="comment">          *</span></span><br><span class="line"><span class="comment">          * @param callback 回调方法</span></span><br><span class="line"><span class="comment">          * @param config 自定义参数</span></span><br><span class="line"><span class="comment">          * */</span></span><br><span class="line">         <span class="attr">get</span> : <span class="function"><span class="keyword">function</span>(<span class="params">callback, config</span>)</span>&#123;</span><br><span class="line">             <span class="keyword">var</span> config = config ? config : &#123;&#125;; <span class="comment">/*防止未传参数报错*/</span></span><br><span class="line">             <span class="keyword">var</span> counter = <span class="number">1</span>; <span class="comment">/*计数器*/</span></span><br><span class="line">             <span class="keyword">var</span> pageStart = config.size ? config.size : <span class="number">10</span>;</span><br><span class="line">             <span class="keyword">var</span> pageSize = config.size ? config.size : <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">             <span class="comment">/*通过自动监听滚动事件加载更多,可选支持*/</span></span><br><span class="line">             config.isEnd = <span class="literal">false</span>; <span class="comment">/*结束标志*/</span></span><br><span class="line">             config.isAjax = <span class="literal">false</span>; <span class="comment">/*防止滚动过快，服务端没来得及响应造成多次请求*/</span></span><br><span class="line">             $(config.ele).scroll(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                 <span class="comment">/*是否开启滚动加载*/</span></span><br><span class="line">                 <span class="keyword">if</span>(!config.scroll)&#123;</span><br><span class="line">                     <span class="keyword">return</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">/*滚动加载时如果已经没有更多的数据了、正在发生请求时，不能继续进行*/</span></span><br><span class="line">                 <span class="keyword">if</span>(config.isEnd == <span class="literal">true</span> || config.isAjax == <span class="literal">true</span>)&#123;</span><br><span class="line">                     <span class="keyword">return</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">/*当滚动到最底部以上100像素时， 加载新内容*/</span></span><br><span class="line">                 <span class="keyword">if</span> ($(<span class="built_in">this</span>).find(<span class="string">&quot;ul&quot;</span>).height() - $(<span class="built_in">this</span>).scrollTop() - $(<span class="built_in">this</span>).height()&lt;<span class="number">100</span>)&#123;</span><br><span class="line">                     counter ++;</span><br><span class="line">                     pageStart = counter * pageSize;</span><br><span class="line">                     callback &amp;&amp; callback.call( $(config.ele),config, pageStart, pageSize);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">             <span class="comment">/*第一次自动加载*/</span></span><br><span class="line">             callback &amp;&amp; callback.call( $(config.ele),config, pageStart, pageSize);</span><br><span class="line">         &#125;,</span><br><span class="line">     &#125;</span><br><span class="line">     $.loadmore = loadmore;</span><br><span class="line"> &#125;)(<span class="built_in">window</span>, <span class="built_in">window</span>.jQuery || <span class="built_in">window</span>.Zepto);</span><br></pre></td></tr></table></figure>
<p><strong>如何调用：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.loadmore.get(getData, &#123;</span><br><span class="line">                <span class="attr">ele</span>:<span class="built_in">window</span>,  <span class="comment">// 绑定滚动监听元素 默认是window</span></span><br><span class="line">                <span class="attr">scroll</span>: <span class="literal">true</span>,  <span class="comment">//默认是false,是否支持滚动加载</span></span><br><span class="line">                <span class="attr">size</span>:<span class="number">10</span>,  <span class="comment">//默认是10</span></span><br><span class="line">                <span class="attr">flag</span>: <span class="number">1</span>, <span class="comment">//自定义参数，可选，示例里没有用到</span></span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>
<p>第一个参数是回调函数，即我们的业务逻辑。我把我的业务逻辑方法贴出来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">config, offset,size</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    config.isAjax = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;json/blog.json&#x27;</span>,</span><br><span class="line">        <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">        <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">reponse</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">            config.isAjax = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> data = reponse.list;</span><br><span class="line">            <span class="keyword">var</span> sum = reponse.list.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/************业务逻辑块：实现拼接html内容并append到页面*****************/</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//console.log(offset , size, sum);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*如果剩下的记录数不够分页，就让分页数取剩下的记录数</span></span><br><span class="line"><span class="comment">            * 例如分页数是5，只剩2条，则只取2条</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * 实际MySQL查询时不写这个</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(sum - offset &lt; size )&#123;</span><br><span class="line">                size = sum - offset;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*使用for循环模拟SQL里的limit(offset,size)*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i=offset; i&lt; (offset+size); i++)&#123;</span><br><span class="line">                result +=<span class="string">&#x27;&lt;div class=&quot;weui_media_box weui_media_text&quot;&gt;&#x27;</span>+</span><br><span class="line">                        <span class="string">&#x27;&lt;a href=&quot;&#x27;</span>+ data[i].url +<span class="string">&#x27;&quot; target=&quot;_blank&quot;&gt;&lt;h4 class=&quot;weui_media_title&quot;&gt;&#x27;</span>+ data[i].title +<span class="string">&#x27;&lt;/h4&gt;&lt;/a&gt;&#x27;</span>+</span><br><span class="line">                        <span class="string">&#x27;&lt;p class=&quot;weui_media_desc&quot;&gt;&#x27;</span>+ data[i].desc +<span class="string">&#x27;&lt;/p&gt;&#x27;</span>+</span><br><span class="line">                    <span class="string">&#x27;&lt;/div&gt;&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $(<span class="string">&#x27;.js-blog-list&#x27;</span>).append(result);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*******************************************/</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*隐藏more*/</span></span><br><span class="line">            <span class="keyword">if</span> ( (offset + size) &gt;= sum)&#123;</span><br><span class="line">                $(<span class="string">&quot;.js-load-more&quot;</span>).hide();</span><br><span class="line">                config.isEnd = <span class="literal">true</span>; <span class="comment">/*停止滚动加载请求*/</span></span><br><span class="line">                <span class="comment">//提示没有了</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                $(<span class="string">&quot;.js-load-more&quot;</span>).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">xhr, type</span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">&#x27;Ajax error!&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上仅贴出核心代码，详细案列：<a href="https://github.com/hedahang/loadingMoreUp">@Munachar</a></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>双飞翼布局和圣杯布局</title>
    <url>/2017/06/23/%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80%E5%92%8C%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="双飞翼布局和圣杯布局"><a href="#双飞翼布局和圣杯布局" class="headerlink" title="双飞翼布局和圣杯布局"></a>双飞翼布局和圣杯布局</h1><p><br><strong>圣杯布局和双飞翼布局</strong>基本上是一致的，都是两边固定宽度，中间自适应的三栏布局，其中，中间栏放到文档流前面，保证先行渲染。解决方案大体相同，都是三栏全部float:left浮动，区别在于解决中间栏div的内容不被遮挡上，圣杯布局是中间栏在添加相对定位，并配合left和right属性，效果上表现为三栏是单独分开的（如果可以看到空隙的话），而双飞翼布局是在中间栏的div中嵌套一个div，内容写在嵌套的div里，然后对嵌套的div设置margin-left和margin-right，效果上表现为左右两栏在中间栏的上面，中间栏还是100%宽度，只不过中间栏的内容通过margin的值显示在中间。</p>
<hr>
<span id="more"></span>

<h2 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h2><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">200px</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span>,<span class="selector-class">.left</span>,<span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#C899FF</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">60px</span> <span class="number">0</span> <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#EBAD5A</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#348F26</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">60px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>mainmainmainmain<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><h3 id="CSS-1"><a href="#CSS-1" class="headerlink" title="CSS"></a>CSS</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#hd</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#666</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#bd</span>&#123;</span><br><span class="line">    <span class="comment">/*左右栏通过添加负的margin放到正确的位置了，此段代码是为了摆正中间栏的位置*/</span></span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0</span> <span class="number">200px</span> <span class="number">0</span> <span class="number">180px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#middle</span>&#123;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;<span class="comment">/*左栏上去到第一行*/</span></span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>:blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span>&#123;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">180px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>:-<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>:<span class="number">#0c9</span>;</span><br><span class="line">    <span class="comment">/*中间栏的位置摆正之后，左栏的位置也相应右移，通过相对定位的left恢复到正确位置*/</span></span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">    <span class="attribute">left</span>:-<span class="number">180px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span>&#123;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>:-<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>:<span class="number">#0c9</span>;</span><br><span class="line">    <span class="comment">/*中间栏的位置摆正之后，右栏的位置也相应左移，通过相对定位的right恢复到正确位置*/</span></span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">    <span class="attribute">right</span>:-<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#footer</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#666</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HTML-1"><a href="#HTML-1" class="headerlink" title="HTML"></a>HTML</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;hd&quot;</span>&gt;</span>header<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;bd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;middle&quot;</span>&gt;</span>middle<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;left&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;right&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>布局</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Vue项目开发中遇到的坑及总结</title>
    <url>/2017/08/10/%E5%9F%BA%E4%BA%8EVue%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%E5%8F%8A%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>项目在5月底启动，属于创业公司的业务扩展吧，IOS和安卓都有成型的版本，所以要做一个对应的移动端H5版的达人、KTV、派对预订，入口是微信公众号，当然少不了jssdk的使用，以及balabala的授权处理等。</p>
<span id="more"></span>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><hr>最初是考虑用React+Redux+Webpack，前后端完全分离，但考虑到人手不足，前后端暂时做不了完全分离，然后还有对React也不熟悉，项目时间等问题，然后就被Boss否了。
最终用了更熟悉的Vue+Vuex+Webpack。主要还是因为更轻，API更加友好，上手速度更快，可以马上开工。
比较遗憾的是因为各种原因前后端分离还不是很彻底，前端用的是smarty模板加js渲染页面。好处是首屏数据可以放到script标签里面直出，在进度条读完的时候页面就能够渲染出来了，提高首屏渲染时间。但是调试的时候十分麻烦，因为没有Node做中间层，每次都要在本地完整地跑个服务器，不然拿不到数据。
Vue，Vuex，Vue-router，Webpack这些不了解的同学就去看看<a href="https://cn.vuejs.org/v2/guide/installation.html" target="_blank" rel="external">文档</a>。MV*框架用好了真的是极大地解放生产力，特别是页面的交互十分复杂的时候。

<h2 id="项目过程中遇到的坑"><a href="#项目过程中遇到的坑" class="headerlink" title="项目过程中遇到的坑"></a>项目过程中遇到的坑</h2><hr>
1. 遇到的第一个的坑就是transition。首页有一个滑动的banner，我是直接用css3的transition配合js定时改变transform实现的。滑动在chrome中模拟没问题，ios中没问题，但是安卓中就没有滑动，百思不得其解。起初还以为是兼容性问题，搞了好久才发现需要在css中先增加一个transform: translateX(0)，像下面一样，不然之后再通过js更改transform是没法在安卓中触发transition的。
<pre>
.slide-wp{
    transform:  translateX(0);
    -webkit-transform:  translateX(0);
    transition: transform  1.5s ease;
    -webkit-transition: transform 1.5s ease;
}
</pre>大家知道，transition的作用是令CSS的属性值在一定的时间区间内平滑地过渡。
所以个人猜测，在安卓中，当没有初始值时，translateX的改动没有被平滑地过渡，就是说transition并不知道translateX是从什么地方开始过渡的，所以也就没有平滑之说，也就没有动画了。
<hr>2. 第二个就是ES6。既然用了Webpack，当然就要配合Bebel用上ES6啦。写的时候还是很爽的。let，const，模块，箭头函数，字符串模版，对象属性简写，解构等等…但帅不过3秒，在chrome上模拟地跑一点问题都没有，一到移动端就直接白屏，页面都没有渲染出来。
排查了好久，才发现是某些扩展运算符...，某些解构和for...of...循环的问题。因为这些ES6的特性（其实不指这些）在Bebel中转换是要用到[Symbol.iterator]接口的。如下面这样。
转码前:
<pre>1.const [a, b, c, d, e] = 'hello';
2.console.log(a, b, c, d, e);//'h','e','l','l','o'</pre>
转码后:
<pre>1.'use strict';
2.var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();
3.
4.var _hello = 'hello';
5.
6.var _hello2 = _slicedToArray(_hello, 5);
7.
8.var a = _hello2[0];
9.var b = _hello2[1];
10.var c = _hello2[2];
11.var d = _hello2[3];
12.var e = _hello2[4];
13.
14.console.log(a, b, c, d, e);//'h','e','l','l','o'</pre>
第一行先声明的_slicedToArray函数用到了[Symbol.iterator]接口，然而浏览器对这个接口的支持还很有限，特别是移动端，只有Firefox Mobile36版本以上才支持，其它清一色挂掉。
所以说ES6虽好，但真要用到实际项目中的话，还不能太激进，有些特性经过Bebel转码后性能上可能还会有所下降，所以还是应该合理地使用ES6。如果是自己折腾倒无所谓，Symbol，Class，Generator，Promise这些就随便炫技吧
<hr>3. 第三个坑就是Vue使用的问题。如其说是坑，还是不如说是我自身还不够熟悉Vue。先看一下官方说明：
<br><code>受 ES5 的限制，Vue.js 不能检测到对象属性的添加或删除。因为 Vue.js 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue.js 转换它，才能让它是响应的。</code>
<br>当时需要在props传来的某些对象数据中增加一个是否可视属性，用来控制一个与其关联的弹出框。增加后点击视图上一点反应都没有，但是用console.log打印出来发现值的确的有变化的。
也就是说，<b>数据的变化不能触发视图更新。</b>原因就是如上面所说，因为这个属性是我后来添加的，不能被Vuejs检测到。这时候需要使用$set(key, value)这个API。
话说里面的语法需要注意下，第一个参数key是一个字符串，是一个keypath，如果假如你的数据是这样:<pre>data(){
            visitors : [{
                    "id": 1,
                    ...
                }, {
                    "id": 2,
                    ...
                }, {
                    "id": 3,
                    ...
                }],
        }
    </pre>
你需要在某次操作后为visitiors里面的每个对象增加一个show属性,则需要这样写：<pre>let str;
         for (let i = 0 , len = this.visitors.length ; i < len; i++) {
             str = "visitors[" + i + "].show";
             this.$set(str,true);
         }
    </pre>
之前真的被这东西搞了很久，明明数据变化了，视图却不更新。个人感觉新手刚使用Vue时很难发现这个问题。也怪自己对Vue，对ES5<code>getter/setter</code>的理解还不够吧。
<hr>4. IOS上CSS3动画的问题。在对img或者设置了background-image的DOM元素设置CSS动画时，动画在刚进入页面的时候有可能不被触发，需要滑动一下屏幕动画才动，安卓下则没有问题。
刚开始还以为是没有设置初始值的问题，但感觉不应该会是这样的。后来在stackoverflow上找到了解决办法(<a href="http://stackoverflow.com/questions/29219534/css-animation-not-always-starting-in-ios-8-safari" target="_blank" rel="external">戳这里</a>)。
给动画加个0.1s秒的延时<pre>animation: slide 1.5s 0.1s linear infinite;
    webkit-animation: slide 1.5s 0.1s linear infinite;
</pre>

<h2 id="关于Vuex"><a href="#关于Vuex" class="headerlink" title="关于Vuex"></a>关于Vuex</h2><hr>
Vuex 之于 vue，就相当于 Redux 之于 React。它是一套数据管理架构实现，用于解决在大型前端应用时数据流动，数据管理等问题。

<p>因为组件一旦多起来，不同组件之间的通信和数据流动会变得十分繁琐及难以追踪，特别是在子组件向同级子组件通信时，你可能需要先$dispatch到父组件，再$broadcast给子组件，整个事件流十分繁杂，也很难调试。<br>Vuex就是用来解决这些问题的。更具体的说明可以看文档，我就不过多叙述了。我就说一下我对Vuex的一些理解。</p>
<p>Vuex里面的数据流是单向的,就像官方说的那样：</p>
<ol>
<li>用户在组件中的输入操作触发 action 调用；</li>
<li>Actions 通过分发 mutations 来修改 store 实例的状态；</li>
<li>Store 实例的状态变化反过来又通过 getters 被组件获知。</li>
</ol>
<p>而且为了保证数据是单向流动，并且是可监控和可预测的，除了在mutation handlers 外，其它地方不允许直接修改 store 里面的 state。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>如何共享一个原型对象</title>
    <url>/2016/07/08/%E5%A6%82%E4%BD%95%E5%85%B1%E4%BA%AB%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>我们想创建一个Student构造函数：</p>
<pre><code>function Student(props) &#123;
    this.name = props.name || &#39;Unnamed&#39;;
&#125;
Student.prototype.hello = function () &#123;
    alert(&#39;Hello, &#39; + this.name + &#39;!&#39;);
&#125;
</code></pre>
<p>现在，我们要基于Student扩展出PrimaryStudent，可以先定义出PrimaryStudent：</p>
<pre><code>function PrimaryStudent(props) &#123;
    // 调用Student构造函数，绑定this变量:
    Student.call(this, props);
    this.grade = props.grade || 1;
&#125;
</code></pre>
<span id="more"></span>    
<p>但是，调用了Student构造函数不等于继承了Student，PrimaryStudent创建的对象的原型是：</p>
<pre><code>new PrimaryStudent() ----&gt; PrimaryStudent.prototype ----&gt; Object.prototype ----&gt; null
</code></pre>
<p>必须想办法把原型链修改为：</p>
<pre><code>new PrimaryStudent() ----&gt; PrimaryStudent.prototype ----&gt; Student.prototype ----&gt; Object.prototype ----&gt; null
</code></pre>
<p>这样，原型链对了，继承关系就对了。新的基于PrimaryStudent创建的对象不但能调用PrimaryStudent.prototype定义的方法，也可以调用Student.prototype定义的方法。</p>
<p>如果你想用最简单粗暴的方法这么干：</p>
<pre><code>PrimaryStudent.prototype = Student.prototype;
</code></pre>
<p>是不行的！如果这样的话，PrimaryStudent和Student共享一个原型对象，那还要定义PrimaryStudent干啥？</p>
<p>我们必须借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向Student.prototype。为了实现这一点，参考道爷（就是发明JSON的那个道格拉斯）的代码，中间对象可以用一个空函数F来实现：</p>
<pre><code>// PrimaryStudent构造函数:
function PrimaryStudent(props) &#123;
    Student.call(this, props);
    this.grade = props.grade || 1;
&#125;

// 空函数F:
function F() &#123;
&#125;

// 把F的原型指向Student.prototype:
F.prototype = Student.prototype;

// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:
PrimaryStudent.prototype = new F();

// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:
PrimaryStudent.prototype.constructor = PrimaryStudent;

// 继续在PrimaryStudent原型（就是new F()对象）上定义方法： (可以省略)
PrimaryStudent.prototype.getGrade = function () &#123;
    return this.grade;
&#125;;

// 创建xiaoming:
var xiaoming = new PrimaryStudent(&#123;
    name: &#39;小明&#39;,
    grade: 2
&#125;);
xiaoming.name; // &#39;小明&#39;
xiaoming.grade; // 2

// 验证原型:
xiaoming.__proto__ === PrimaryStudent.prototype; // true
xiaoming.__proto__.__proto__ === Student.prototype; // true

// 验证继承关系:
xiaoming instanceof PrimaryStudent; // true
xiaoming instanceof Student; // true
</code></pre>
<p>注意，函数F仅用于桥接，我们仅创建了一个new F()实例，而且，没有改变原有的Student定义的原型链。</p>
<p>如果把继承这个动作用一个inherits()函数封装起来，还可以隐藏F的定义，并简化代码：</p>
<pre><code>function inherits(Child, Parent) &#123;
    var F = function () &#123;&#125;;
    F.prototype = Parent.prototype;
    Child.prototype = new F();
    Child.prototype.constructor = Child;
&#125;
</code></pre>
<p>这个inherits()函数可以复用：</p>
<pre><code>function Student(props) &#123;
    this.name = props.name || &#39;Unnamed&#39;;
&#125;

Student.prototype.hello = function () &#123;
    alert(&#39;Hello, &#39; + this.name + &#39;!&#39;);
&#125;

function PrimaryStudent(props) &#123;
    Student.call(this, props);
    this.grade = props.grade || 1;
&#125;

// 实现原型继承链:
inherits(PrimaryStudent, Student);

// 绑定其他方法到PrimaryStudent原型:
PrimaryStudent.prototype.getGrade = function () &#123;
    return this.grade;
&#125;;
</code></pre>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>JavaScript的原型继承实现方式就是：</li>
<li>定义新的构造函数，并在内部用call()调用希望“继承”的构造函数，并绑定this；</li>
<li>借助中间函数F实现原型链继承，最好通过封装的inherits函数完成；</li>
<li>继续在新的构造函数的原型上定义新方法。</li>
</ul>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>如何处理信息过载</title>
    <url>/2016/05/04/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BF%A1%E6%81%AF%E8%BF%87%E8%BD%BD/</url>
    <content><![CDATA[<h3 id="一、俯瞰全景"><a href="#一、俯瞰全景" class="headerlink" title="一、俯瞰全景"></a>一、俯瞰全景</h3><blockquote>
<p>用断舍离的自在力俯瞰信息输入全景<br>微信：群、订阅号、朋友圈<br>微博、日报、新闻等APP<br>书籍、杂志<br>音频<br>其他</p>
</blockquote>
<h3 id="二、正本清源"><a href="#二、正本清源" class="headerlink" title="二、正本清源"></a>二、正本清源</h3><blockquote>
<p>梳理反思，及时清理对你造成困扰的信息源头。<br>以下是我的使用习惯，供参考<br>微信清退规则<br>群：没有群规，且超过一个月不曾发言<br>订阅号：未读数超 30<br>朋友圈：固定时间查阅<br>APP：关掉推送通知，关不掉就卸掉</p>
</blockquote>
<span id="more"></span>
<h3 id="三、书籍"><a href="#三、书籍" class="headerlink" title="三、书籍"></a>三、书籍</h3><blockquote>
<p>尽量阅读纸质书，不读杂志<br>读「元学科」相关的著作<br>阅读经典与诚意之作<br>阅读器存放的书不超过四本</p>
</blockquote>
<h3 id="四、音频"><a href="#四、音频" class="headerlink" title="四、音频"></a>四、音频</h3><blockquote>
<p>只在通勤时收听</p>
</blockquote>
<h3 id="五、社交"><a href="#五、社交" class="headerlink" title="五、社交"></a>五、社交</h3><blockquote>
<p>远离社交媒体<br>尽可能独立思考地输出代表作<br>有可追溯的记录平台<br>让自己变得优秀，方可与优秀的人相聚</p>
</blockquote>
<blockquote>
<p>会当凌绝顶，一览众山小。当你攀爬上思想巅峰，你便知，所谓信息过载，便如山边之行云，待一一退去，方可领略真知的雄伟。</p>
</blockquote>
<p>作者：陈素封<br>链接：<a href="http://www.zhihu.com/question/19685050/answer/71453024">http://www.zhihu.com/question/19685050/answer/71453024</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>关于IOS、安卓与原生JS交互的总结</title>
    <url>/2016/11/03/%E5%AE%89%E5%8D%93IOS%E4%B8%8EJS%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<p>最近在App中需要做一些页面，其中涉及到了与原生APP交互的问题，现在做下总结方便以后查询</p>
<span id="more"></span>
<p><strong>Android与JS交互</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> browser=&#123;</span><br><span class="line">    <span class="attr">versions</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> u = navigator.userAgent, app = navigator.appVersion;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="comment">//移动终端浏览器版本信息</span></span><br><span class="line">            <span class="attr">trident</span>: u.indexOf(<span class="string">&#x27;Trident&#x27;</span>) &gt; -<span class="number">1</span>, <span class="comment">//IE内核</span></span><br><span class="line">            <span class="attr">presto</span>: u.indexOf(<span class="string">&#x27;Presto&#x27;</span>) &gt; -<span class="number">1</span>, <span class="comment">//opera内核</span></span><br><span class="line">            <span class="attr">webKit</span>: u.indexOf(<span class="string">&#x27;AppleWebKit&#x27;</span>) &gt; -<span class="number">1</span>, <span class="comment">//苹果、谷歌内核</span></span><br><span class="line">            <span class="attr">gecko</span>: u.indexOf(<span class="string">&#x27;Gecko&#x27;</span>) &gt; -<span class="number">1</span> &amp;&amp; u.indexOf(<span class="string">&#x27;KHTML&#x27;</span>) == -<span class="number">1</span>, <span class="comment">//火狐内核</span></span><br><span class="line">            <span class="attr">mobile</span>: !!u.match(<span class="regexp">/AppleWebKit.*Mobile.*/</span>)||!!u.match(<span class="regexp">/AppleWebKit/</span>), <span class="comment">//是否为移动终端</span></span><br><span class="line">            <span class="attr">ios</span>: !!u.match(<span class="regexp">/\(i[^;]+;( U;)? CPU.+Mac OS X/</span>), <span class="comment">//ios终端</span></span><br><span class="line">            <span class="attr">android</span>: u.indexOf(<span class="string">&#x27;Android&#x27;</span>) &gt; -<span class="number">1</span> || u.indexOf(<span class="string">&#x27;Linux&#x27;</span>) &gt; -<span class="number">1</span>, <span class="comment">//android终端或者uc浏览器</span></span><br><span class="line">            <span class="attr">iPhone</span>: u.indexOf(<span class="string">&#x27;iPhone&#x27;</span>) &gt; -<span class="number">1</span> || u.indexOf(<span class="string">&#x27;Mac&#x27;</span>) &gt; -<span class="number">1</span>, <span class="comment">//是否为iPhone或者QQHD浏览器</span></span><br><span class="line">            <span class="attr">iPad</span>: u.indexOf(<span class="string">&#x27;iPad&#x27;</span>) &gt; -<span class="number">1</span>, <span class="comment">//是否iPad</span></span><br><span class="line">            <span class="attr">webApp</span>: u.indexOf(<span class="string">&#x27;Safari&#x27;</span>) == -<span class="number">1</span> <span class="comment">//是否web应该程序，没有头部与底部</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;(),</span><br><span class="line">    <span class="attr">language</span>:(navigator.browserLanguage || navigator.language).toLowerCase()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showToast</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">android.showToast(<span class="string">&quot;&#x27;title: Money+Funny，这可能是全成都最适合你的兼职！&#x27;,&#x27;content:拼K高校首席体验官公开招募！底薪1000元多玩多赚！速来！速来！速来！&#x27;,&#x27;urlId:http://www.tanshikeji.com/Home/Active/special_form.html&#x27;&quot;</span>);</span><br><span class="line"><span class="comment">//    android.showToast(&quot;&#123;\&quot;title\&quot;:\&quot; 我报名了拼K高校首席体验官！ 你也快来！\&quot;,\&quot;content\&quot;:\&quot;拼K高校首席体验官公开招募！底薪1000元多玩多赚！速来！速来！速来！\&quot;,\&quot;urlId:http://www.tanshikeji.com/Home/Active/special\&quot;&#125;&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showClick</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( navigator.userAgent.indexOf(<span class="string">&#x27;Android&#x27;</span>) &gt; -<span class="number">1</span> ||  navigator.userAgent.indexOf(<span class="string">&#x27;Linux&#x27;</span>) &gt; -<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//        e.preventDefault();</span></span><br><span class="line">    &#125;</span><br><span class="line">    android.showClick(<span class="string">&quot;http://www.tanshikeji.com/Home/Active/special_form.html&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;android_share&#x27;</span>).onclick = showToast;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;from_click&#x27;</span>).onclick = showClick;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><strong>IOS与JS交互:</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">/*这段代码是固定的，必须要放到js中*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupWebViewJavascriptBridge</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.WebViewJavascriptBridge) &#123; <span class="keyword">return</span> callback(WebViewJavascriptBridge); &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.WVJBCallbacks) &#123; <span class="keyword">return</span> <span class="built_in">window</span>.WVJBCallbacks.push(callback); &#125;</span><br><span class="line">    <span class="built_in">window</span>.WVJBCallbacks = [callback];</span><br><span class="line">    <span class="keyword">var</span> WVJBIframe = <span class="built_in">document</span>.createElement(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">    WVJBIframe.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    WVJBIframe.src = <span class="string">&#x27;wvjbscheme://__BRIDGE_LOADED__&#x27;</span>;</span><br><span class="line">    <span class="built_in">document</span>.documentElement.appendChild(WVJBIframe);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">document</span>.documentElement.removeChild(WVJBIframe) &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*与OC交互的所有JS方法都要放在此处注册，才能调用通过JS调用OC或者让OC调用这里的JS*/</span></span><br><span class="line">setupWebViewJavascriptBridge(<span class="function"><span class="keyword">function</span>(<span class="params">bridge</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*我们在这注册一个js调用OC的方法，不带参数，且不用ObjC端反馈结果给JS：打开本demo对应的博文*/</span></span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;ios_share&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        bridge.callHandler(<span class="string">&#x27;getShareObjC&#x27;</span>, &#123;</span><br><span class="line">            <span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;Money+Funny，这可能是全成都最适合你的兼职！&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;content&#x27;</span>:<span class="string">&#x27;拼K高校首席体验官公开招募！底薪1000元多玩多赚！速来！速来！速来！&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;urlId&#x27;</span>:<span class="string">&#x27;http://www.tanshikeji.com/Home/Active/special_form.html&#x27;</span></span><br><span class="line">        &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line"><span class="comment">//            alert(&quot;success&quot;+response);</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>IOS</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>常用正则表达式</title>
    <url>/2016/07/06/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>正则表达式，一个十分古老而又强大的文本处理工具，仅仅用一段非常简短的表达式语句，便能够快速实现一个非常复杂的业务逻辑。熟练地掌握正则表达式的话，能够使你的开发效率得到极大的提升。</p>
<p>正则表达式经常被用于字段或任意字符串的校验，如下面这段校验基本日期格式的JavaScript代码：</p>
<pre><code>var reg = /^(\\d&#123;1,4&#125;)(-|\\/)(\\d&#123;1,2&#125;)\\2(\\d&#123;1,2&#125;)$/; 
var r = fieldValue.match(reg);             
if(r==null)alert(&#39;Date format error!&#39;);
</code></pre>
<p>下面是技匠整理的，在前端开发中经常使用到的20个正则表达式。</p>
<hr>
<span id="more"></span>
<h3 id="校验密码强度"><a href="#校验密码强度" class="headerlink" title="校验密码强度"></a>校验密码强度</h3><p>密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。</p>
<pre><code>^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$
</code></pre>
<h3 id="校验中文"><a href="#校验中文" class="headerlink" title="校验中文"></a>校验中文</h3><p>字符串仅能是中文。</p>
<pre><code>^[\\u4e00-\\u9fa5]&#123;0,&#125;$
</code></pre>
<h3 id="由数字、26个英文字母或下划线组成的字符串"><a href="#由数字、26个英文字母或下划线组成的字符串" class="headerlink" title="由数字、26个英文字母或下划线组成的字符串"></a>由数字、26个英文字母或下划线组成的字符串</h3><pre><code>^\\w+$
</code></pre>
<h3 id="校验E-Mail-地址"><a href="#校验E-Mail-地址" class="headerlink" title="校验E-Mail 地址"></a>校验E-Mail 地址</h3><p>同密码一样，下面是E-mail地址合规性的正则检查语句。</p>
<pre><code>[\\w!#$%&amp;&#39;*+/=?^_`&#123;|&#125;~-]+(?:\\.[\\w!#$%&amp;&#39;*+/=?^_`&#123;|&#125;~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?
</code></pre>
<h3 id="校验身份证号码"><a href="#校验身份证号码" class="headerlink" title="校验身份证号码"></a>校验身份证号码</h3><p>下面是身份证号码的正则校验。15 或 18位。</p>
<p>15位：</p>
<pre><code>^[1-9]\\d&#123;7&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;$
</code></pre>
<p>18位：</p>
<pre><code>^[1-9]\\d&#123;5&#125;[1-9]\\d&#123;3&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;([0-9]|X)$
</code></pre>
<h3 id="校验日期"><a href="#校验日期" class="headerlink" title="校验日期"></a>校验日期</h3><p>“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。</p>
<pre><code>^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$
</code></pre>
<h3 id="校验金额"><a href="#校验金额" class="headerlink" title="校验金额"></a>校验金额</h3><p>金额校验，精确到2位小数。</p>
<pre><code>^[0-9]+(.[0-9]&#123;2&#125;)?$
</code></pre>
<h3 id="校验手机号"><a href="#校验手机号" class="headerlink" title="校验手机号"></a>校验手机号</h3><p>下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码）</p>
<pre><code>^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$
</code></pre>
<h3 id="判断IE的版本"><a href="#判断IE的版本" class="headerlink" title="判断IE的版本"></a>判断IE的版本</h3><p>IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。</p>
<pre><code>^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\/[5-9]\\.0).*$
</code></pre>
<h3 id="校验IP-v4地址"><a href="#校验IP-v4地址" class="headerlink" title="校验IP-v4地址"></a>校验IP-v4地址</h3><p>IP4 正则语句。</p>
<pre><code>\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b
</code></pre>
<h3 id="校验IP-v6地址"><a href="#校验IP-v6地址" class="headerlink" title="校验IP-v6地址"></a>校验IP-v6地址</h3><p>IP6 正则语句。</p>
<pre><code>(([0-9a-fA-F]&#123;1,4&#125;:)&#123;7,7&#125;[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,7&#125;:|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,6&#125;:[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,5&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,2&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,3&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,3&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,2&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,5&#125;|[0-9a-fA-F]&#123;1,4&#125;:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,6&#125;)|:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,7&#125;|:)|fe80:(:[0-9a-fA-F]&#123;0,4&#125;)&#123;0,4&#125;%[0-9a-zA-Z]&#123;1,&#125;|::(ffff(:0&#123;1,4&#125;)&#123;0,1&#125;:)&#123;0,1&#125;((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;:((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9]))
</code></pre>
<h3 id="检查URL的前缀"><a href="#检查URL的前缀" class="headerlink" title="检查URL的前缀"></a>检查URL的前缀</h3><p>应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。</p>
<pre><code>if (!s.match(/^[a-zA-Z]+:\\/\\//))
&#123;
    s = &#39;http://&#39; + s;
&#125;
</code></pre>
<h3 id="提取URL链接"><a href="#提取URL链接" class="headerlink" title="提取URL链接"></a>提取URL链接</h3><p>下面的这个表达式可以筛选出一段文本中的URL。</p>
<pre><code>^(f|ht)&#123;1&#125;(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&amp;=]*)?
</code></pre>
<h3 id="文件路径及扩展名校验"><a href="#文件路径及扩展名校验" class="headerlink" title="文件路径及扩展名校验"></a>文件路径及扩展名校验</h3><p>验证windows下文件路径和扩展名（下面的例子中为.txt文件）</p>
<pre><code>^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?&quot;&lt;&gt;|]+\\.txt(l)?$
</code></pre>
<h3 id="提取Color-Hex-Codes"><a href="#提取Color-Hex-Codes" class="headerlink" title="提取Color Hex Codes"></a>提取Color Hex Codes</h3><p>有时需要抽取网页中的颜色代码，可以使用下面的表达式。</p>
<pre><code>^#([A-Fa-f0-9]&#123;6&#125;|[A-Fa-f0-9]&#123;3&#125;)$
</code></pre>
<h3 id="提取网页图片"><a href="#提取网页图片" class="headerlink" title="提取网页图片"></a>提取网页图片</h3><p>假若你想提取网页中所有图片信息，可以利用下面的表达式。</p>
<pre><code>\\&lt; *[img][^\\\\&gt;]*[src] *= *[\\&quot;\\&#39;]&#123;0,1&#125;([^\\&quot;\\&#39;\\ &gt;]*)
</code></pre>
<h3 id="提取页面超链接"><a href="#提取页面超链接" class="headerlink" title="提取页面超链接"></a>提取页面超链接</h3><p>提取html中的超链接。</p>
<pre><code>(&lt;a\\s*(?!.*\\brel=)[^&gt;]*)(href=&quot;https?:\\/\\/)((?!(?:(?:www\\.)?&#39;.implode(&#39;|(?:www\\.)?&#39;, $follow_list).&#39;))[^&quot;]+)&quot;((?!.*\\brel=)[^&gt;]*)(?:[^&gt;]*)&gt;
</code></pre>
<h3 id="查找CSS属性"><a href="#查找CSS属性" class="headerlink" title="查找CSS属性"></a>查找CSS属性</h3><p>通过下面的表达式，可以搜索到相匹配的CSS属性。</p>
<pre><code>^\\s*[a-zA-Z\\-]+\\s*[:]&#123;1&#125;\\s[a-zA-Z0-9\\s.#]+[;]&#123;1&#125;
</code></pre>
<h3 id="抽取注释"><a href="#抽取注释" class="headerlink" title="抽取注释"></a>抽取注释</h3><p>如果你需要移除HMTL中的注释，可以使用如下的表达式。</p>
<pre><code>&lt;!--(.*?)--&gt;
</code></pre>
<h3 id="匹配HTML标签"><a href="#匹配HTML标签" class="headerlink" title="匹配HTML标签"></a>匹配HTML标签</h3><p>通过下面的表达式可以匹配出HTML中的标签属性。</p>
<pre><code>&lt;\\/?\\w+((\\s+\\w+(\\s*=\\s*(?:&quot;.*?&quot;|&#39;.*?&#39;|[\\^&#39;&quot;&gt;\\s]+))?)+\\s*|\\s*)\\/?&gt;
</code></pre>
<p>文／技匠（简书签约作者）<br>原文链接：<a href="http://www.jianshu.com/p/e7bb97218946">http://www.jianshu.com/p/e7bb97218946</a></p>
]]></content>
      <tags>
        <tag>Expression</tag>
      </tags>
  </entry>
  <entry>
    <title>清除浮动</title>
    <url>/2016/07/01/%E6%B8%85%E6%A5%9A%E6%B5%AE%E5%8A%A8/</url>
    <content><![CDATA[<h4 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h4><pre><code>.order_con:after&#123;
    content: ‘.’;
    display: block;
    visibility: hidden;
    width: 0px;
    height: 0px;
    clear: both;
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端的长按事件</title>
    <url>/2017/01/13/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E9%95%BF%E6%8C%89%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p><strong>Demo代码：</strong></p>
<span id="more"></span> 
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://lib.sinaapp.com/js/jquery/1.9.1/jquery-1.9.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:100%;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;touchArea&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:90%; height:200px; background-color:#CCC;font-size:100px&quot;</span>&gt;</span>长按我<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">var</span> timeOutEvent=<span class="number">0</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	$(<span class="string">&quot;#touchArea&quot;</span>).on(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="attr">touchstart</span>: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			timeOutEvent = <span class="built_in">setTimeout</span>(<span class="string">&quot;longPress()&quot;</span>,<span class="number">500</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		 	e.preventDefault();</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		&#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="attr">touchmove</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            		<span class="built_in">clearTimeout</span>(timeOutEvent);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		    	timeOutEvent = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		&#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="attr">touchend</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	   		<span class="built_in">clearTimeout</span>(timeOutEvent);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="keyword">if</span>(timeOutEvent!=<span class="number">0</span>)&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			    alert(<span class="string">&quot;你这是点击，不是长按&quot;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="keyword">return</span> <span class="literal">false</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	&#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="function"><span class="keyword">function</span> <span class="title">longPress</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    timeOutEvent = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    alert(<span class="string">&quot;长按事件触发发&quot;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端软键盘挡住输入框</title>
    <url>/2016/12/13/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%BD%AF%E9%94%AE%E7%9B%98%E6%8C%A1%E4%BD%8F%E8%BE%93%E5%85%A5%E6%A1%86/</url>
    <content><![CDATA[<p>在IOS端不需要加这一段代码，在软键盘出来的时候页面会自动被顶上去，但是Android不会，所以加一些条件判断，代码如下：</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> u = navigator.userAgent;</span><br><span class="line"><span class="keyword">var</span> isAndroid = u.indexOf(<span class="string">&#x27;Android&#x27;</span>) &gt; -<span class="number">1</span> || u.indexOf(<span class="string">&#x27;Adr&#x27;</span>) &gt; -<span class="number">1</span>; <span class="comment">//android终端</span></span><br><span class="line"><span class="keyword">var</span> isiOS = !!u.match(<span class="regexp">/\(i[^;]+;( U;)? CPU.+Mac OS X/</span>); <span class="comment">//ios终端</span></span><br><span class="line"><span class="comment">//处理isAndroid问题</span></span><br><span class="line"><span class="keyword">if</span> (isAndroid) &#123;</span><br><span class="line">     $(<span class="built_in">window</span>).on(<span class="string">&#x27;resize&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">document</span>.activeElement.tagName == <span class="string">&quot;INPUT&quot;</span> || <span class="built_in">document</span>.activeElement.tagName == <span class="string">&quot;TEXTAREA&quot;</span>) &#123;</span><br><span class="line">               <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　　　　　　　　<span class="built_in">document</span>.activeElement.scrollIntoViewIfNeeded();</span><br><span class="line">　　　　　　&#125;, <span class="number">0</span>);</span><br><span class="line">　　　&#125;</span><br><span class="line">　　  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title>不用0，1，2，以及加减乘除来进行运算</title>
    <url>/2016/07/03/%E7%A8%8B%E5%BA%8F%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>很久很久以前，有个叫阿隆佐·邱奇，发现只需要用函数，就可以用计算机实现运算，而不需要0、1、2、3这些数字和+、-、*、/这些符号。</p>
<p>JavaScript支持函数，所以可以通过JavaScript用函数来写这些计算。来试试：</p>
<span id="more"></span>
<pre><code>&#39;use strict&#39;;
// 定义数字0:
var zero = function (f) &#123;
    return function (x) &#123;
        return x;
    &#125;
&#125;;
// 定义数字1:
var one = function (f) &#123;
    return function (x) &#123;
        return f(x);
    &#125;
&#125;;
// 定义加法:
function add(n, m) &#123;
    return function (f) &#123;
        return function (x) &#123;
            return m(f)(n(f)(x));
        &#125;
    &#125;
&#125;
// 计算数字2 = 1 + 1:
var two = add(one, one);
// 计算数字3 = 1 + 2:
var three = add(one, two);
// 计算数字5 = 2 + 3:
var five = add(two, three);

// 你说它是3就是3，你说它是5就是5，你怎么证明？
// 给3传一个函数,会打印3次:
(three(function () &#123;
    console.log(&#39;print 3 times&#39;);
&#125;))();

// 给5传一个函数,会打印5次:
(five(function () &#123;
    console.log(&#39;print 5 times&#39;);
&#125;))();
</code></pre>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>素数算法</title>
    <url>/2016/06/21/%E7%B4%A0%E6%95%B0%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="找出数组中的素数"><a href="#找出数组中的素数" class="headerlink" title="找出数组中的素数"></a>找出数组中的素数</h3><p>例如    shu([1,2,5,9,7,8,6,13,56,48,46]) = [2, 5, 7, 13];</p>
<pre><code>function shu(arr)&#123;
    return arr.filter(
        function(num) &#123;
          if (num == 1) &#123;
            return false;
          &#125;
          if (num == 2) &#123;
            return true;
          &#125;
          for (var i = 2; i &lt;= Math.sqrt(num); i++) &#123;
            if (num % i == 0) &#123;
              return false;
            &#125;
          &#125;
          return true;
        &#125;
    )
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Github打不开问题</title>
    <url>/2021/07/19/%E8%AE%B0%E5%BD%95GitHub%E7%BD%91%E9%A1%B5hosts%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>github 最近打不开，很久之前遇到过，但是忘记怎么解决了，查找相关资料后，今天记录在此，以备不时之需：</p>
<span id="more"></span>

<h2 id="确定-Github-网址-IP"><a href="#确定-Github-网址-IP" class="headerlink" title="确定 Github 网址 IP"></a>确定 Github 网址 IP</h2><p>打开网站：<a href="https://github.com.ipaddress.com/">https://github.com.ipaddress.com/</a><br>找到<strong>IP Address</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP Address	140.82.114.4</span><br></pre></td></tr></table></figure>

<h2 id="确定-Github-域名-IP"><a href="#确定-Github-域名-IP" class="headerlink" title="确定 Github 域名 IP"></a>确定 Github 域名 IP</h2><p>打开网站：<a href="https://fastly.net.ipaddress.com/github.global.ssl.fastly.net">https://fastly.net.ipaddress.com/github.global.ssl.fastly.net</a><br>找到<strong>IP Address</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP Address	199.232.5.194</span><br></pre></td></tr></table></figure>

<h2 id="确定静态资源-IP"><a href="#确定静态资源-IP" class="headerlink" title="确定静态资源 IP"></a>确定静态资源 IP</h2><p>打开网站：<a href="https://github.com.ipaddress.com/assets-cdn.github.com">https://github.com.ipaddress.com/assets-cdn.github.com</a><br>找到<strong>IPv4 addresses</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IPv4 Addresses	185.199.108.153</span><br><span class="line">IPv4 Addresses	185.199.109.153</span><br><span class="line">IPv4 Addresses	185.199.110.153</span><br><span class="line">IPv4 Addresses	185.199.111.153</span><br></pre></td></tr></table></figure>

<h2 id="修改-hosts-文件"><a href="#修改-hosts-文件" class="headerlink" title="修改 hosts 文件"></a>修改 hosts 文件</h2><p>找到 hosts 文件：C:\Windows\System32\drivers\etc<br>修改 host 文件，在最后附上下面的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">140.82.114.4 github.com</span><br><span class="line">199.232.5.194 github.global.ssl.fastly.net</span><br><span class="line">185.199.108.153 assets-cdn.github.com</span><br><span class="line">185.199.109.153 assets-cdn.github.com</span><br><span class="line">185.199.110.153 assets-cdn.github.com</span><br><span class="line">185.199.111.153 assets-cdn.github.com</span><br></pre></td></tr></table></figure>

<p>最后还需要刷新 dns 缓存：cmd:ipconfig /flushdns</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/158938544">https://zhuanlan.zhihu.com/p/158938544</a></li>
</ul>
]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>模板引擎、字节转换、map函数</title>
    <url>/2016/06/23/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h5 id="1-模板引擎"><a href="#1-模板引擎" class="headerlink" title="1. 模板引擎"></a>1. 模板引擎</h5><pre><code>var reg = /\$\&#123;[a-zA-Z]+\&#125;/g;
var tpl = &quot;hello $&#123;who&#125;!&quot;;
var obj = &#123;who:&quot;world&quot;&#125;;
function template(tpl,obj)&#123;
        var s = reg.exec(tpl);
        var s1 = s[0].slice(2,-1);
        document.write(tpl.replace(reg,obj[s1]));
    &#125;
    //template(tpl,obj);
    template(&#39;Hello,$&#123;name&#125;&#39;,&#123;name:&quot;hedahang&quot;&#125;);
</code></pre>
<span id="more"></span>
<h5 id="2-字节转换"><a href="#2-字节转换" class="headerlink" title="2. 字节转换"></a>2. 字节转换</h5><pre><code>&lt;pre&gt;function bytesToSize(bytes) &#123;
    if (bytes === 0) return &#39;0 B&#39;;
    var k = 1024,
            sizes = [&#39;B&#39;, &#39;KB&#39;, &#39;MB&#39;, &#39;GB&#39;, &#39;TB&#39;, &#39;PB&#39;, &#39;EB&#39;, &#39;ZB&#39;, &#39;YB&#39;],
            i = Math.floor(Math.log(bytes) / Math.log(k));
    return (bytes / Math.pow(k, i)).toPrecision(3) + &#39; &#39; + sizes[i];
&#125;
console.log( bytesToSize(12345));&lt;/pre&gt;
</code></pre>
<h5 id="3-map函数"><a href="#3-map函数" class="headerlink" title="3. map函数"></a>3. map函数</h5><pre><code>&lt;pre&gt;function map(arr,fun)&#123;
    var array = [];
    for(var i = 0;i&lt;arr.length;i++)&#123;
        if( i == 0)&#123;
            array[i] = fun(0,arr[i]);
        &#125;else&#123;
            array[i] = fun(arr[i-1],arr[i])
        &#125;
    console.log(array);
    &#125;
&#125;
map([1,2,3,4,5],function(o,i)&#123;return o + i;&#125;)&lt;/pre&gt;
</code></pre>
]]></content>
      <categories>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown编辑器：马克飞象</title>
    <url>/2016/07/23/%E9%A9%AC%E5%85%8B%E9%A3%9E%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="欢迎使用马克飞象"><a href="#欢迎使用马克飞象" class="headerlink" title="欢迎使用马克飞象"></a>欢迎使用马克飞象</h1><p>@(示例笔记本)[马克飞象|帮助|Markdown]</p>
<p><strong>马克飞象</strong>是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述：</p>
<ul>
<li><strong>功能丰富</strong> ：支持高亮代码块、<em>LaTeX</em> 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手；</li>
<li><strong>得心应手</strong> ：简洁高效的编辑器，提供<a href="http://maxiang.info/client_zh">桌面客户端</a>以及<a href="https://chrome.google.com/webstore/detail/kidnkfckhbdkfgbicccmdggmpgogehop">离线Chrome App</a>，支持移动端 Web；</li>
<li><strong>深度整合</strong> ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。</li>
</ul>
<hr>
<span id="more"></span>
<p>[TOC]</p>
<h2 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h2><blockquote>
<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown">维基百科</a></p>
</blockquote>
<p>正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href="http://www.example.com/">链接</a>或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按<code>Ctrl + /</code>查看帮助。</p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span>(<span class="params">param1=<span class="string">&#x27;&#x27;</span>, param2=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;Greater&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">&#x27;&#x27;&#x27;interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="LaTeX-公式"><a href="#LaTeX-公式" class="headerlink" title="LaTeX 公式"></a>LaTeX 公式</h3><p>可以创建行内公式，例如 $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。或者块级公式：</p>
<p>$$    x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table>
<thead>
<tr>
<th align="left">Item</th>
<th align="right">Value</th>
<th align="center">Qty</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Computer</td>
<td align="right">1600 USD</td>
<td align="center">5</td>
</tr>
<tr>
<td align="left">Phone</td>
<td align="right">12 USD</td>
<td align="center">12</td>
</tr>
<tr>
<td align="left">Pipe</td>
<td align="right">1 USD</td>
<td align="center">234</td>
</tr>
</tbody></table>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">e=&gt;end</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>

<p>以及时序图:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示：</strong>想了解更多，请查看<strong>流程图</strong><a href="http://adrai.github.io/flowchart.js/">语法</a>以及<strong>时序图</strong><a href="http://bramp.github.io/js-sequence-diagrams/">语法</a>。</p>
</blockquote>
<h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><p>使用 <code>- [ ]</code> 和 <code>- [x]</code> 语法可以创建复选框，实现 todo-list 等功能。例如：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 已完成事项</li>
<li><input disabled="" type="checkbox"> 待办事项1</li>
<li><input disabled="" type="checkbox"> 待办事项2</li>
</ul>
<blockquote>
<p><strong>注意：</strong>目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在<strong>马克飞象</strong>中修改 Markdown 原文才可生效。下个版本将会全面支持。</p>
</blockquote>
<h2 id="印象笔记相关"><a href="#印象笔记相关" class="headerlink" title="印象笔记相关"></a>印象笔记相关</h2><h3 id="笔记本和标签"><a href="#笔记本和标签" class="headerlink" title="笔记本和标签"></a>笔记本和标签</h3><p><strong>马克飞象</strong>增加了<code>@(笔记本)[标签A|标签B]</code>语法, 以选择笔记本和添加标签。 <strong>绑定账号后</strong>， 输入<code>(</code>自动会出现笔记本列表，请从中选择。</p>
<h3 id="笔记标题"><a href="#笔记标题" class="headerlink" title="笔记标题"></a>笔记标题</h3><p><strong>马克飞象</strong>会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 <code>欢迎使用马克飞象</code>。</p>
<h3 id="快捷编辑"><a href="#快捷编辑" class="headerlink" title="快捷编辑"></a>快捷编辑</h3><p>保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到<strong>马克飞象</strong>中打开并编辑该笔记。</p>
<blockquote>
<p><strong>注意：</strong>目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。</p>
</blockquote>
<h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><p><strong>马克飞象</strong>通过<strong>将Markdown原文以隐藏内容保存在笔记中</strong>的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。</p>
<blockquote>
<p><strong>隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。</strong></p>
</blockquote>
<h3 id="离线存储"><a href="#离线存储" class="headerlink" title="离线存储"></a>离线存储</h3><p><strong>马克飞象</strong>使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过<code>文档管理</code>打开。</p>
<blockquote>
<p><strong>注意：</strong>虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，<strong>请务必经常及时同步到印象笔记</strong>。</p>
</blockquote>
<h2 id="编辑器相关"><a href="#编辑器相关" class="headerlink" title="编辑器相关"></a>编辑器相关</h2><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>右侧系统菜单（快捷键<code>Ctrl + M</code>）的<code>设置</code>中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。</p>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>帮助    <code>Ctrl + /</code><br>同步文档    <code>Ctrl + S</code><br>创建文档    <code>Ctrl + Alt + N</code><br>最大化编辑器    <code>Ctrl + Enter</code><br>预览文档 <code>Ctrl + Alt + Enter</code><br>文档管理    <code>Ctrl + O</code><br>系统菜单    <code>Ctrl + M</code></p>
<p>加粗    <code>Ctrl + B</code><br>插入图片    <code>Ctrl + G</code><br>插入链接    <code>Ctrl + L</code><br>提升标题    <code>Ctrl + H</code></p>
<h2 id="关于收费"><a href="#关于收费" class="headerlink" title="关于收费"></a>关于收费</h2><p><strong>马克飞象</strong>为新用户提供 10 天的试用期，试用期过后需要<a href="maxiang.info/vip.html">续费</a>才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。</p>
<h2 id="反馈与建议"><a href="#反馈与建议" class="headerlink" title="反馈与建议"></a>反馈与建议</h2><ul>
<li>微博：<a href="http://weibo.com/u/2788354117">@马克飞象</a>，<a href="http://weibo.com/ggock" title="开发者个人账号">@GGock</a></li>
<li>邮箱：<a href="mailto:&#104;&#117;&#x73;&#x74;&#x67;&#111;&#99;&#107;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;">&#104;&#117;&#x73;&#x74;&#x67;&#111;&#99;&#107;&#64;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#x63;&#111;&#109;</a></li>
</ul>
<hr>
<p>感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。</p>
<p>[^demo]: 这是一个示例脚注。请查阅 <a href="https://github.com/fletcher/MultiMarkdown/wiki/MultiMarkdown-Syntax-Guide#footnotes">MultiMarkdown 文档</a> 关于脚注的说明。 <strong>限制：</strong> 印象笔记的笔记内容使用 <a href="https://dev.yinxiang.com/doc/articles/enml.php">ENML</a> 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致<code>脚注</code>和<code>TOC</code>无法正常点击。</p>
]]></content>
      <categories>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title>十、JavaScript之call、apply和bind的模拟实现</title>
    <url>/2019/09/21/deepjs/call%E3%80%81apply%E3%80%81bind%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>简单来说</p>
<blockquote>
<p>call()方法在将函数的第一个参数值指定到 this 和剩余参数指定的情况下调用某个函数或方法。</p>
</blockquote>
<span id="more"></span>
<p>使用示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lilei&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// this指向第一个参数foo;</span></span><br><span class="line">bar.call(foo, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// &#123;name: &quot;lilei&quot;&#125; 1 2</span></span><br><span class="line"><span class="comment">// a,b未传参数，默认是undefined</span></span><br><span class="line">bar.call(foo); <span class="comment">// &#123;name: &quot;lilei&quot;&#125; undefined undefined</span></span><br><span class="line"><span class="comment">// call方法不传参数或传递null/undefined，this都指向window(非严格模式)</span></span><br><span class="line">bar.call(); <span class="comment">// window undefined undefined</span></span><br><span class="line">bar.call(<span class="literal">null</span>); <span class="comment">// window undefined undefined</span></span><br><span class="line">bar.call(<span class="literal">undefined</span>); <span class="comment">// window undefined undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h3><p>call 方法的模拟实现需要明白 call 的原理：</p>
<ol>
<li>this 指向的改变</li>
<li>call 函数中执行调用的函数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context === <span class="literal">null</span> || context === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    context = <span class="built_in">window</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    context = <span class="built_in">Object</span>(context);</span><br><span class="line">  &#125;</span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">delete</span> context.fn(...args);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lilei&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line">bar.myCall(foo, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// &#123;name: &quot;lilei&quot;, fn: ƒ&#125; 1 2</span></span><br><span class="line">bar.myCall(foo); <span class="comment">// &#123;name: &quot;lilei&quot;, fn: ƒ&#125; undefined undefined</span></span><br><span class="line">bar.myCall(); <span class="comment">// Window undefined undefined</span></span><br><span class="line">bar.myCall(<span class="literal">null</span>); <span class="comment">// Window undefined undefined</span></span><br><span class="line">bar.myCall(<span class="literal">undefined</span>); <span class="comment">// Window undefined undefined</span></span><br><span class="line">bar.myCall(<span class="number">23</span>, <span class="number">24</span>); <span class="comment">// Number &#123;23, fn: ƒ&#125; undefined undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>apply 的使用与 apply 基本一致，两者之间的区别：apply 的第二个参数是数组[arg1,arg2,arg3,…]，call 的第二个参数是列表(arg1,arg2,arg3,…)；<br>使用示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lilei&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line">bar.apply(foo, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// &#123;name: &quot;lilei&quot;&#125; 1 2</span></span><br><span class="line">bar.apply(foo); <span class="comment">// &#123;name: &quot;lilei&quot;&#125; undefined undefined</span></span><br><span class="line">bar.apply(); <span class="comment">// window undefined undefined</span></span><br><span class="line">bar.apply(<span class="literal">null</span>); <span class="comment">// window undefined undefined</span></span><br><span class="line">bar.apply(<span class="literal">undefined</span>); <span class="comment">// window undefined undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="模拟实现-1"><a href="#模拟实现-1" class="headerlink" title="模拟实现"></a>模拟实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context === <span class="literal">null</span> || context === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    context = <span class="built_in">window</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    context = <span class="built_in">Object</span>(context);</span><br><span class="line">  &#125;</span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">delete</span> context.fn(args);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>引用 MDN 中的介绍</p>
<blockquote>
<p>bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p>
</blockquote>
<p>由此看出 bind 的特点：</p>
<ul>
<li>bind 返回一个新的函数。</li>
<li>这个新的函数可以预置参数。</li>
</ul>
<p>举个例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lilei&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn = bar.bind(foo, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">fn(); <span class="comment">//// &#123;name: &quot;lilei&quot;&#125; 1 2</span></span><br></pre></td></tr></table></figure>

<h3 id="模拟实现-2"><a href="#模拟实现-2" class="headerlink" title="模拟实现"></a>模拟实现</h3><p>1.实现返回一个函数，并可以传递参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 保存要绑定的this</span></span><br><span class="line">  <span class="keyword">var</span> _this = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// 获取预置参数</span></span><br><span class="line">  <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取执行时传入的参数</span></span><br><span class="line">    <span class="keyword">var</span> restArgs = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 合并参数</span></span><br><span class="line">    <span class="keyword">var</span> allArgs = args.concat(restArgs);</span><br><span class="line">    <span class="keyword">return</span> self.apply(_this, allArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>接下来最重要的一点，bind 返回的函数支持 new 调用：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;绑定的目标必须是函数&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 保存要绑定的this</span></span><br><span class="line">  <span class="keyword">var</span> _this = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// 获取预置参数</span></span><br><span class="line">  <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取执行时传入的参数</span></span><br><span class="line">    <span class="keyword">var</span> restArgs = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 合并参数</span></span><br><span class="line">    <span class="keyword">var</span> allArgs = args.concat(restArgs);</span><br><span class="line">    <span class="comment">// instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。</span></span><br><span class="line">    <span class="comment">// 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值</span></span><br><span class="line">    <span class="comment">// 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context </span></span><br><span class="line">    <span class="keyword">return</span> self.apply(<span class="built_in">this</span> <span class="keyword">instanceof</span> fBound ? <span class="built_in">this</span> : _this, allArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 原型链关系处理</span></span><br><span class="line">  <span class="comment">// fBound.prototype = Object.create(self.prototype || Function.prototype);</span></span><br><span class="line">  fNOP.prototype = <span class="built_in">this</span>.prototype;</span><br><span class="line">  fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">  <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://github.com/mqyqingfeng/Blog/issues/11">https://github.com/mqyqingfeng/Blog/issues/11</a></p>
]]></content>
      <categories>
        <category>深入理解JavaScript系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>十一、JavaScript之new的模拟实现</title>
    <url>/2019/09/28/deepjs/new%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>在 MDN 中对 new 运算符的解释是：</p>
<blockquote>
<p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</p>
</blockquote>
<span id="more"></span>

<p>为了更清楚理解，举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">make, model, year</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>)); <span class="comment">// &#123;&#125;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.__proto__ === Car.prototype); <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">this</span>.make = make;</span><br><span class="line">  <span class="built_in">this</span>.model = model;</span><br><span class="line">  <span class="built_in">this</span>.year = year;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>)); <span class="comment">//&#123;&quot;make&quot;:&quot;Eagle&quot;,&quot;model&quot;:&quot;Talon TSi&quot;,&quot;year&quot;:1993&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car1 = <span class="keyword">new</span> Car(<span class="string">&quot;Eagle&quot;</span>, <span class="string">&quot;Talon TSi&quot;</span>, <span class="number">1993</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(car1.make); <span class="comment">// Eagle</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，new 运算符会进行如下操作：</p>
<ol>
<li>创建一个空的简单 JavaScript 对象（即{}）；</li>
<li>新对象的<strong>proto</strong>属性指向构造函数的 prototype 属性 ；</li>
<li>将步骤 1 新创建的对象作为 this 的上下文 ；</li>
<li>如果该函数没有返回对象，则返回 this。</li>
</ol>
<h3 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h3><p>实现一个 new 也就意味着不能用 new 关键字，那么要完成这么一系列步骤，我们通过一个函数 newFactory 来实现。</p>
<p>请看下面示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 取出第一个参数，就是我们要传入的构造函数</span></span><br><span class="line">  <span class="keyword">var</span> func = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 创建一个空对象，并且指定原型为func.prototype</span></span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(func.prototype);</span><br><span class="line">  <span class="comment">// 使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性</span></span><br><span class="line">  <span class="keyword">var</span> ret = func.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 判断构造函数是否返回对象，有则return该对象，没有则返回this;(特殊情况返回null处理)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">&quot;object&quot;</span> &amp;&amp; ret !== <span class="literal">null</span> ? ret : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试一(构造函数无返回对象)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Otaku</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.habit = <span class="string">&quot;Games&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Otaku.prototype.strength = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">Otaku.prototype.sayYourName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;I am &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = newFactory(Otaku, <span class="string">&quot;Kevin&quot;</span>, <span class="string">&quot;18&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// Kevin</span></span><br><span class="line"><span class="built_in">console</span>.log(person.habit); <span class="comment">// Games</span></span><br><span class="line"><span class="built_in">console</span>.log(person.strength); <span class="comment">// 60</span></span><br><span class="line"></span><br><span class="line">person.sayYourName(); <span class="comment">// I am Kevin</span></span><br></pre></td></tr></table></figure>

<p>测试二(构造函数有返回对象)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Otaku</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.habit = <span class="string">&quot;Games&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Otaku.prototype.strength = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">Otaku.prototype.sayYourName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;I am &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = newFactory(Otaku, <span class="string">&quot;Kevin&quot;</span>, <span class="string">&quot;18&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// Kevin</span></span><br><span class="line"><span class="built_in">console</span>.log(person.habit); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(person.strength); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">person.sayYourName(); <span class="comment">// person.sayYourName is not a function</span></span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://github.com/mqyqingfeng/Blog/issues/12">https://github.com/mqyqingfeng/Blog/issues/12</a></p>
]]></content>
      <categories>
        <category>深入理解JavaScript系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>六、JavaScript之this理解</title>
    <url>/2019/08/06/deepjs/this/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在前面我们已经知道，当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。<br>对于每个执行上下文，都有三个重要属性：</p>
<ul>
<li>变量对象(Variable object，VO)</li>
<li>作用域链(Scope chain)</li>
<li>this<span id="more"></span></li>
</ul>
<p>前面我们已经讨论了变量对象和作用域链，本文主要说说对this的理解。<br>this与上下文的可执行代码类型直接相关。该值在进入上下文时确定，并且在代码在上下文中运行时是不可变的。</p>
<h2 id="全局代码中This的值"><a href="#全局代码中This的值" class="headerlink" title="全局代码中This的值"></a>全局代码中This的值</h2><p>在全局代码中，this值始终是全局对象本身。因此，可以间接引用它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显式定义全局对象</span></span><br><span class="line"><span class="built_in">this</span>.a = <span class="number">10</span>; <span class="comment">// global.a = 10</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过赋值隐式定义</span></span><br><span class="line">b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.b); <span class="comment">// 20</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 全局上下文变量声明</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.c); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
<h2 id="函数代码中This的值"><a href="#函数代码中This的值" class="headerlink" title="函数代码中This的值"></a>函数代码中This的值</h2><p>this的第一个（可能也是主要的）特征是在这种类型代码中的值没有静态绑定到函数。</p>
<p>如上所述，this值是在进入上下文时确定的，如果使用功能代码，则每次的值都可能完全不同。<br>所以，在代码运行时this值是不可变的，即无法为其分配新值，因为它不是变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">x</span>: <span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">test</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> === bar); <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x); <span class="comment">// 20</span></span><br><span class="line">    <span class="comment">// this = foo; // error, Invalid left-hand side in assignment</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x); <span class="comment">// 如果不报错这里将会是10,</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">bar.test(); <span class="comment">// true, 20</span></span><br><span class="line">foo.test = bar.test;</span><br><span class="line"><span class="comment">//现在this的值将指向“foo”——即使我们正在调用相同的函数  </span></span><br><span class="line">foo.test(); <span class="comment">// false, 10</span></span><br></pre></td></tr></table></figure>
<p>那么是什么影响了this函数代码中值的变化呢？有几个因素。</p>
<p>首先，在通常的函数调用中，this是由激活上下文代码的调用者来提供的，即调用函数的父上下文(parent context )。this取决于调用函数的方式。</p>
<p>理解和记住这重要的一点能帮助我们在任何情况下准确无误的确定this值。正是调用函数的方式影响了调用的上下文中的this值，所以，即使是正常的全局函数也会被调用方式的不同形式激活，这些不同的调用方式导致了不同的this值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">foo(); <span class="comment">// global</span></span><br><span class="line"><span class="built_in">console</span>.log(foo === foo.prototype.constructor); <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 但是同一个function的不同的调用表达式，this是不同的</span></span><br><span class="line">foo.prototype.constructor(); <span class="comment">// foo.prototype</span></span><br></pre></td></tr></table></figure>
<p>有可能作为一些对象定义的方法来调用函数，但是this将不会设置为这个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  <span class="attr">bar</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> === foo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">foo.bar(); <span class="comment">// foo, true</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> exampleFunc = foo.bar;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(exampleFunc === foo.bar); <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 再一次，同一个function的不同的调用表达式，this是不同的</span></span><br><span class="line"> </span><br><span class="line">exampleFunc(); <span class="comment">// global, false</span></span><br></pre></td></tr></table></figure>
<p>为了充分理解this值的确定,我们需要知道在 ECMAScript 规范中还有一种只存在于规范中的类型，它们的作用是用来描述语言底层行为逻辑。<br>本文主要讨论下其中的 Reference 类型。它与 this 的指向有着密切的关联。</p>
<h2 id="引用类型（Reference-type）"><a href="#引用类型（Reference-type）" class="headerlink" title="引用类型（Reference type）"></a>引用类型（Reference type）</h2><p>那么什么是Reference？<a href="https://262.ecma-international.org/6.0/#sec-reference-specification-type">ECMAScript</a>中6.2.3章有介绍：</p>
<blockquote>
<p>The Reference type is used to explain the behaviour of such operators as deletedelete, typeoftypeof, the assignment operators, the supersuper keyword and other language features. For example, the lefthand operand of an assignment is expected to produce a reference.</p>
</blockquote>
<p>翻译一下，Reference 类型用于解释诸如delete、typeof、赋值运算符、super关键字和其他语言功能等运算符的行为 。例如，赋值的左侧操作数预计会产生一个引用<br>再看接下来的这段具体介绍 Reference 的内容:</p>
<blockquote>
<ul>
<li>A Reference is a resolved name or property binding. </li>
<li>A Reference consists of three components, the base value component, the referenced name component, and the Boolean-valued strict reference flag. </li>
<li>The base value component is either undefined, an Object, a Boolean, a String, a Symbol, a Number, a BigInt, or an Environment Record.</li>
<li>A base value component of undefined indicates that the Reference could not be resolved to a binding.</li>
<li>The referenced name component is a String or Symbol value.<br>简单来说，Reference 的构成，由三个组成部分，分别是：</li>
</ul>
</blockquote>
<ul>
<li>base value</li>
<li>referenced name</li>
<li>strict reference</li>
</ul>
<p>base value 就是属性所在的对象或者就是 EnvironmentRecord，它的值只可能是 undefined, an Object, a Boolean, a String, a Number, or an environment record 其中的一种。<br>referenced name 就是属性的名称，它的值可能是 a String or Symbol value。<br>使用伪代码可以将Reference type的值表示为具有三个属性的对象：base（即属性所属的对象）、base中的propertyName和strict reference(如果use strict有效则为真)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> valueOfReferenceType = &#123;</span><br><span class="line">  <span class="attr">base</span>: &lt;base object&gt;,</span><br><span class="line">  propertyName: &lt;property name&gt;,</span><br><span class="line">  strick: &lt;strict reference&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这里我们需要明白一个很重要的东西，返回引用类型的值只有两种情况：</p>
<ol>
<li>标识符的处理</li>
<li>一个属性访问器</li>
</ol>
<h3 id="标识符的处理"><a href="#标识符的处理" class="headerlink" title="标识符的处理"></a>标识符的处理</h3><p>标示符的处理（标识符的解析）过程，用来确定一个变量（或函数声明）属于哪个变量对象。<br>这个算法的返回值中，总是一个<strong>引用类型的值</strong>，它的base组件是相应的变量对象（或若未找到则为null）,属性名组件是向上查找的标示符的名称。<br>标识符是变量名，函数名，函数参数名和全局对象中未识别的属性名。例如，下面标识符的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在操作的中间结果中，引用类型对应的值如下：</span></span><br><span class="line"><span class="keyword">var</span> fooReference = &#123;</span><br><span class="line">  <span class="attr">base</span>: <span class="built_in">global</span>,</span><br><span class="line">  <span class="attr">propertyName</span>: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">  <span class="attr">strick</span>: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> barReference = &#123;</span><br><span class="line">  <span class="attr">base</span>: <span class="built_in">global</span>,</span><br><span class="line">  <span class="attr">propertyName</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">  <span class="attr">strick</span>: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了从引用类型中得到一个对象真正的值，伪代码中的GetValue方法可以做如下描述：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetValue</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Type(value) != Reference) &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> base = GetBase(value);</span><br><span class="line">  <span class="keyword">if</span> (base === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> base.[[Get]](GetPropertyName(value));</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部的[[Get]]方法返回对象属性真正的值(base.[[Get]] === global)，包括对原型链中继承的属性分析。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GetValue(fooReference); <span class="comment">// 10 </span></span><br><span class="line">GetValue(barReference); <span class="comment">// function object &quot;bar&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="属性访问器"><a href="#属性访问器" class="headerlink" title="属性访问器"></a>属性访问器</h3><p>属性访问器都应该熟悉。它有两种变体：点（.）语法（此时属性名是正确的标示符，且事先知道），或括号语法（[]）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo.bar();</span><br><span class="line">foo[<span class="string">&#x27;bar&#x27;</span>]();</span><br></pre></td></tr></table></figure>
<p>在中间计算的返回值中，引用类型的值如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fooBarReference = &#123;</span><br><span class="line">  <span class="attr">base</span>: foo,</span><br><span class="line">  <span class="attr">propertyName</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">  <span class="attr">strick</span>: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">GetValue(fooBarReference); <span class="comment">// function object &quot;bar&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="引用类型的值与This的关系"><a href="#引用类型的值与This的关系" class="headerlink" title="引用类型的值与This的关系"></a>引用类型的值与This的关系</h3><p>引用类型的值与函数上下文中的this值如何相关？——从最重要的意义上来说。 这个关联的过程是这篇文章的核心。 一个函数上下文中确定this值的通用规则如下：</p>
<p><strong>在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用括号()的左边是引用类型的值，this将设为引用类型值的base对象（base object），在其他情况下（与引用类型不同的任何其它属性），这个值为null。不过，实际不存在this的值为null的情况，因为当this的值为null的时候，其值会被隐式转换为全局对象。</strong><br>注：第5版的ECMAScript中，已经不强迫转换成全局变量了，而是赋值为undefined。</p>
<p>我们看看这个例子中的表现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">foo(); <span class="comment">// global</span></span><br></pre></td></tr></table></figure>
<p>我们看到在调用括号的左边是一个引用类型值（因为foo是一个标示符）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fooReference = &#123;</span><br><span class="line">  <span class="attr">base</span>: <span class="built_in">global</span>,</span><br><span class="line">  <span class="attr">propertyName</span>: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">  <span class="attr">strick</span>: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>相应地，this也设置为引用类型的base对象。即全局对象。</p>
<p>同样，使用属性访问器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  <span class="attr">bar</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">foo.bar(); <span class="comment">// foo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们再次拥有一个引用类型，其base是foo对象，在函数bar激活时用作this。</span></span><br><span class="line"><span class="keyword">var</span> fooBarReference = &#123;</span><br><span class="line">  <span class="attr">base</span>: foo,</span><br><span class="line">  <span class="attr">propertyName</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是，用另外一种形式激活相同的函数，我们得到其它的this值。</span></span><br><span class="line"><span class="keyword">var</span> test = foo.bar;</span><br><span class="line">test(); <span class="comment">// global</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为test作为标示符，生成了引用类型的其他值，其base（全局对象）用作this 值。</span></span><br><span class="line"><span class="keyword">var</span> testReference = &#123;</span><br><span class="line">  <span class="attr">base</span>: <span class="built_in">global</span>,</span><br><span class="line">  <span class="attr">propertyName</span>: <span class="string">&#x27;test&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在，我们可以很明确的告诉你，为什么用表达式的不同形式激活同一个函数会不同的this值，答案在于引用类型（type Reference）不同的中间值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">foo(); <span class="comment">// global, because</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> fooReference = &#123;</span><br><span class="line">  <span class="attr">base</span>: <span class="built_in">global</span>,</span><br><span class="line">  <span class="attr">propertyName</span>: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(foo === foo.prototype.constructor); <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 另外一种形式的调用表达式</span></span><br><span class="line"> </span><br><span class="line">foo.prototype.constructor(); <span class="comment">// foo.prototype, because</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> fooPrototypeConstructorReference = &#123;</span><br><span class="line">  <span class="attr">base</span>: foo.prototype,</span><br><span class="line">  <span class="attr">propertyName</span>: <span class="string">&#x27;constructor&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="函数调用和非引用类型"><a href="#函数调用和非引用类型" class="headerlink" title="函数调用和非引用类型"></a>函数调用和非引用类型</h2><p>正如我们已经指出，当调用括号的左边不是引用类型而是其它类型，这个值自动设置为null，结果为全局对象。<br>让我们再思考这种表达式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// null =&gt; global</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们有一个函数对象但不是引用类型的对象（它不是标示符，也不是属性访问器），相应地，this值最终设为全局对象。</p>
<p>更多复杂的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  <span class="attr">bar</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">foo.bar(); <span class="comment">// Reference, OK =&gt; foo</span></span><br><span class="line">(foo.bar)(); <span class="comment">// Reference, OK =&gt; foo</span></span><br><span class="line"> </span><br><span class="line">(foo.bar = foo.bar)(); <span class="comment">// global?</span></span><br><span class="line">(<span class="literal">false</span> || foo.bar)(); <span class="comment">// global?</span></span><br><span class="line">(foo.bar, foo.bar)(); <span class="comment">// global?</span></span><br></pre></td></tr></table></figure>
<p>为什么我们有一个属性访问器，它的中间值应该为引用类型的值，在某些调用中我们得到的this值不是base对象，而是global对象？</p>
<p>问题在于后面的三个调用，在应用一定的运算操作之后，在调用括号的左边的值不再是引用类型。</p>
<p>第一个例子很明显———明显的引用类型，结果是，this为base对象，即foo。<br>在第二个例子中，组运算符并不适用，想想上面提到的，从引用类型中获得一个对象真正的值的方法，如GetValue。相应的，在组运算的返回中———我们得到仍是一个引用类型。这就是this值为什么再次设为base对象，即foo。<br>第三个例子中，与组运算符不同，赋值运算符调用了GetValue方法。返回的结果是函数对象（但不是引用类型），这意味着this设为null，结果是global对象。<br>第四个和第五个也是一样——逗号运算符和逻辑运算符（OR）调用了GetValue 方法，相应地，我们失去了引用而得到了函数。并再次设为global。</p>
<h2 id="作为构造器调用的函数中的this"><a href="#作为构造器调用的函数中的this" class="headerlink" title="作为构造器调用的函数中的this"></a>作为构造器调用的函数中的this</h2><p>还有一个与this值相关的情况是在函数的上下文中，这是一个构造函数的调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// &quot;a&quot;对象下创建一个新属性</span></span><br><span class="line">  <span class="built_in">this</span>.x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="built_in">console</span>.log(a.x); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，new运算符调用“A”函数的内部的[[Construct]] 方法，接着，在对象创建后，调用内部的[[Call]] 方法。 所有相同的函数“A”都将this的值设置为新创建的对象。</p>
<h2 id="函数调用中手动设置this"><a href="#函数调用中手动设置this" class="headerlink" title="函数调用中手动设置this"></a>函数调用中手动设置this</h2><p>在函数原型中定义的两个方法（因此所有的函数都可以访问它）允许去手动设置函数调用的this值。它们是.apply和.call方法。他们用接受的第一个参数作为this值，this 在调用的作用域中使用。这两个方法的区别很小，对于.apply，第二个参数必须是数组（或者是类似数组的对象，如arguments，反过来，.call能接受任何参数。两个方法必须的参数是第一个——this。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.b);</span><br><span class="line">  <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">a(<span class="number">20</span>); <span class="comment">// this === global, this.b == 10, c == 20</span></span><br><span class="line"> </span><br><span class="line">a.call(&#123;<span class="attr">b</span>: <span class="number">20</span>&#125;, <span class="number">30</span>); <span class="comment">// this === &#123;b: 20&#125;, this.b == 20, c == 30</span></span><br><span class="line">a.apply(&#123;<span class="attr">b</span>: <span class="number">30</span>&#125;, [<span class="number">40</span>]) <span class="comment">// this === &#123;b: 30&#125;, this.b == 30, c == 40</span></span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-3-this/">http://dmitrysoshnikov.com/ecmascript/ru-chapter-3-this/</a></li>
<li><a href="https://javascript.info/reference-type">https://javascript.info/reference-type</a></li>
</ul>
]]></content>
      <categories>
        <category>深入理解JavaScript系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>二、JavaScript之作用域</title>
    <url>/2019/06/15/deepjs/%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h2><p>作用域是指程序源代码中定义变量的区域。</p>
<p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p>
<p>JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。</p>
<span id="more"></span>
<h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>在你不知道的javascript上卷中是这样定义的：</p>
<blockquote>
<p>词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变(大部分情况下是这样的)。</p>
</blockquote>
<p>在JS中词法作用域的规则：<a href="https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20%26%20closures/ch1.md">点这里</a></p>
<p>请看下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var value = 1;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    var value = 2;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); // ???</span><br></pre></td></tr></table></figure>
<p>假设JavaScript采用静态作用域，让我们分析下执行过程：<br>执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。</p>
<p>假设JavaScript采用动态作用域，让我们分析下执行过程：<br>执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。</p>
<p>前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1。<br>再看下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line"></span><br><span class="line">	var b = a * 2;</span><br><span class="line"></span><br><span class="line">	function bar(c) &#123;</span><br><span class="line">		console.log( a, b, c );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bar(b * 3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo( 2 ); // 2 4 12</span><br></pre></td></tr></table></figure>
<p>在这个代码示例中有三个固有的嵌套作用域：</p>
<ul>
<li>包围着全局作用域，只有一个标识符：foo。</li>
<li>包围着作用域 foo，它含有三个标识符：a，bar 和 b。</li>
<li>包围着作用域 bar，它里面只包含一个标识符：c。</li>
</ul>
<p>当我们执行console.log(…)语句的时候，开始查找三个被引用的变量 a，b 和 c。它首先从最内部的作用域气泡开始，也就是 bar(…) 函数的作用域。在这里它找不到 a，所以它向上走一层，到外面下一个最近的作用域气泡，foo(…) 的作用域。它在这里找到了 a，于是它就使用这个 a。同样的事情也发生在 b 身上。但是对于 c，它在 bar(..) 内部就找到了。</p>
<p>如果在 foo(..) 内部定义一个变量 c，console.log(…) 语句也仍然会找到并使用 bar(…) 中的那一个，而不会使用 foo(…) 中的那一个。</p>
<p><strong>一旦找到第一个匹配，作用域查询就停止了。</strong>相同的标识符名称可以在嵌套作用域的多个层中被指定，这称为“遮蔽（shadowing）”（内部的标识符“遮蔽”了外部的标识符）。无论如何遮蔽，作用域查询总是从当前被执行的最内侧的作用域开始，向外/向上不断查找，直到第一个匹配才停止。</p>
<p><strong>注意：</strong>全局变量也自动地是全局对象（在浏览器中是 window，等等）的属性，所以不直接通过全局变量的词法名称，而通过将它作为全局对象的一个属性引用来间接地引用，是可能的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 5;</span><br><span class="line">function foo(a) &#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">  console.log(window.a)</span><br><span class="line">&#125;</span><br><span class="line">foo(2) // 2,5</span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://github.com/mqyqingfeng/Blog/issues/3">https://github.com/mqyqingfeng/Blog/issues/3</a></p>
]]></content>
      <categories>
        <category>深入理解JavaScript系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>五、JavaScript之作用域链</title>
    <url>/2019/07/18/deepjs/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
    <content><![CDATA[<p>在上一篇的文章中，我们了解到执行上下文数据（变量、函数声明和函数的所有形参）是由这个变量对象的属性存储的，另外，我们知道每次进入上下文时都会创建变量对象并填充初始化值，并且在执行上下文代码时会发生它的修改。</p>
<p>下面我们叫了解执行上下文相关的另一个概念：作用域链。</p>
<span id="more"></span>

<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>作用域链（Scope，Scope chain，缩写 SC）是与执行上下文相关联的变量对象链，在解析标识符名称时在其中搜索变量。</p>
</blockquote>
<p>简而言之，作用域链更多的是关于嵌套函数。</p>
<p>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">20</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(x + y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line">foo()(); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p>同时，我们知道每个上下文都有自己的变量对象：对于全局上下文，这是全局对象本身，对于函数，这是活动对象。<br>作用域链是嵌套上下文的这些（父）变量对象的列表。该链用于搜索变量。那些。从上面的例子来看，“bar”上下文的作用域链将包括 AO (bar)、AO (foo) 和 VO (global)。</p>
<p>函数的作用域链是在执行时创建的，由一个活动对象和一个内部[[Scope]]函数属性组成。我们将在下面讨论 [[Scope]] 属性。</p>
<p>前面我们写了执行上下文的组称代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ExecutionContextObj = &#123;</span><br><span class="line">  <span class="attr">VO</span>: <span class="built_in">window</span>, <span class="comment">// 变量对象</span></span><br><span class="line">  <span class="attr">Scope</span>: &#123;&#125;, <span class="comment">// 作用域链</span></span><br><span class="line">  <span class="attr">this</span>: <span class="built_in">window</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中 Scope 的定义是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Scope = AO + [[Scope]];</span><br></pre></td></tr></table></figure>

<p>如果我们将 Scope 和 [[Scope]] 以普通 JavaScript 数组的形式表示——这样会更清晰。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Scope = [VO1, VO2, ..., VOn]; <span class="comment">// scope chain</span></span><br></pre></td></tr></table></figure>

<p>换种说法[[scope]] 就是所有父变量对象的层级链。</p>
<h2 id="函数声明周期"><a href="#函数声明周期" class="headerlink" title="函数声明周期"></a>函数声明周期</h2><p>函数的生命周期分为创建阶段和激活（调用）阶段。现在我们从这两个方面来详细地分析它们。</p>
<h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><p>我们知道，函数声明在进入上下文阶段就属于变量对象（VO）/激活对象（AO）。思考一个在全局上下文中声明变量和函数的示例（其中变量对象是全局对象本身）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p>执行之后我们看到了符合预期的结果：30，但是这里有一个很重要特性。<br>到目前为止，我们只讨论了同一上下文中的变量对象。这里我们看到变量“y”是在函数“foo”中定义的（也就是说它在函数“foo”的上下文的 AO 中），但是变量“x”在进入上下文的时候是没有在任何地方定义（因此，在 AO 中没有添加；“在表面上”，对于“foo”函数来说，“x”变量根本不存在，但是，正如我们将在下面看到的，只有“在表面上” ）。函数上下文活动对象“foo”只包含一个属性——“y”属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fooContext.AO = &#123;</span><br><span class="line">  <span class="attr">y</span>: <span class="literal">undefined</span>, <span class="comment">// undefined - 进入执行上下文时, 20 - 执行时</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么函数“foo”是如何取到变量“x”的值？实际上它是通过函数内部的[[scope]]属性来实现的。<br><img src="/images/scope.png" alt="(流程图)"><br>我们声明了一个函数 foo,需要查看 foo 的原型对象才能看到[[scopes]]属性，因为 foo.prototype.constructor===foo，所以展开 constructor 选项。<br>可以看到[[scopes]]属性是一个数组，里面只有一个元素 Global,也就是全局对象。<br>需要注意的一点－－[[scope]]在函数创建时被存储－－静态（不变的），直至函数销毁。即：函数可以永不调用，但[[scope]]属性已经写入，并存储在函数对象中，同时[[scope]] 并不代表完整的作用域链。<br>所以上面列子函数“foo”的[[scope]]如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo[[Scope]] = [</span><br><span class="line">  globalContext.VO, <span class="comment">// === Global</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h3 id="函数激活"><a href="#函数激活" class="headerlink" title="函数激活"></a>函数激活</h3><p>当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端，作为作用域数组的第一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Scope = [AO].concat([[Scope]]);</span><br></pre></td></tr></table></figure>

<p>至此，作用域链创建完毕。</p>
<p>下面我们用一个例子，结合着之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">20</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> z = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x + y + z);</span><br><span class="line">  &#125;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// 60</span></span><br></pre></td></tr></table></figure>

<p>执行过程如下：</p>
<ol>
<li>全局上下文的变量对象是：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">globalContext.VO === Global = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">10</span></span><br><span class="line">  <span class="attr">foo</span>: <span class="xml"><span class="tag">&lt;<span class="name">reference</span> <span class="attr">to</span> <span class="attr">function</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>foo 函数被创建，保存作用域链到内部属性[[scope]]:</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo.[[scope]] = [globalContext.VO];</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>执行 foo 函数，创建 foo 函数执行上下文，foo 函数执行上下文被压入执行上下文栈:</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ECStack = [fooContext, globalContext];</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>foo 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链:</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fooContext = &#123;</span><br><span class="line">  <span class="attr">Scope</span>: foo.[[scope]],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fooContext = &#123;</span><br><span class="line">    <span class="attr">AO</span>: &#123;</span><br><span class="line">        <span class="attr">arguments</span>: &#123;</span><br><span class="line">            <span class="attr">length</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">y</span>: <span class="literal">undefined</span>,</span><br><span class="line">        <span class="attr">bar</span>: reference to <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    &#125;，</span><br><span class="line">    <span class="attr">Scope</span>: foo.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>第三步：将活动对象压入 foo 作用域链顶端</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fooContext = &#123;</span><br><span class="line">    <span class="attr">AO</span>: &#123;</span><br><span class="line">        <span class="attr">arguments</span>: &#123;</span><br><span class="line">            <span class="attr">length</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">y</span>: <span class="literal">undefined</span>,</span><br><span class="line">        <span class="attr">bar</span>: reference to <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">Scope</span>: [fooContext.AO, foo.[[Scope]]] <span class="comment">// 等同于 [fooContext.AO, globalContext.VO]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>执行函数 foo ，修改 AO 的属性值</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fooContext = &#123;</span><br><span class="line">    <span class="attr">AO</span>: &#123;</span><br><span class="line">        <span class="attr">arguments</span>: &#123;</span><br><span class="line">            <span class="attr">length</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">y</span>: <span class="number">20</span>,</span><br><span class="line">        <span class="attr">bar</span>: reference to <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">Scope</span>: [fooContext.AO, foo.[[Scope]]] <span class="comment">// 等同于 [fooContext.AO, globalContext.VO]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>修改y值后，内部函数 bar 开始创建：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其[[scope]]为：</span></span><br><span class="line">bar.[[Scope]] = [</span><br><span class="line">  fooContext.AO,</span><br><span class="line">  globalContext.VO</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行上下文栈</span></span><br><span class="line">ECStack = [barContext, fooContext, globalContext];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制函数[[scope]]属性创建作用域链</span></span><br><span class="line">barContext = &#123;</span><br><span class="line">  <span class="attr">Scope</span>: bar.[[Scope]],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并初始化 bar 上下文活动对象</span></span><br><span class="line">barContext = &#123;</span><br><span class="line">    <span class="attr">AO</span>: &#123;</span><br><span class="line">        <span class="attr">arguments</span>: &#123;</span><br><span class="line">            <span class="attr">length</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">z</span>: <span class="literal">undefined</span>,</span><br><span class="line">    &#125;，</span><br><span class="line">    <span class="attr">Scope</span>: bar.[[scope]],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将活动对象压入 bar 作用域链顶端</span></span><br><span class="line">barContext = &#123;</span><br><span class="line">    <span class="attr">AO</span>: &#123;</span><br><span class="line">        <span class="attr">arguments</span>: &#123;</span><br><span class="line">            <span class="attr">length</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">z</span>: <span class="literal">undefined</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">Scope</span>: [barContext.AO, bar.[[Scope]]] <span class="comment">// 等同于 [barContext.AO, fooContext.AO, globalContext.VO]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行函数 bar ，修改bar.AO 的属性值</span></span><br><span class="line">barContext = &#123;</span><br><span class="line">    <span class="attr">AO</span>: &#123;</span><br><span class="line">        <span class="attr">arguments</span>: &#123;</span><br><span class="line">            <span class="attr">length</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">z</span>: <span class="number">30</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">Scope</span>: [barContext.AO, bar.[[Scope]]] <span class="comment">// 等同于 [barContext.AO, fooContext.AO, globalContext.VO]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>执行console.log语句，对“x”、“y”、“z”的标识符解析如下：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">- <span class="string">&quot;x&quot;</span></span><br><span class="line">-- barContext.AO <span class="comment">// not found</span></span><br><span class="line">-- fooContext.AO <span class="comment">// not found</span></span><br><span class="line">-- globalContext.VO <span class="comment">// found - 10</span></span><br><span class="line"></span><br><span class="line">- <span class="string">&quot;y&quot;</span></span><br><span class="line">-- barContext.AO <span class="comment">// not found</span></span><br><span class="line">-- fooContext.AO <span class="comment">// found - 20</span></span><br><span class="line"></span><br><span class="line">- <span class="string">&quot;z&quot;</span></span><br><span class="line">-- barContext.AO <span class="comment">// found - 30</span></span><br></pre></td></tr></table></figure>
<ol start="9">
<li>打印x,y,z的之后，函数执行完毕，函数上下文从执行上下文栈中依次弹出</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bar函数出栈</span></span><br><span class="line">ECStack = [fooContext, globalContext];</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo函数出栈</span></span><br><span class="line">ECStack = [globalContext];</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-4-scope-chain/">http://dmitrysoshnikov.com/ecmascript/ru-chapter-4-scope-chain/</a></p>
]]></content>
      <categories>
        <category>深入理解JavaScript系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>九、JavaScript之参数按值传递</title>
    <url>/2019/09/11/deepjs/%E5%80%BC%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在《JavaScript 高级程序设计》中讲到传递参数：</p>
<blockquote>
<p>ECMAScript 中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。对很多开发者来说，这一块可能会不好理解，毕竟变量有按值和按引用访问，而传参则只有按值传递。</p>
</blockquote>
<span id="more"></span>

<h2 id="按值传递"><a href="#按值传递" class="headerlink" title="按值传递"></a>按值传递</h2><blockquote>
<p>在按值传递参数时，值会被复制到一个局部变量（即一个命名参数，或者用 ECMAScript 的话说，就是 arguments 对象中的一个槽位）。<br>来看一个例子：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  num += <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(num); <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">20</span>;</span><br><span class="line">foo(count);</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 20，没有变化</span></span><br></pre></td></tr></table></figure>

<p>这里，函数 foo()有一个参数 num，它其实是一个局部变量。在调用时，变量 count 作为参数传入。count 的值 20 被复制给参数 num 。在函数内部，参数 num 的值被加上了 10，但这不会影响函数外部的变量 count。参数 num 和变量 count 互不干扰，它们只不过碰巧保存了一样的值。</p>
<h2 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h2><blockquote>
<p>众所周知按引用传递接收的不是值拷贝，而是对象的隐式引用，如该对象在外部的直接引用地址。函数内部对参数的任何改变都是影响该对象在函数外部的值，因为两者引用的是同一个对象，也就是说：这时候参数就相当于外部对象的一个别名。<br>伪代码：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  o.value = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(o.value); <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line">foo(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.value); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>哪ECMAScript 中函数传递引用数据类型参数是引用传递吗？然而并不是，除了上面两种策略以外，我们看看第三种策略。</p>
<h2 id="共享传递"><a href="#共享传递" class="headerlink" title="共享传递"></a>共享传递</h2><p>共享传递策略还有一些代名词：“按对象传递”或“按对象共享传递”。该策略是1974年由Barbara Liskov为CLU编程语言提出的，策略的要点是：</p>
<blockquote>
<p>函数接收的是对象引用的拷贝（副本），该引用拷贝和形参以及其值相关联。<br>这里出现的引用，我们不能称之为“按引用传递”，因为函数接收的参数不是直接的对象别名，而是该引用地址的拷贝。</p>
</blockquote>
<p>最重要的区别就是：函数内部给参数重新赋新值不会影响到外部的对象（和上例按引用传递的case），但是因为该参数是一个地址拷贝，所以在外面访问和里面访问的都是同一个对象,改变该参数对象的属性值将会影响到外部的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">num</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  obj.num = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.num); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>这里，我们创建了一个对象 person 并这个对象被传给 foo 方法，并被复制到参数 obj 中。在函数内部，obj 和 person 都指向同一个对象。个人觉得引用数据类型传递的也是值, 不过这个值是一个地址指针，<br>我们再来看看下面这个修改后的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; <span class="attr">num</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  obj.num = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 将obj引用指针指向了新的一个对象上</span></span><br><span class="line">  obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  obj.num = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.num); <span class="comment">// 1</span></span><br><span class="line">foo(person);</span><br><span class="line"><span class="comment">// 如果这里是按照引用传递，那么，下面的输出应该是3</span></span><br><span class="line"><span class="built_in">console</span>.log(person.num); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>当 person 传入 foo()时，其 num 属性被设置为 2。然后变量 obj 被设置为一个新对象且 num 属性被设置为 3。如果 person 是按引用传递的，那么 person 应该自动将指针改为指向 num 为 3 的对象。可是，当我们再次访问 person.num 时，它的值是 2，这表明函数中参数的值改变之后，原始的引用仍然没变。当 obj 在函数内部被重写时，它变成了一个指向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>如果参数是基本类型，那么是按值传递。</li>
<li>如果参数是引用数据类型，传递的还是值，但是这个值是引用数据类型地址的拷贝。</li>
</ol>
]]></content>
      <categories>
        <category>深入理解JavaScript系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>一、JavaScript之原型和原型链</title>
    <url>/2019/06/11/deepjs/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>首先创建一个构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line">var person = new Person();</span><br><span class="line">person.name = &#x27;lilei&#x27;;</span><br><span class="line">console.log(person.name) // lilei</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。</p>
<h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>每个函数都有一个prototype属性，那这个属性到底是指向哪里呢？是这个函数的原型吗？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line">Person.prototype.name = &#x27;lilei&#x27;;</span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br><span class="line">console.log(person1.name) // lilei</span><br><span class="line">console.log(person2.name) // lilei</span><br></pre></td></tr></table></figure>
<p>从这里可以看出，函数Person的prototype熟悉指向了一个对象，这个对象就是正在调用该构造函数而创建的实例的原型，也就是这个例子中的person的原型。<br>那什么是原型呢？可以这样理解，每个JavaScript对象（null除外）在创建的时候都会关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型继承属性。</p>
<h3 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h3><p>每一个JavaScript对象（null除外）都具有的一个属性叫 ‘<strong>proto</strong>‘ , 这个属性指向该对象的原型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line">var person = new Person();</span><br><span class="line">console.log(person.__proto__ === Person.prototype); // true</span><br></pre></td></tr></table></figure>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>前面我们已经知道实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？<br>因为一个构造函数可以生成多个实例，所以原型没有指向实例的属性，，但是原型可以指向构造函数，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line">console.log(Person === Person.prototype.constructor); // true</span><br></pre></td></tr></table></figure>
<p>综上我们已经得出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line"></span><br><span class="line">console.log(person.__proto__ == Person.prototype) // true</span><br><span class="line">console.log(Person.prototype.constructor == Person) // true</span><br><span class="line">// 顺便学习一个ES5的方法,可以获得对象的原型</span><br><span class="line">console.log(Object.getPrototypeOf(person) === Person.prototype) // true</span><br></pre></td></tr></table></figure>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>在前面，我们已经知道什么是原型，下面我们说说原型链。<br>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。<br>那么原型的最顶层是什么呢？请看下面的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(Object.prototype.__proto__ === null) // true</span><br></pre></td></tr></table></figure>
<blockquote>
<p>null字面意思：空值，这个值的语义是，希望表示一个对象被人为的重置为空对象，而非一个变量最原始的状态 。<br>所以 Object.prototype.<strong>proto</strong> 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。<br>所以查找属性的时候查到 Object.prototype 就可以停止查找了，所以原型的最顶层就是null。<br>最后用一张图来表示之间的关系：<br><img src="/images/prototype.png" alt="(原型图)"><br>图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。</p>
</blockquote>
]]></content>
      <categories>
        <category>深入理解JavaScript系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>四、JavaScript之变量对象</title>
    <url>/2019/07/12/deepjs/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>在前面的文章<a href="https://hedahang.github.io/2019/06/26/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/">《JavaScript之执行上下文栈》</a>中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。</p>
<span id="more"></span>
<p>执行上下文的组成代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const ExecutionContextObj = &#123;</span><br><span class="line">    VO: window, // 变量对象</span><br><span class="line">    Scope: &#123;&#125;, // 作用域链</span><br><span class="line">    this: window</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本文主要记录创建变量对象的过程。</p>
<h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><p>变量对象是与执行上下文相关的数据作用域，存储了上下文中定义的变量和函数声明。<br>变量对象式一个抽象的概念，在不同的上下文中，表示不同的对象:</p>
<h3 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h3><p>全局执行上下文的变量对象</p>
<ul>
<li>全局执行上下文中，变量对象就是全局对象。</li>
<li>在顶层js代码中，this指向全局对象，全局变量会作为该对象的属性来被查询。在浏览器中，window就是全局对象。</li>
</ul>
<p>这样我们就能理解为什么，在全局上下文中声明一个变量时，我们能够通过全局对象的一个​​属性来间接引用它（例如，当变量的名称事先不知道时）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// &quot;test&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>[<span class="string">&#x27;a&#x27;</span>]); <span class="comment">// &quot;test&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(a === <span class="built_in">this</span>.a); <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> aKey = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>[aKey]); <span class="comment">//  &quot;test&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h3><p>函数执行上下文的变量对象</p>
<ul>
<li>函数上下文中，变量对象VO就是活动对象AO。</li>
<li>初始化时，带有arguments属性。</li>
</ul>
<p>Arguments 对象（简称 ArgO）是一个位于函数上下文的激活对象中的对象，包含以下属性：</p>
<p>callee - 链接到正在执行的函数；<br>length -实际传递的参数数量；<br>properties-indexes（数字，缩减为字符串），其中的值是函数的形参（在参数列表中从左到右）。这些索引属性的数量 == arguments.length。arguments 对象的 index 属性值和存在的形参是可以互换的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 描述函数参数的数量(x, y, z)  </span></span><br><span class="line">  <span class="built_in">console</span>.log(foo.length); <span class="comment">// 3</span></span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 实际传输参数的数量,只有(x, y)  </span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length); <span class="comment">// 2</span></span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 函数本身的引用  </span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee === foo); <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// arguments对象的index属性值和存在的形参是可以互换</span></span><br><span class="line">  <span class="built_in">console</span>.log(x === <span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// 10</span></span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// 20</span></span><br><span class="line">  x = <span class="number">30</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// 30</span></span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 然而，对于未指定的z参数,是无法和arguments的值进行互换的</span></span><br><span class="line">  z = <span class="number">40</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">2</span>]); <span class="comment">// undefined</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">2</span>] = <span class="number">50</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(z); <span class="comment">// 40</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">foo(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p>执行上下文的代码会分成两个阶段进行处理：分析(进入执行上下文)和执行(代码执行)：</p>
<h3 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h3><p>当进入执行上下文时，这时候还没有执行代码，<br>变量对象会包括：</p>
<ol>
<li>函数的所有形参 (如果是函数上下文)</li>
</ol>
<ul>
<li>由名称和对应值组成的一个变量对象的属性被创建</li>
<li>没有实参，属性值设为 undefined</li>
</ul>
<ol start="2">
<li>函数声明</li>
</ol>
<ul>
<li>由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</li>
<li>如果变量对象已经存在相同名称的属性，则完全替换这个属性</li>
</ul>
<ol start="3">
<li>变量声明</li>
</ol>
<ul>
<li>由名称和对应值（undefined）组成一个变量对象的属性被创建；</li>
<li>如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</li>
</ul>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> e = <span class="function"><span class="keyword">function</span> <span class="title">_e</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>在进入执行上下文后，这时候的 AO 是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="attr">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">length</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">d</span>: reference to <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    <span class="attr">e</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，AO 中不包含“x”函数。这是因为，“x”是不是一个函数声明，而是一个FunctionExpression（函数表达式）是不影响VO。然而，函数“_e”也是一个表达式函数，但是，正如我们将在下面看到的，通过将对其的引用分配给变量“e”，它可以通过“e”使用。您其他帖子中阅读 FunctionDeclaration 和 FunctionExpression 之间的区别。</p>
<h3 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h3><p>在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值</p>
<p>还是上面的例子，当代码执行完后，这时候的 AO 是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="attr">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">length</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="number">10</span></span><br><span class="line">    <span class="attr">d</span>: reference to <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    <span class="attr">e</span>: reference to FunctionExpression <span class="string">&quot;_e&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次注意 FunctionExpression_e仅以变量为代价保留在内存中e。FunctionExpressionx没有进入 AO/VO：也就是说，如果你试图在代码中x声明之前或之后调用一个函数，就会出现“x未定义”错误。未保存的 FunctionExpression 只能与声明一起调用，或递归调用。</p>
<p>来看一个示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// function</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 10</span></span><br><span class="line"> </span><br><span class="line">x = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<p>为什么第一个输出中的“x”是一个函数，甚至在申明之前可用？为什么不是 10 或 20？因为，根据规则——VO在进入上下文时填充了函数声明，在同一个地方，进入时声明了变量“x”，但VO中的变量的优先级低于函数声明，因此，在进入时，VO填充会以如下方式发生：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">VO = &#123;&#125;;</span><br><span class="line"> </span><br><span class="line">VO[<span class="string">&#x27;x&#x27;</span>] = reference to <span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 发现 var x = 10;</span></span><br><span class="line"><span class="comment">// 由于之前已经填充了函数声明，变量‘x’不会覆盖函数的值</span></span><br><span class="line"> </span><br><span class="line">VO[<span class="string">&#x27;x&#x27;</span>] = reference to <span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>但是已经在执行代码时，VO被修改成这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">VO[<span class="string">&#x27;x&#x27;</span>] = <span class="number">10</span>;</span><br><span class="line">VO[<span class="string">&#x27;x&#x27;</span>] = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>再看一个示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// undefined, 而不是 &quot;b is not defined&quot;</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们看到变量在进入上下文时就会进入 VO（例如，永远不会执行 else 块，但是，变量“b”仍然存在于 VO 中）</p>
<h2 id="关于变量"><a href="#关于变量" class="headerlink" title="关于变量"></a>关于变量</h2><p>在JavaScript中，使用var申明和不适用var申明是有区别，请记住：变量仅使用 var 关键字声明。<br>比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// b is not defined</span></span><br><span class="line">b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>这里我们看到”b is not defined”，因为 这不是一个变量，“b”只会在代码执行时创建;<br>关于变量的另一个重点，与简单属性不同，变量接收{DontDelete}属性，这意味着无法使用delete运算符删除：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> a); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// undefined</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> b); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b); <span class="comment">// 任然是20</span></span><br></pre></td></tr></table></figure>

<p>到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说：</p>
<ul>
<li><p>全局上下文的变量对象初始化是全局对象</p>
</li>
<li><p>函数上下文的变量对象初始化只包括 Arguments 对象</p>
</li>
<li><p>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</p>
</li>
<li><p>在代码执行阶段，会再次修改变量对象的属性值</p>
</li>
<li><p>在进入执行上下文时,var声明的变量才会被添加并赋初始值</p>
</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-2-variable-object/">http://dmitrysoshnikov.com/ecmascript/ru-chapter-2-variable-object/</a></p>
]]></content>
      <categories>
        <category>深入理解JavaScript系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>七、JavaScript之执行上下文</title>
    <url>/2019/08/26/deepjs/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>每次当控制器转到 ECMAScript 可执行代码的时候，即会进入到一个执行上下文。执行上下文(简称-EC)是 ECMA-262 标准里的一个抽象概念，用于同可执行代码(executable code)概念进行区分。</p>
<p>标准规范没有从技术实现的角度定义 EC 的准确类型和结构，这应该是具体实现 ECMAScript 引擎时要考虑的问题。</p>
<p>活动的执行上下文组在逻辑上组成一个堆栈。堆栈底部永远都是全局上下文(global context)，而顶部就是当前(活动的)执行上下文。堆栈在 EC 类型进入和退出上下文的时候被修改（推入或弹出）。</p>
<span id="more"></span>

<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>这里我们结合前面几篇文章来看看执行上下文的具体处理过程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope = <span class="string">&quot;local scope&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scope;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure>

<p>执行过程如下： 1.执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈；全局上下文初始化；创建 checkscope 函数，并保存作用域链到函数的内部属性[[scope]]。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ECStack = [globalContext];</span><br><span class="line"></span><br><span class="line">globalContext = &#123;</span><br><span class="line">  <span class="attr">VO</span>: [<span class="built_in">global</span>],</span><br><span class="line">  <span class="attr">Scope</span>: [globalContext.VO],</span><br><span class="line">  <span class="attr">this</span>: globalContext.VO,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">checkscope[[scope]] = [globalContext.VO];</span><br></pre></td></tr></table></figure>

<p>2.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ECStack = [checkscopeContext, globalContext];</span><br></pre></td></tr></table></figure>

<p>4.checkscope 函数执行上下文初始化：</p>
<ul>
<li>复制函数 [[scope]] 属性创建作用域链，</li>
<li>用 arguments 创建活动对象，</li>
<li>初始化活动对象，即加入形参、函数声明、变量声明，</li>
<li>将活动对象压入 checkscope 作用域链顶端。</li>
<li>同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">  <span class="attr">AO</span>: &#123;</span><br><span class="line">    <span class="attr">arguments</span>: &#123;</span><br><span class="line">      <span class="attr">length</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">scope</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">f</span>: reference to <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">Scope</span>: [AO, globalContext.VO],</span><br><span class="line">  <span class="attr">this</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ECStack = [fContext, checkscopeContext, globalContext];</span><br></pre></td></tr></table></figure>

<p>6.f 函数执行上下文初始化, 以下跟第 4 步相同：</p>
<ul>
<li>复制函数 [[scope]] 属性创建作用域链</li>
<li>用 arguments 创建活动对象</li>
<li>初始化活动对象，即加入形参、函数声明、变量声明</li>
<li>将活动对象压入 f 作用域链顶端</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fContext = &#123;</span><br><span class="line">  <span class="attr">AO</span>: &#123;</span><br><span class="line">    <span class="attr">arguments</span>: &#123;</span><br><span class="line">      <span class="attr">length</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">Scope</span>: [AO, checkscopeContext.AO, globalContext.VO],</span><br><span class="line">  <span class="attr">this</span>: <span class="literal">undefined</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>7.f 函数执行，沿着作用域链查找 scope 值，返回 scope 值</p>
<p>8.f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ECStack = [checkscopeContext, globalContext];</span><br></pre></td></tr></table></figure>

<p>9.checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ECStack = [globalContext];</span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://github.com/mqyqingfeng/Blog/issues/8">https://github.com/mqyqingfeng/Blog/issues/8</a></p>
]]></content>
      <categories>
        <category>深入理解JavaScript系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>三、JavaScript之执行上下文栈</title>
    <url>/2019/06/26/deepjs/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/</url>
    <content><![CDATA[<p>由于JS是单线程的，每次只能做一件事情，其他的事情会放在指定的上下文栈中排队等待执行，所以执行上下文栈的作用是用来跟踪代码的，。</p>
<p>JS解释器在初始化代码的时候，首先会创建一个新的全局执行上下文到执行上下文栈顶中，然后随着每次函数的调用都会创建一个新的执行上下文放入到栈顶中，随着函数执行完毕后被执行上下文栈顶弹出，直到回到全局的执行上下文中。（栈：一种数据结构，遵循后进先出的原则）。下面我们说说执行上下文栈是如何工作的。</p>
<span id="more"></span>
<p>为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ECStack = [];</span><br></pre></td></tr></table></figure>
<p>当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>现在我们执行下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var color = &#x27;blue&#x27;;</span><br><span class="line">function changeColor() &#123;</span><br><span class="line">    var anotherColor = &#x27;red&#x27;;</span><br><span class="line">    function swapColors() &#123;</span><br><span class="line">        var tempColor = anotherColor;</span><br><span class="line">        anotherColor = color;</span><br><span class="line">        color = tempColor;</span><br><span class="line">    &#125;</span><br><span class="line">    swapColors();</span><br><span class="line">&#125;</span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure>
<p>上述代码运行按照如下步骤：</p>
<ul>
<li>当上述代码在浏览器中加载时，JavaScript 引擎会创建一个全局执行上下文并且将它推入当前的执行栈</li>
<li>调用 changeColor函数时，此时changeColor函数内部代码还未执行，js执行引擎立即创建一个changeColor的执行上下文（简称EC），然后把这执行上下文压入到执行栈（简称ECStack）中。</li>
<li>执行changeColor函数过程中，调用swapColors函数，同样地，swapColors函数执行之前也创建了一个swapColors的执行上下文，并压入到执行栈中。</li>
<li>swapColors函数执行完成，swapColors函数的执行上下文出栈，并且被销毁。</li>
<li>changeColor函数执行完成，changeColor函数的执行上下文出栈，并且被销毁。<br><img src="/images/esstack.png" alt="(流程图)"></li>
</ul>
]]></content>
      <categories>
        <category>深入理解JavaScript系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>十二、JavaScript之继承的多种方式和优缺点</title>
    <url>/2019/09/30/deepjs/%E7%BB%A7%E6%89%BF%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
    <content><![CDATA[<p>本文讲解 JavaScript 各种继承方式和优缺点。</p>
<span id="more"></span>

<h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>实现方式：将子类的原型链指向父类的对象实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&quot;parent&quot;</span>;</span><br><span class="line">  <span class="built_in">this</span>.list = [<span class="string">&quot;a&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(child.name); <span class="comment">// parent</span></span><br><span class="line">child.sayHi(); <span class="comment">// hi</span></span><br></pre></td></tr></table></figure>

<p>原理：子类实例 child 的__proto__指向 Child 的原型链 prototype，而 Child.prototype 指向 Parent 类的对象实例，该父类对象实例的__proto__指向 Parent.prototype,所以 Child 可继承 Parent 的构造函数属性、方法和原型链属性、方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">child.__proto__ === Child.prototype; <span class="comment">// true</span></span><br><span class="line">child.__proto__.__proto__ === Parent.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>优点：可继承构造函数的属性，父类构造函数的属性，父类原型的属性<br>缺点：无法向父类构造函数传参；且所有实例共享父类实例的属性，若父类共有属性为引用类型，一个子类实例更改父类构造函数共有属性时会导致继承的共有属性发生变化；实例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(child2.list); <span class="comment">// [&#x27;a&#x27;]</span></span><br><span class="line">child.list.push(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child2.list); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br></pre></td></tr></table></figure>

<h2 id="构造函数-经典继承"><a href="#构造函数-经典继承" class="headerlink" title="构造函数(经典继承)"></a>构造函数(经典继承)</h2><p>实现方式：在子类构造函数中使用 call 或者 apply 劫持父类构造函数方法，并传入参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name, id</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.id = id;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.printName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, id</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>, name, id);</span><br><span class="line">  <span class="comment">// Parent.apply(this, arguments);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">&quot;jin&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">child.printName(); <span class="comment">// jin</span></span><br><span class="line">child.sayName(); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>原理：使用 call 或者 apply 更改子类函数的作用域，使 this 执行父类构造函数，子类因此可以继承父类共有属性<br>优点：可解决原型链继承的缺点<br>缺点：不可继承父类的原型链方法，构造函数不可复用</p>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>原理：综合使用构造函数继承和原型链继承。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name, id</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.id = id;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.printName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, id</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>, name, id);</span><br><span class="line">  <span class="comment">// Parent.apply(this, arguments);</span></span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">&quot;jin&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">child.printName(); <span class="comment">// jin</span></span><br><span class="line">child.sayName(); <span class="comment">// jin</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name, id</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.id = id;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.list = [<span class="string">&quot;a&quot;</span>];</span><br><span class="line">  <span class="built_in">this</span>.printName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, id</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>, name, id);</span><br><span class="line">  <span class="comment">// Parent.apply(this, arguments);</span></span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="string">&quot;jin&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">child.printName(); <span class="comment">// jin</span></span><br><span class="line">child.sayName(); <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Child();</span><br><span class="line">a.list.push(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b.list); <span class="comment">// [&#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>优点：可继承父类原型上的属性，且可传参；每个新实例引入的构造函数是私有的<br>缺点：会执行两次父类的构造函数，消耗较大内存，子类的构造函数会代替原型上的那个父类构造函数</p>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>原理：类似 Object.create，用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象，结果是将子对象的__proto__指向父对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = &#123;</span><br><span class="line">  <span class="attr">names</span>: [<span class="string">&quot;a&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = copy(parent);</span><br></pre></td></tr></table></figure>

<p>缺点：共享引用类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;kevin&quot;</span>,</span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&quot;daisy&quot;</span>, <span class="string">&quot;kelly&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createObj(person);</span><br><span class="line"><span class="keyword">var</span> person2 = createObj(person);</span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">&quot;person1&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person2.name); <span class="comment">// kevin</span></span><br><span class="line"></span><br><span class="line">person1.firends.push(<span class="string">&quot;taylor&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person2.friends); <span class="comment">// [&quot;daisy&quot;, &quot;kelly&quot;, &quot;taylor&quot;]</span></span><br></pre></td></tr></table></figure>

<p>注意：修改 person1.name 的值，person2.name 的值并未发生改变，并不是因为 person1 和 person2 有独立的 name 值，而是因为 person1.name = ‘person1’，给 person1 添加了 name 值，并非修改了原型上的 name 值。</p>
<h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象，相当于二次封装原型式继承，并拓展。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObject</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(o);</span><br><span class="line">  clone.getNames = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.names);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.names;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：可添加新的属性和方法<br>缺点：每次创建对象都会创建一遍方法。</p>
<h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>原理：改进组合继承，利用寄生式继承的思想继承原型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = object;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 复制一份父类的原型</span></span><br><span class="line">  <span class="keyword">var</span> p = copy(superClass.prototype);</span><br><span class="line">  <span class="comment">// 修正构造函数</span></span><br><span class="line">  p.constructor = subClass;</span><br><span class="line">  <span class="comment">// 设置子类原型</span></span><br><span class="line">  subClass.prototype = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name, id</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.id = id;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.list = [<span class="string">&quot;a&quot;</span>];</span><br><span class="line">  <span class="built_in">this</span>.printName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, id</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>, name, id);</span><br><span class="line">  <span class="comment">// Parent.apply(this, arguments);</span></span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(Child, Parent);</span><br></pre></td></tr></table></figure>

<p>引用《JavaScript 高级程序设计》中对寄生组合式继承的夸赞就是：</p>
<p>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://github.com/mqyqingfeng/Blog/issues/16">https://github.com/mqyqingfeng/Blog/issues/16</a></p>
]]></content>
      <categories>
        <category>深入理解JavaScript系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>八、JavaScript之闭包</title>
    <url>/2019/09/01/deepjs/%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>闭包在 MDN 中的定义：</p>
<blockquote>
<p>一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。</p>
</blockquote>
<p>这里只有一类函数除外，那就是通过 Function 构造器创建的函数，因为其[[Scope]]只包含全局对象。</p>
<span id="more"></span>

<p>为了更好的澄清该问题，我们对 ECMAScript 中的闭包给出 2 个正确的版本定义：</p>
<p>ECMAScript 中，闭包指的是：</p>
<ol>
<li>从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。</li>
<li>从实践角度：以下函数才算是闭包：</li>
<li>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</li>
<li>在代码中引用了自由变量</li>
</ol>
<p>下面我们主要讨论实践上的闭包。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这里我们需要注意的是：在 ECMAScript 中，同一个父上下文中创建的闭包是共用一个[[Scope]]属性的。也就是说，某个闭包对其中[[Scope]]的变量做修改会影响到其他闭包对其变量的读取：</p>
<p>这就是说：所有的内部函数都共享同一个父作用域</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> firstClosure;</span><br><span class="line"><span class="keyword">var</span> secondClosure;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  firstClosure = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++x;</span><br><span class="line">  &#125;;</span><br><span class="line">  secondClosure = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> --x;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  x = <span class="number">2</span>; <span class="comment">// 影响 AO[&quot;x&quot;], 在2个闭包公有的[[Scope]]中</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(firstClosure()); <span class="comment">// 3, 通过第一个闭包的[[Scope]]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstClosure()); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(secondClosure()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>因为我们经常会遇到这样一个面试题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">  data[k] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>](); <span class="comment">// 3, 而不是0</span></span><br><span class="line">data[<span class="number">1</span>](); <span class="comment">// 3, 而不是1</span></span><br><span class="line">data[<span class="number">2</span>](); <span class="comment">// 3, 而不是2</span></span><br></pre></td></tr></table></figure>

<p>上述当执行到 data[0] 函数之前，此时全局上下文的 VO 为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">globalContext = &#123;</span><br><span class="line">    <span class="attr">VO</span>: &#123;</span><br><span class="line">        <span class="attr">data</span>: [...],</span><br><span class="line">        <span class="attr">k</span>: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当执行 data[0] 函数的时候，data[0] 函数的作用域链为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data[<span class="number">0</span>]Context = &#123;</span><br><span class="line">    <span class="attr">Scope</span>: [AO, globalContext.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>data[0]Context 的 AO 并没有 k 值，所以会从 globalContext.VO 中查找，k 为 3，所以打印的结果就是 3。data[1] 和 data[2] 是一样的道理。<br>如下所示，创建一个闭包就可以解决这个问题了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">  data[k] = (<span class="function"><span class="keyword">function</span> <span class="title">_helper</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(k); <span class="comment">// 传入&quot;k&quot;值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在结果是正确的了</span></span><br><span class="line">data[<span class="number">0</span>](); <span class="comment">// 0</span></span><br><span class="line">data[<span class="number">1</span>](); <span class="comment">// 1</span></span><br><span class="line">data[<span class="number">2</span>](); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>当执行到 data[0] 函数之前，此时全局上下文的 VO 为:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">globalContext = &#123;</span><br><span class="line">    <span class="attr">VO</span>: &#123;</span><br><span class="line">        <span class="attr">data</span>: [...],</span><br><span class="line">        <span class="attr">k</span>: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟之前一样，但是 data[0]的作用域链发生了变化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data[<span class="number">0</span>]Context = &#123;</span><br><span class="line">    <span class="attr">Scope</span>: [AO,_helperContext.AO, globalContext.VO]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 匿名函数执行上下文的 AO 为：</span></span><br><span class="line">_helperContext = &#123;</span><br><span class="line">  <span class="attr">VO</span>: &#123;</span><br><span class="line">         <span class="attr">arguments</span>: &#123;</span><br><span class="line">            <span class="number">0</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">length</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">k</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">Scope</span>: [AO, globalContext.VO]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>data[0]Context 的 AO 并没有 k 值，所以会沿着作用域链从_helperContenx.AO 中查找，这时候找到 k 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 K 的值(值为 3)，所以打印的结果就是 0。同理 data[1]、data[2]的值就是 1 和 2。</p>
<h2 id="闭包用法实战"><a href="#闭包用法实战" class="headerlink" title="闭包用法实战"></a>闭包用法实战</h2><p>实际使用的时候，闭包可以创建出非常优雅的设计，允许对funarg上定义的多种计算方式进行定制。如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组排序,它接受一个排序条件函数作为参数</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  ... <span class="comment">// 排序条件</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的map方法是根据函数中定义的条件将原数组映射到一个新的数组中：</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> element * <span class="number">2</span>;</span><br><span class="line">&#125;); <span class="comment">// [2, 4, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的find方法实现一个搜索功能，并且可以支持无限制的搜索条件：</span></span><br><span class="line">someCollection.find(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> element.someProperty == <span class="string">&#x27;searchCondition&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还有应用函数，比如常见的forEach方法，将函数应用到每个数组元素：</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (element % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(element);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;); <span class="comment">// 1, 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺便提下，函数对象的 apply 和 call方法，在函数式编程中也可以用作应用函数。 apply和call已经在讨论“this”的时候介绍过了；这里，我们将它们看作是应用函数 —— 应用到参数中的函数（在apply中是参数列表，在call中是独立的参数）：</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert([].join.call(<span class="built_in">arguments</span>, <span class="string">&#x27;;&#x27;</span>)); <span class="comment">// 1;2;3</span></span><br><span class="line">&#125;).apply(<span class="built_in">this</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 闭包还有另外一个非常重要的应用 —— 延迟调用：</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(a); <span class="comment">// 10, after one second</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还有回调函数</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// only for example</span></span><br><span class="line">xmlHttpRequestObject.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当数据就绪的时候，才会调用;</span></span><br><span class="line">  <span class="comment">// 这里，不论是在哪个上下文中创建</span></span><br><span class="line">  <span class="comment">// 此时变量“x”的值已经存在了</span></span><br><span class="line">  alert(x); <span class="comment">// 10</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以创建封装的作用域来隐藏辅助对象：</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123;&#125;;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">object</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  object.getX = <span class="function"><span class="keyword">function</span> <span class="title">_getX</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;)(foo);</span><br><span class="line"></span><br><span class="line">alert(foo.getX()); <span class="comment">// 获得闭包 &quot;x&quot; – 10</span></span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures</a><br><a href="https://juejin.cn/post/6844903475998900237">https://juejin.cn/post/6844903475998900237</a><br><a href="http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/">http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/</a></p>
]]></content>
      <categories>
        <category>深入理解JavaScript系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>七、ES6系列之Promise</title>
    <url>/2020/04/28/es6/Promise/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Promises 是用于传递异步计算结果的回调的替代方法。它让您能够把异步操作最终的成功返回值或者失败原因和相应的处理程序关联起来。 这样使得异步方法可以像同步方法那样返回值：异步方法并不会立即返回最终的值，而是会返回一个 promise，以便在未来某个时候把值交给使用者。</p>
<span id="more"></span>

<p>状态：</p>
<ol>
<li>Promise 始终处于三种互斥状态之一：<ul>
<li>待定（pending）: 初始状态，既没有被兑现，也没有被拒绝。</li>
<li>已兑现（fulfilled）: 意味着操作成功完成。</li>
<li>已拒绝（rejected）: 意味着操作失败。。</li>
</ul>
</li>
<li>如果“操作已经完成”（如果它被兑现或被拒绝），则 Promise 将被解决。</li>
<li>一个 Promise 只结算一次，然后保持不变。</li>
</ol>
<p>更改状态：有两种操作可以更改 Promise 的状态。在您调用其中任何一个之后，进一步的调用将无效。</p>
<ol>
<li>Rejecting 意味着承诺被拒绝。</li>
<li>Resolving 返回一个 Promise 用给定值解析的 对象。<ul>
<li>如果值是一个 promise，则返回该 promise;</li>
<li>如果值是 thenable （即有 a “then” method），则返回的承诺将“跟随”该 thenable，采用其最终状态;</li>
<li>返回的承诺将用该值实现</li>
</ul>
</li>
</ol>
<p>Promises 是一种模式，有助于进行一种特定的异步编程：异步返回单个结果的函数（或方法）。通常我们通过回调接收返回的结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunction</span>(<span class="params">name, age, callback</span>) </span>&#123;</span><br><span class="line">  callback(<span class="string">`<span class="subst">$&#123;name&#125;</span>今年<span class="subst">$&#123;age&#125;</span>岁`</span>);</span><br><span class="line">&#125;</span><br><span class="line">asyncFunction(<span class="string">&quot;李磊&quot;</span>, <span class="number">18</span>, <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result); <span class="comment">// 李磊今年18岁</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Promises 提供了一种更好的回调方法：现在异步函数返回一个 Promise 对象，该对象充当占位符和最终结果的容器。通过 Promise 方法注册的回调 then()会收到结果通知：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunction</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">`<span class="subst">$&#123;name&#125;</span>今年<span class="subst">$&#123;age&#125;</span>岁`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">asyncFunction(<span class="string">&quot;李磊&quot;</span>, <span class="number">18</span>).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>与回调相比，Promises 具有以下优点：</p>
<ul>
<li>无控制反转：与同步代码类似，基于 Promise 的函数返回结果，它们不会（直接）通过回调继续并控制执行。也就是说，调用者保持控制。</li>
<li>链接更简单：then()可以返回一个 Promise 对象。因此，您可以链接 then()方法调用<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">asyncFunction1(a, b)</span><br><span class="line">  .then(<span class="function">(<span class="params">result1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result1);</span><br><span class="line">    <span class="keyword">return</span> asyncFunction2(x, y);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">result2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result2);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li>
<li>组合异步调用（循环、映射等）：稍微容易一些，因为您有可以使用的数据（Promise 对象）</li>
<li>错误处理：正如我们稍后将看到的，使用 Promises 的错误处理更简单，因为没有控制反转。此外，异常和异步错误的管理方式相同。</li>
</ul>
<p>来看一个列子：<br>使用 Node.js 风格的回调，异步读取文件如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.readFile(<span class="string">&quot;config.json&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;Error while reading config file&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> obj = <span class="built_in">JSON</span>.parse(text);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj, <span class="literal">null</span>, <span class="number">4</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">&quot;Invalid JSON in file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>使用 Promises，同样的功能是这样使用的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">readFilePromisified(<span class="string">&quot;config.json&quot;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// (A)</span></span><br><span class="line">    <span class="keyword">const</span> obj = <span class="built_in">JSON</span>.parse(text);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj, <span class="literal">null</span>, <span class="number">4</span>));</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// (B)</span></span><br><span class="line">    <span class="comment">// File read error or JSON SyntaxError</span></span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;An error occurred&quot;</span>, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><p>finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。<br>例如，在使用完资源后进行清理。这就是 Promise 方法 finally()的用途，它的工作方式与 finally 异常处理中的子句非常相似。它的回调不接收任何参数，但会收到解决或拒绝的通知。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">createResource(···)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">value1</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Use resource</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">value2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Use resource</span></span><br><span class="line">&#125;)</span><br><span class="line">.finally(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Clean up</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，不管 promise 最后的状态，在执行完 then 或 catch 指定的回调函数以后，都会执行 finally 方法指定的回调函数。</p>
<p>它的实现也很简单。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> P = <span class="built_in">this</span>.constructor;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">    <span class="function">(<span class="params">value</span>) =&gt;</span> P.resolve(callback()).then(<span class="function">() =&gt;</span> value),</span><br><span class="line">    <span class="function">(<span class="params">reason</span>) =&gt;</span></span><br><span class="line">      P.resolve(callback()).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> reason;</span><br><span class="line">      &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p>Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<p>p 的状态由 p1、p2、p3 决定，分成两种情况。</p>
<p>（1）只有 p1、p2、p3 的状态都变成 fulfilled，p 的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数。</p>
<p>（2）只要 p1、p2、p3 之中有一个被 rejected，p 的状态就变成 rejected，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数。</p>
<h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><p>Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><p>有时需要将现有对象转为 Promise 对象，Promise.resolve()方法就起到这个作用。<br>Promise.resolve(x) 工作原理如下：</p>
<ol>
<li>对于大多数值 x，它返回一个满足以下条件的 Promise x： <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&quot;abc&quot;</span>).then(<span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">console</span>.log(x)); <span class="comment">// abc</span></span><br></pre></td></tr></table></figure></li>
<li>如果参数是一个 Promise 实例，那么 Promise.resolve 将不做任何修改、原封不动地返回这个实例： <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">() =&gt;</span> <span class="literal">null</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Promise</span>.resolve(p) === p); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li>如果 参数是一个 thenable 对象。<br> thenable 对象指的是具有 then 方法的对象，比如下面这个对象。 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fulfilledThenable = &#123;</span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">resolve, reject</span>)</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 Promise.resolve()方法会将这个对象转为 Promise 对象，然后就立即执行 thenable 对象的 then()方法。 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fulfilledThenable = &#123;</span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">resolve, reject</span>)</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> promise = <span class="built_in">Promise</span>.resolve(fulfilledThenable);</span><br><span class="line"><span class="built_in">console</span>.log(promise <span class="keyword">instanceof</span> <span class="built_in">Promise</span>); <span class="comment">// true</span></span><br><span class="line">promise.then(<span class="function">(<span class="params">x</span>) =&gt;</span> <span class="built_in">console</span>.log(x)); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
 上面代码中，fulfilledThenable 对象的 then()方法执行后，对象 p1 的状态就变为 resolved，从而立即执行最后那个 then()方法指定的回调函数，输出”hello”。</li>
</ol>
<p>这意味着您可以使用 Promise.resolve()将任何值（Promise、thenable 或其他）转换为 Promise。事实上，Promise.all()和 Promise.race()被用于将任意值的数组转换为 Promise 数组。</p>
<h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><p>Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为 rejected。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myError = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Problem!&quot;</span>);</span><br><span class="line"><span class="built_in">Promise</span>.reject(myError).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err === myError)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>现在我们来看几个关于 Promise 的示例用法:</p>
<h3 id="fs-readFile"><a href="#fs-readFile" class="headerlink" title="fs.readFile()"></a>fs.readFile()</h3><p>以下代码是内置 Node.js 函数的基于 Promise 的版本 fs.readFile()：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">&quot;fs&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFilePromisified</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    readFile(filename, &#123; <span class="attr">encoding</span>: <span class="string">&quot;utf8&quot;</span> &#125;, <span class="function">(<span class="params">error, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"></span><br><span class="line">readFilePromisified(process.argv[<span class="number">2</span>])</span><br><span class="line">  .then(<span class="function">(<span class="params">text</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(text);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h3><p>下面是一个基于 Promise 的函数，它通过基于事件的 XMLHttpRequest API 执行 HTTP GET：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">httpGet</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    request.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="comment">// Success</span></span><br><span class="line">        resolve(<span class="built_in">this</span>.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Something went wrong (404 etc.)</span></span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="built_in">this</span>.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;XMLHttpRequest Error: &quot;</span> + <span class="built_in">this</span>.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line">    request.open(<span class="string">&quot;GET&quot;</span>, url);</span><br><span class="line">    request.send();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用：</span></span><br><span class="line">httpGet(<span class="string">&quot;http://example.com/file.txt&quot;</span>).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Contents: &quot;</span> + value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;Something went wrong&quot;</span>, reason);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="延迟活动"><a href="#延迟活动" class="headerlink" title="延迟活动"></a>延迟活动</h3><p>基于 Promise 实现一个延迟执行函数 delay()。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用:</span></span><br><span class="line">delay(<span class="number">5000</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;5 seconds have passed!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="超时-Promise"><a href="#超时-Promise" class="headerlink" title="超时 Promise"></a>超时 Promise</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms, promise</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    promise.then(resolve);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Timeout after &quot;</span> + ms + <span class="string">&quot; ms&quot;</span>)); <span class="comment">// (A)</span></span><br><span class="line">    &#125;, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">timeout(<span class="number">5000</span>, httpGet(<span class="string">&quot;http://example.com/file.txt&quot;</span>))</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Contents: &quot;</span> + value);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;Error or timeout&quot;</span>, reason);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>虽然超时后的 reject (A) 不会取消请求，但会阻止 resolve 去改变状态。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://codeburst.io/a-simple-guide-to-es6-iterators-in-javascript-with-examples-189d052c3d8e">https://codeburst.io/a-simple-guide-to-es6-iterators-in-javascript-with-examples-189d052c3d8e</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/90">https://github.com/mqyqingfeng/Blog/issues/90</a></li>
</ul>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Es6</tag>
      </tags>
  </entry>
  <entry>
    <title>九、ES6系列之Proxy</title>
    <url>/2020/05/07/es6/Proxy/</url>
    <content><![CDATA[<p>Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</p>
<span id="more"></span>

<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>

<ul>
<li>target: 目标对象</li>
<li>handler: 一个通常以函数作为属性的对象，用来定制拦截行为，各属性中的函数分别定义了在执行各种操作时代理 p 的行为;</li>
</ul>
<p>举个例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, propKey, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;get &quot;</span> + propKey);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.foo);</span><br><span class="line"><span class="comment">// get foo</span></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>上面代码对 target 对象架设了一层拦截，重定义了属性的读取（get）行为。</p>
<h2 id="handler-对象的方法"><a href="#handler-对象的方法" class="headerlink" title="handler 对象的方法"></a>handler 对象的方法</h2><p>handler 对象是一个容纳一批特定属性的占位符对象。它包含有 Proxy 的各个捕获器（trap）。<br>所有的捕捉器是可选的。如果没有定义某个捕捉器，那么就会保留源对象的默认行为。</p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>get 方法用于拦截对象的读取属性操作,可以接受三个参数:</p>
<ul>
<li>target: 目标对象</li>
<li>property: 被获取的属性名</li>
<li>receiver: proxy 实例本身（严格地说，是操作行为所针对的对象）可选。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, propKey, receiver</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (propKey <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[propKey];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">&#x27;Prop name &quot;&#x27;</span> + propKey + <span class="string">&#x27;&quot; does not exist.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>

<p>get 方法会拦截目标对象的以下操作:</p>
<ul>
<li>访问属性: proxy[‘name’]和 proxy.name</li>
<li>访问原型链上的属性: Object.create(proxy)[name]</li>
<li>Reflect.get()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">proxy[<span class="string">&quot;name&quot;</span>]; <span class="comment">// 张三</span></span><br><span class="line"><span class="comment">// proxy.age; // Uncaught ReferenceError: Prop name &quot;age&quot; does not exist.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问原型链上的属性</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(proxy);</span><br><span class="line">obj.name; <span class="comment">// 张三</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reflect.get</span></span><br><span class="line"><span class="built_in">Reflect</span>.get(proxy, <span class="string">&quot;name&quot;</span>); <span class="comment">// 张三</span></span><br><span class="line"><span class="built_in">Reflect</span>.get(proxy, <span class="string">&quot;age&quot;</span>); <span class="comment">// Uncaught ReferenceError: Prop name &quot;age&quot; does not exist.</span></span><br></pre></td></tr></table></figure>

<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set 方法是用来拦截某个属性的赋值操作，可以接受四个参数：</p>
<ul>
<li>target: 目标对象</li>
<li>property: 被获取的属性名</li>
<li>value: 新属性值</li>
<li>receiver: 通常是 proxy 实例本身，可选。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, propKey, value</span>)</span> &#123;</span><br><span class="line">    target[propKey] = value;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;property set: &quot;</span> + propKey + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> proxy); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">proxy.a = <span class="number">10</span>; <span class="comment">// &quot;property set: a = 10&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> proxy); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.a); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>set 方法会拦截目标对象的以下操作:</p>
<ul>
<li>指定属性值：proxy[foo] = bar 和 proxy.foo = bar</li>
<li>指定继承者的属性值：Object.create(proxy)[foo] = bar</li>
<li>Reflect.set()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 访问原型链上的属性</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(proxy);</span><br><span class="line">obj.b = <span class="number">20</span>; <span class="comment">// property set: b = 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reflect.set</span></span><br><span class="line"><span class="built_in">Reflect</span>.set(proxy, <span class="string">&quot;age&quot;</span>, <span class="number">18</span>); <span class="comment">// property set: age = 18</span></span><br></pre></td></tr></table></figure>

<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p>apply() 方法用于拦截函数的调用，call 和 apply 操作，可以接受三个参数:</p>
<ul>
<li>target: 目标对象（函数）。</li>
<li>thisArg: 被调用时的上下文对象。</li>
<li>argumentsList: 被调用时的参数数组。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">target, ctx, args</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Calculate sum: <span class="subst">$&#123;args&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> target(args[<span class="number">0</span>], args[<span class="number">1</span>]) * <span class="number">10</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(sum, handler);</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line">proxy(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// Calculate sum: 1,2</span></span><br><span class="line"><span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p>apply 方法会拦截目标对象的以下操作:</p>
<ul>
<li>proxy(…args)</li>
<li>Function.prototype.apply() 和 Function.prototype.call()</li>
<li>Reflect.apply()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// call、apply</span></span><br><span class="line">proxy.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line">proxy.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reflect.apply</span></span><br><span class="line"><span class="built_in">Reflect</span>.apply(proxy, <span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line"><span class="comment">// Calculate sum: 1,2</span></span><br><span class="line"><span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p>上面的代码结果都是一样的。</p>
<h3 id="has"><a href="#has" class="headerlink" title="has"></a>has</h3><p>has()方法是针对 in 操作符的代理方法，即判断对象是否具有某个属性时，has()方法可以接受两个参数：</p>
<ul>
<li>target: 目标对象。</li>
<li>prop: 需要查询的属性名。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">has</span>(<span class="params">target, key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&quot;_&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key <span class="keyword">in</span> target;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_prop</span>: <span class="string">&quot;foo&quot;</span>, <span class="attr">prop</span>: <span class="string">&quot;foo&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="string">&quot;_prop&quot;</span> <span class="keyword">in</span> proxy; <span class="comment">// false</span></span><br><span class="line"><span class="string">&quot;prop&quot;</span> <span class="keyword">in</span> proxy; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>has 方法会拦截目标对象的以下操作:</p>
<ul>
<li>属性查询: foo in proxy</li>
<li>继承属性查询: foo in Object.create(proxy)</li>
<li>with 检查: with(proxy) { (foo); }</li>
<li>Reflect.has()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(proxy);</span><br><span class="line"><span class="string">&quot;_prop&quot;</span> <span class="keyword">in</span> proxy; <span class="comment">// false</span></span><br><span class="line"><span class="string">&quot;prop&quot;</span> <span class="keyword">in</span> obj; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (proxy) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(prop); <span class="comment">// foo</span></span><br><span class="line">  <span class="built_in">console</span>.log(_prop); <span class="comment">// _prop is not defined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.has(proxy, <span class="string">&quot;prop&quot;</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Reflect</span>.has(proxy, <span class="string">&quot;_prop&quot;</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h3 id="construct"><a href="#construct" class="headerlink" title="construct"></a>construct</h3><p>construct 方法用于拦截 new 操作符. 为了使 new 操作符在生成的 Proxy 对象上生效，用于初始化代理的目标对象自身必须具有[[Construct]]内部方法（即 new target 必须是有效的）。</p>
<p>construct 方法可以接受三个参数。</p>
<ul>
<li>target：目标对象。</li>
<li>args：构造函数的参数数组。</li>
<li>newTarget：创造实例对象时，new 命令作用的构造函数。</li>
</ul>
<p>construct 方法可以拦截以下操作</p>
<ul>
<li>new proxy(…args)</li>
<li>Reflect.construct()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">construct</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, args</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;called: &quot;</span> + args.join(<span class="string">&quot;, &quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">value</span>: args[<span class="number">0</span>] * <span class="number">10</span> &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> p(<span class="number">1</span>).value;</span><br><span class="line"><span class="comment">// called: 1</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.construct(p, [<span class="number">1</span>]).value;</span><br><span class="line"><span class="comment">// called: 1</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty"></a>deleteProperty</h3><p>deleteProperty 方法用于拦截 delete 操作，如果这个方法抛出错误或者返回 false，当前属性就无法被 delete 命令删除。</p>
<p>deleteProperty 方法接受两个个参数：</p>
<ul>
<li>target: 删除属性的目标对象。</li>
<li>propertyKey: 需要删除的属性的名称。</li>
</ul>
<p>该方法拦截以下操作：</p>
<ul>
<li>删除属性: delete proxy[foo] 和 delete proxy.foo</li>
<li>Reflect.deleteProperty()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_prop</span>: <span class="string">&quot;_foo&quot;</span>, <span class="attr">prop</span>: <span class="string">&quot;foo&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="attr">deleteProperty</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&quot;_&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> target[key];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> proxy._prop;</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(target); <span class="comment">// &#123;_prop: &quot;_foo&quot;, prop: &quot;foo&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.deleteProperty(proxy, <span class="string">&quot;prop&quot;</span>);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(target); <span class="comment">// &#123;_prop: &quot;_foo&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h3><p>defineProperty 方法用于拦截对对象的 Object.defineProperty() 操作。它接受三个参数：</p>
<ul>
<li>target: 目标对象。</li>
<li>property: 待检索其描述的属性名。</li>
<li>descriptor: 待定义或修改的属性的描述符。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="attr">defineProperty</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, prop, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prop[<span class="number">0</span>] === <span class="string">&quot;_&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Invalid attempt to define private &quot;<span class="subst">$&#123;prop&#125;</span>&quot; property`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    target[prop] = dsc;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>

<p>该方法会拦截目标对象的以下操作 :</p>
<ul>
<li>proxy.property=’value’</li>
<li>Object.defineProperty()</li>
<li>Reflect.defineProperty()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">proxy._prop = <span class="string">&quot;easily scared&quot;</span>;</span><br><span class="line"><span class="comment">// Uncaught Error: Invalid attempt to define private &quot;_prop&quot; property</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> desc = &#123; <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(proxy, <span class="string">&quot;_a&quot;</span>, desc);</span><br><span class="line"><span class="comment">// Uncaught Error: Invalid attempt to define private &quot;_a&quot; property</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.defineProperty(proxy, <span class="string">&quot;_b&quot;</span>, desc);</span><br><span class="line"><span class="comment">// Uncaught Error: Invalid attempt to define private &quot;_b&quot; property</span></span><br></pre></td></tr></table></figure>

<p>注意：当调用 Object.defineProperty() 或者 Reflect.defineProperty()，传递给 defineProperty 的 descriptor 有一个限制 - 只有以下属性才有用，非标准的属性将会被无视 :</p>
<ul>
<li>enumerable</li>
<li>configurable</li>
<li>writable</li>
<li>value</li>
<li>get</li>
<li>set</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="title">defineProperty</span>(<span class="params">target, prop, descriptor</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(descriptor);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.defineProperty(target, prop, descriptor);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(proxy, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&quot;proxy&quot;</span>,</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;custom&quot;</span>,</span><br><span class="line">&#125;); <span class="comment">// &#123; value: &#x27;proxy&#x27; &#125;</span></span><br><span class="line">proxy.name; <span class="comment">// proxy</span></span><br></pre></td></tr></table></figure>

<h3 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor"></a>getOwnPropertyDescriptor</h3><p>getOwnPropertyDescriptor()方法拦截 Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者 undefined。<br>该方法接受两个参数：</p>
<ul>
<li>target: 目标对象。</li>
<li>prop: 属性名称。</li>
</ul>
<p>可以拦截这些操作:</p>
<ul>
<li>Object.getOwnPropertyDescriptor()</li>
<li>Reflect.getOwnPropertyDescriptor()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">getOwnPropertyDescriptor</span>(<span class="params">target, key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&quot;_&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.getOwnPropertyDescriptor(target, key);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">_prop</span>: <span class="string">&quot;_foo&quot;</span>, <span class="attr">prop</span>: <span class="string">&quot;foo&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">&quot;_prop&quot;</span>);</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(proxy, <span class="string">&quot;prop&quot;</span>);</span><br><span class="line"><span class="comment">// &#123;value: &quot;foo&quot;, writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf"></a>getPrototypeOf</h3><p>getPrototypeOf 是一个代理（Proxy）方法，当读取代理对象的原型时，该方法就会被调用。<br>它的参数只有一个：</p>
<ul>
<li>target: 目标对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">getPrototypeOf</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler);</span><br></pre></td></tr></table></figure>

<p>该方法会拦截以下操作:</p>
<ul>
<li>Object.getPrototypeOf()</li>
<li>Reflect.getPrototypeOf()</li>
<li><strong>proto</strong></li>
<li>Object.prototype.isPrototypeOf()</li>
<li>instanceof</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  <span class="built_in">Object</span>.getPrototypeOf(proxy) === <span class="built_in">Array</span>.prototype, <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">Reflect</span>.getPrototypeOf(proxy) === <span class="built_in">Array</span>.prototype, <span class="comment">// true</span></span><br><span class="line">  proxy.__proto__ === <span class="built_in">Array</span>.prototype, <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">Array</span>.prototype.isPrototypeOf(proxy), <span class="comment">// true</span></span><br><span class="line">  proxy <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible"></a>isExtensible</h3><p>isExtensible() 方法用于拦截对对象的 Object.isExtensible()，同时 isExtensible 方法必须返回一个 Boolean 值或可转换成 Boolean 的值。<br>它的参数：</p>
<ul>
<li>target: 目标对象</li>
</ul>
<p>该方法会拦截目标对象的以下操作:</p>
<ul>
<li>Object.isExtensible()</li>
<li>Reflect.isExtensible()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">isExtensible</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;called&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.isExtensible(proxy); <span class="comment">// called  // true</span></span><br><span class="line"><span class="built_in">Reflect</span>.isExtensible(proxy); <span class="comment">// called  // true</span></span><br></pre></td></tr></table></figure>

<p>注意：Object.isExtensible(proxy) 必须同 Object.isExtensible(target)返回相同值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> empty = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(empty, &#123;</span><br><span class="line">  <span class="attr">isExtensible</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//return 0;return NaN等都会报错</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.isExtensible(proxy); <span class="comment">// TypeError is thrown</span></span><br><span class="line"><span class="comment">// 现在我们把empty对象变成不可扩展的</span></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(empty);</span><br><span class="line"><span class="comment">// 返回了false</span></span><br><span class="line"><span class="built_in">Object</span>.isExtensible(proxy); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>所以 Object.isExtensible(proxy)和 Object.isExtensible(target)的返回值要么都是 true，要么都是 false。</p>
<h3 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys"></a>ownKeys</h3><p>ownKeys()方法用来拦截对象自身属性的读取操作。可接受参数：</p>
<ul>
<li>target: 目标对象</li>
</ul>
<p>可以拦截以下操作:</p>
<ul>
<li>Object.getOwnPropertyNames()</li>
<li>Object.getOwnPropertySymbols()</li>
<li>Object.keys()</li>
<li>Reflect.ownKeys()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">&quot;d&quot;</span>)]: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="attr">ownKeys</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;called&quot;</span>); <span class="comment">// called</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.getOwnPropertyNames(target);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(proxy); <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy2 = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="attr">ownKeys</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;called&quot;</span>); <span class="comment">// called</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.getOwnPropertySymbols(target);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(proxy2); <span class="comment">// [Symbol(d)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy3 = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="attr">ownKeys</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;called&quot;</span>); <span class="comment">// called</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(target);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.keys(proxy3); <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy4 = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="attr">ownKeys</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;called&quot;</span>); <span class="comment">// called</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(target);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(proxy4); <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, Symbol(d) ]</span></span><br></pre></td></tr></table></figure>

<h3 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions"></a>preventExtensions</h3><p>preventExtensions() 方法用于设置对 Object.preventExtensions()的拦截。该方法必须返回一个布尔值，否则会被自动转为布尔值。可接受参数：</p>
<ul>
<li>target: 目标对象</li>
</ul>
<p>可以拦截以下操作:</p>
<ul>
<li>Object.preventExtensions()</li>
<li>Reflect.preventExtensions()</li>
</ul>
<p>这个方法有一个限制，只有目标对象不可扩展时（即 Object.isExtensible(proxy)为 false），proxy.preventExtensions 才能返回 true，否则会报错。<br>错误示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">preventExtensions</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;called&quot;</span>); <span class="comment">//called</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(proxy); <span class="comment">// throw TypeError</span></span><br></pre></td></tr></table></figure>

<p>正确示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">preventExtensions</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;called&quot;</span>); <span class="comment">//called</span></span><br><span class="line">      <span class="built_in">Object</span>.preventExtensions(target);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(proxy);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(proxy)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf"></a>setPrototypeOf</h3><p>setPrototypeOf()方法主要用来拦截 Object.setPrototypeOf()方法。可接受两个参数：</p>
<ul>
<li>target: 目标对象</li>
<li>prototype: 对象新原型或为 null.</li>
</ul>
<p>可以拦截以下操作:</p>
<ul>
<li>Object.setPrototypeOf()</li>
<li>Reflect.setPrototypeOf()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">setPrototypeOf</span>(<span class="params">target, newProto</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;custom error&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newProto = &#123;&#125;,</span><br><span class="line">  target = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(p1, newProto); <span class="comment">// Uncaught Error: custom error</span></span><br><span class="line"><span class="built_in">Reflect</span>.setPrototypeOf(p1, newProto); <span class="comment">// Uncaught Error: custom error</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，只要修改 target 的原型对象，就会报错。</p>
<p>注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（non-extensible），setPrototypeOf()方法不得改变目标对象的原型。</p>
<h2 id="Proxy-revocable"><a href="#Proxy-revocable" class="headerlink" title="Proxy.revocable()"></a>Proxy.revocable()</h2><p>创建一个可撤销的 Proxy 对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; proxy, revoke &#125; = <span class="built_in">Proxy</span>.revocable(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.foo = <span class="number">123</span>;</span><br><span class="line">proxy.foo; <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">revoke();</span><br><span class="line">proxy.foo; <span class="comment">// TypeError: Revoked</span></span><br></pre></td></tr></table></figure>

<p>Proxy.revocable()方法返回一个对象，该对象的 proxy 属性是 Proxy 实例，revoke 属性是一个函数，可以取消 Proxy 实例。上面代码中，当执行 revoke 函数之后，再访问 Proxy 实例，就会抛出一个错误。</p>
<p>Proxy.revocable()的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></li>
<li><a href="https://es6.ruanyifeng.com/">https://es6.ruanyifeng.com/</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Es6</tag>
      </tags>
  </entry>
  <entry>
    <title>十、ES6系列之Reflect</title>
    <url>/2020/05/09/es6/Reflect/</url>
    <content><![CDATA[<p>Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与 proxy handlers 的方法相同。Reflect 不是一个函数对象，因此它是不可构造的。</p>
<span id="more"></span>

<p>Reflect 的所有属性和方法都是静态的（就像 Math 对象）。<br>Reflect 对象提供了以下静态方法，这些方法与 proxy handler methods 的命名相同。</p>
<ul>
<li>Reflect.apply(target, thisArg, args)<br>对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和 Function.prototype.apply() 功能类似。</li>
<li>Reflect.construct(target, args)<br>对构造函数进行 new 操作，相当于执行 new target(…args)。</li>
<li>Reflect.get(target, name, receiver)<br>获取对象身上某个属性的值，类似于 target[name]。</li>
<li>Reflect.set(target, name, value, receiver)<br>将值分配给属性的函数。返回一个 Boolean，如果更新成功，则返回 true。</li>
<li>Reflect.defineProperty(target, name, desc)<br>和 Object.defineProperty() 类似。如果设置成功就会返回 true</li>
<li>Reflect.deleteProperty(target, name)<br>作为函数的 delete 操作符，相当于执行 delete target[name]。</li>
<li>Reflect.has(target, name)<br>判断一个对象是否存在某个属性，和 in 运算符 的功能完全相同。</li>
<li>Reflect.ownKeys(target)<br>返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 Object.keys(), 但不会受 enumerable 影响).</li>
<li>Reflect.isExtensible(target)<br>类似于 Object.isExtensible().</li>
<li>Reflect.preventExtensions(target)<br>类似于 Object.preventExtensions()。返回一个 Boolean。</li>
<li>Reflect.getOwnPropertyDescriptor(target, name)<br>类似于 Object.getOwnPropertyDescriptor()。如果对象中存在该属性，则返回对应的属性描述符, 否则返回 undefined.</li>
<li>Reflect.getPrototypeOf(target)<br>类似于 Object.getPrototypeOf()。</li>
<li>Reflect.setPrototypeOf(target, prototype)<br>设置对象原型的函数. 返回一个 Boolean， 如果更新成功，则返回 true。</li>
</ul>
<p>由于 Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。所以具体的方法使用这里不做过多描述。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></li>
<li><a href="https://es6.ruanyifeng.com/">https://es6.ruanyifeng.com/</a></li>
</ul>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Es6</tag>
      </tags>
  </entry>
  <entry>
    <title>五、ES6系列之Set和Map</title>
    <url>/2020/04/18/es6/SetMap/</url>
    <content><![CDATA[<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>ES6 提供了新的数据结构 Set，它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<span id="more"></span>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>Set 本身是一个构造函数，用来生成 Set 数据结构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br></pre></td></tr></table></figure>

<p>Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(set); <span class="comment">// Set(4) &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;div&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(set.size); <span class="comment">// 66</span></span><br><span class="line"></span><br><span class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));</span><br><span class="line"><span class="built_in">console</span>.log(set.size); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>上面代码也展示了一种去除数组重复成员的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 去除数组的重复成员</span></span><br><span class="line">[...new <span class="built_in">Set</span>(array)];</span><br></pre></td></tr></table></figure>

<p>上面的方法也可以用于，去除字符串里面的重复字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>(<span class="string">&quot;ababbc&quot;</span>)].join(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure>

<p>Set 中加入值时，不会发生类型转换。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是向 Set 加入值时认为 NaN 等于自身，而精确相等运算符认为 NaN 不等于自身，另外，两个对象总是不相等的。。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">set.add(<span class="number">5</span>);</span><br><span class="line">set.add(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">set; <span class="comment">//Set(2) &#123;5, &quot;5&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">set.add(<span class="literal">NaN</span>);</span><br><span class="line">set.add(<span class="literal">NaN</span>);</span><br><span class="line">set; <span class="comment">//Set(3) &#123;5, &quot;5&quot;, NaN&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> set2 = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">set2.add(&#123;&#125;);</span><br><span class="line">set.size; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">set2.add(&#123;&#125;);</span><br><span class="line">set.size; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>Set 结构的实例有以下属性。</p>
<ul>
<li>Set.prototype.constructor：构造函数，默认就是 Set 函数。</li>
<li>Set.prototype.size：返回 Set 实例的成员总数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">set.add(<span class="number">1</span>);</span><br><span class="line">set.add(<span class="number">2</span>);</span><br><span class="line">set.size; <span class="comment">//2</span></span><br><span class="line">set.constructor === <span class="built_in">Set</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>方法分为操作方法和遍历方法：</p>
<p>操作方法有：</p>
<ol>
<li>add(value)：添加某个值，返回 Set 结构本身。</li>
<li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>has(value)：返回一个布尔值，表示该值是否为 Set 的成员。</li>
<li>clear()：清除所有成员，无返回值。</li>
</ol>
<p>请看示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">set.add(<span class="number">1</span>).add(<span class="number">2</span>); <span class="comment">// Set(2) &#123;1, 2&#125;</span></span><br><span class="line">set.delete(<span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line">set.has(<span class="number">2</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">set.clear(); <span class="comment">// undefined</span></span><br><span class="line">set.has(<span class="number">1</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>遍历方法有：</p>
<ol>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回键值对的遍历器</li>
<li>forEach()：使用回调函数遍历每个成员，无返回值</li>
</ol>
<p>注意 keys()、values()、entries() 返回的是遍历器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;red&quot;, &quot;red&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;green&quot;, &quot;green&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;blue&quot;, &quot;blue&quot;]</span></span><br></pre></td></tr></table></figure>

<p>forEach 方法的参数就是一个处理函数。该函数的参数与数组的 forEach 一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。</p>
<p>另外，forEach 方法还可以有第二个参数，表示绑定处理函数内部的 this 对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]);</span><br><span class="line">set.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="built_in">console</span>.log(key + <span class="string">&quot; : &quot;</span> + value));</span><br><span class="line"><span class="comment">// 1 : 1</span></span><br><span class="line"><span class="comment">// 4 : 4</span></span><br><span class="line"><span class="comment">// 9 : 9</span></span><br></pre></td></tr></table></figure>

<h2 id="weakSet"><a href="#weakSet" class="headerlink" title="weakSet"></a>weakSet</h2><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p>
<ol>
<li>WeakSet 的成员只能是对象，而不能是其他类型的值。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line">ws.add(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// TypeError: Invalid value used in weak set</span></span><br><span class="line">ws.add(<span class="built_in">Symbol</span>());</span><br><span class="line"><span class="comment">// TypeError: invalid value used in weak set</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>WeakSet 中的对象都是弱引用。</li>
</ol>
<p>即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。<br>可以用来保存 DOM 节点，不容易造成内存泄漏，不能遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> john = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> weakSet = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line">weakSet.add(john);</span><br><span class="line"></span><br><span class="line">john = <span class="literal">null</span>; <span class="comment">// 覆盖引用</span></span><br><span class="line"><span class="comment">// john 被从内存删除了</span></span><br></pre></td></tr></table></figure>

<p>WeakSet 结构没有 size 属性，有以下三个方法。：</p>
<ul>
<li>weakSet.add(key)</li>
<li>weakSet.delete(key)</li>
<li>weakSet.has(key)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">ws.add(<span class="built_in">window</span>);</span><br><span class="line">ws.add(obj);</span><br><span class="line"></span><br><span class="line">ws.has(<span class="built_in">window</span>); <span class="comment">// true</span></span><br><span class="line">ws.has(foo); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">ws.delete(<span class="built_in">window</span>);</span><br><span class="line">ws.has(<span class="built_in">window</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">ws.size; <span class="comment">// undefined</span></span><br><span class="line">ws.forEach; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">ws.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;WeakSet has &quot;</span> + item);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// TypeError: undefined is not a function</span></span><br></pre></td></tr></table></figure>

<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>ES6 提供了新的数据结构 Map 。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> o = &#123; <span class="attr">name</span>: <span class="string">&quot;lilei&quot;</span> &#125;;</span><br><span class="line">m.set(o, <span class="string">&quot;content&quot;</span>);</span><br><span class="line">m.get(o); <span class="comment">//&quot;content&quot;</span></span><br><span class="line"></span><br><span class="line">m.has(o); <span class="comment">// true</span></span><br><span class="line">m.delete(o); <span class="comment">// true</span></span><br><span class="line">m.has(o); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;title&quot;</span>, <span class="string">&quot;Author&quot;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">map.size; <span class="comment">// 2</span></span><br><span class="line">map.has(<span class="string">&quot;name&quot;</span>); <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">&quot;name&quot;</span>); <span class="comment">// &quot;张三&quot;</span></span><br><span class="line">map.has(<span class="string">&quot;title&quot;</span>); <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">&quot;title&quot;</span>); <span class="comment">// &quot;Author&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="属性和方法-1"><a href="#属性和方法-1" class="headerlink" title="属性和方法"></a>属性和方法</h3><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><p>Map 结构的实例有以下属性。</p>
<ul>
<li>Map.prototype.constructor：构造函数，默认就是 Map 函数。</li>
<li>Map.prototype.size：返回 Map 实例的成员总数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="number">1</span>, <span class="string">&quot;li&quot;</span>);</span><br><span class="line">map.set(<span class="number">2</span>, <span class="string">&quot;wang&quot;</span>);</span><br><span class="line">map.size; <span class="comment">//2</span></span><br><span class="line">map.constructor === <span class="built_in">Map</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><p>方法分为操作方法和遍历方法：</p>
<p>操作方法有：</p>
<ol>
<li>set(key, value)：设置键名 key 对应的键值为 value，返回 Map 结构本身。</li>
<li>get(key)：读取 key 对应的键值，如果找不到 key，返回 undefined。</li>
<li>delete(key)：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>has(key)：返回一个布尔值，表示该值是否为 Map 的成员。</li>
<li>clear()：清除所有成员，无返回值。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="number">1</span>, <span class="string">&quot;li&quot;</span>);</span><br><span class="line">map.set(<span class="number">2</span>, <span class="string">&quot;wang&quot;</span>);</span><br><span class="line">map.get(<span class="number">1</span>); <span class="comment">// &quot;li&quot;</span></span><br><span class="line">map.delete(<span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line">map.has(<span class="number">1</span>); <span class="comment">// false</span></span><br><span class="line">map.clear(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>遍历方法有：</p>
<ol>
<li>keys()：返回键名的遍历器</li>
<li>values()：返回键值的遍历器</li>
<li>entries()：返回键值对的遍历器</li>
<li>forEach()：遍历 Map 的所有成员。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;age&quot;</span>, <span class="number">18</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;name&quot;</span></span><br><span class="line"><span class="comment">// &quot;age&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;zhangsan&quot;</span></span><br><span class="line"><span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item[<span class="number">0</span>], item[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name zhangsan</span></span><br><span class="line"><span class="comment">// age 18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name zhangsan</span></span><br><span class="line"><span class="comment">// age 18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于使用map.entries()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name zhangsan</span></span><br><span class="line"><span class="comment">// age 18</span></span><br></pre></td></tr></table></figure>

<p>Map 还有一个 forEach 方法，与数组的 forEach 方法类似，也可以实现遍历。forEach 方法还可以接受第二个参数，用来绑定 this。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">&quot;one&quot;</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">&quot;two&quot;</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">&quot;three&quot;</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">const</span> reporter = &#123;</span><br><span class="line">  <span class="attr">report</span>: <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Key: %s, Value: %s&quot;</span>, key, value);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">map.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, key, map</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.report(key, value);</span><br><span class="line">&#125;, reporter);</span><br></pre></td></tr></table></figure>

<h2 id="weakMap"><a href="#weakMap" class="headerlink" title="weakMap"></a>weakMap</h2><p>WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。<br>WeakMap 与 Map 的区别有两点。</p>
<ol>
<li>只接受对象作为键名（null 除外），不接受其他类型的值作为键名。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">map.set(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// TypeError: 1 is not an object!</span></span><br><span class="line">map.set(<span class="built_in">Symbol</span>(), <span class="number">2</span>);</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br><span class="line">map.set(<span class="literal">null</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的。</li>
</ol>
<p>即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&quot;example&quot;</span>);</span><br><span class="line"></span><br><span class="line">wm.set(element, <span class="string">&quot;some information&quot;</span>);</span><br><span class="line">wm.get(element); <span class="comment">// &quot;some information&quot;</span></span><br></pre></td></tr></table></figure>

<p>WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有 keys()、values()和 entries()方法），也没有 size 属性。二是无法清空，即不支持 clear 方法。因此，WeakMap 只有四个方法可用：get()、set()、has()、delete()。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// size、forEach、clear 方法都不存在</span></span><br><span class="line">wm.size; <span class="comment">// undefined</span></span><br><span class="line">wm.forEach; <span class="comment">// undefined</span></span><br><span class="line">wm.clear; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>例如，我们有用于处理用户访问计数的代码。收集到的信息被存储在 map 中：一个用户对象作为键，其访问次数为值。当一个用户离开时（该用户对象将被垃圾回收机制回收），这时我们就不再需要他的访问次数了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">复制代码;</span><br><span class="line"><span class="comment">// visitsCount.js</span></span><br><span class="line"><span class="keyword">let</span> visitsCountMap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>(); <span class="comment">// weakmap: user =&gt; visits count</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递增用户来访次数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countUser</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = visitsCountMap.get(user) || <span class="number">0</span>;</span><br><span class="line">  visitsCountMap.set(user, count + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://es6.ruanyifeng.com/#docs/symbol">https://es6.ruanyifeng.com/#docs/symbol</a></li>
</ul>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Es6</tag>
      </tags>
  </entry>
  <entry>
    <title>四、ES6系列之Symbol</title>
    <url>/2020/04/16/es6/Symbol/</url>
    <content><![CDATA[<p>Symbol 是一种基本数据类型，Symbol()函数会返回 是一种基本数据类型，Symbol 类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的 symbol 注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法：”new Symbol()”。</p>
<span id="more"></span>

<p>每个从 Symbol()返回的 symbol 值都是唯一的。一个 symbol 值能作为对象属性的标识符；这是该数据类型仅有的目的。</p>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><ol>
<li>Symbol 值通过 Symbol 函数生成，使用 typeof，结果为 “symbol”</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>不能使用 new 命令</li>
</ol>
<p>因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p>
<ol start="3">
<li>可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1); <span class="comment">// Symbol(foo)</span></span><br><span class="line">s1.toString(); <span class="comment">// &quot;Symbol(foo)&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>instanceof 的结果为 false</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">s <span class="keyword">instanceof</span> <span class="built_in">Symbol</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>如果 Symbol 的参数是一个对象，就会调用该对象的 toString 方法，将其转为字符串，然后才生成一个 Symbol 值。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lilei&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> s = <span class="built_in">Symbol</span>(obj);</span><br><span class="line"><span class="built_in">console</span>.log(s); <span class="comment">// Symbol(lilei)</span></span><br></pre></td></tr></table></figure>

<h2 id="Symbol-作为属性名"><a href="#Symbol-作为属性名" class="headerlink" title="Symbol 作为属性名"></a>Symbol 作为属性名</h2><p>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">&quot;Hello!&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">&quot;Hello!&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol]; <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意，Symbol 值作为对象属性名时，不能用点运算符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">a.mySymbol = <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">a[mySymbol]; <span class="comment">// undefined</span></span><br><span class="line">a[<span class="string">&quot;mySymbol&quot;</span>]; <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure>

<p>同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [s]: <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[s](<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<h2 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h2><p>Symbol 作为属性名，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。<br>但是，它也不是私有属性，有一个 Object.getOwnPropertySymbols 方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">obj[b] = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"></span><br><span class="line">objectSymbols;</span><br><span class="line"><span class="comment">// [Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure>

<h2 id="Symbol-for"><a href="#Symbol-for" class="headerlink" title="Symbol.for()"></a>Symbol.for()</h2><p>如果我们希望重新使用同一个 Symbol 值，Symbol.for()方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，s1 和 s2 都是 Symbol 值，但是它们都是由同样参数的 Symbol.for 方法生成的，所以实际上是同一个值。<br>注意，Symbol.for()为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Symbol-keyFor"><a href="#Symbol-keyFor" class="headerlink" title="Symbol.keyFor()"></a>Symbol.keyFor()</h2><p>Symbol.keyFor()方法返回一个已登记的 Symbol 类型值的 key。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s1)); <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s2)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://es6.ruanyifeng.com/#docs/symbol">https://es6.ruanyifeng.com/#docs/symbol</a></li>
</ul>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Es6</tag>
      </tags>
  </entry>
  <entry>
    <title>十一、ES6系列之Async</title>
    <url>/2020/05/15/es6/async/</url>
    <content><![CDATA[<h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>
<p>在异步处理上，async 函数就是 Generator 函数的语法糖。</p>
<span id="more"></span>

<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 generator</span></span><br><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">&quot;node-fetch&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">&quot;co&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> r1 = <span class="keyword">yield</span> fetch(<span class="string">&quot;https://api.github.com/users/github&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> json1 = <span class="keyword">yield</span> r1.json();</span><br><span class="line">  <span class="built_in">console</span>.log(json1.bio);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">co(gen);</span><br></pre></td></tr></table></figure>

<p>当你使用 async 时：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 async</span></span><br><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">&quot;node-fetch&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fetchData = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> r1 = <span class="keyword">await</span> fetch(<span class="string">&quot;https://api.github.com/users/github&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> json1 = <span class="keyword">await</span> r1.json();</span><br><span class="line">  <span class="built_in">console</span>.log(json1.bio);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fetchData();</span><br></pre></td></tr></table></figure>

<p>一比较就会发现，其实 async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> spawn(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spawn 函数指的是自动执行器，就比如说 co。</p>
<p>再加上 async 函数返回一个 Promise 对象，你也可以理解为 async 函数是基于 Promise 和 Generator 的一层封装。<br>下面给出 spawn 函数的实现，基本就是前文自动执行器的翻版。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span>(<span class="params">genF</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> gen = genF();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">nextF</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> next;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        next = nextF();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (next.done) &#123;</span><br><span class="line">        <span class="keyword">return</span> resolve(next.value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(next.value).then(</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">          step(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> gen.next(v);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">          step(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> gen.throw(e);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    step(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> gen.next(<span class="literal">undefined</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveAfter2Seconds</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncCall</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;calling&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> resolveAfter2Seconds(<span class="number">2000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;ending&quot;</span>);</span><br><span class="line">  <span class="comment">// expected output: &quot;ending&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncCall();</span><br></pre></td></tr></table></figure>

<p>由于 async 函数返回的是 Promise 对象，可以作为 await 命令的参数。所以，上面的例子也可以写成下面的形式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveAfter2Seconds</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncCall</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;calling&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> resolveAfter2Seconds(<span class="number">2000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;ending&quot;</span>);</span><br><span class="line">  <span class="comment">// expected output: &quot;ending&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncCall();</span><br></pre></td></tr></table></figure>

<h2 id="继发与并发"><a href="#继发与并发" class="headerlink" title="继发与并发"></a>继发与并发</h2><p>问题：给定一个 URL 数组，如何实现接口的继发和并发？</p>
<p>async 继发实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继发一</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">await</span> fetch(url1);</span><br><span class="line">  <span class="keyword">var</span> res2 = <span class="keyword">await</span> fetch(url2);</span><br><span class="line">  <span class="keyword">var</span> res3 = <span class="keyword">await</span> fetch(url3);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;whew all done&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继发二</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params">urls</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> url <span class="keyword">of</span> urls) &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> response.text());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>async 并发实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 并发一</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([fetch(url1), fetch(url2), fetch(url3)]);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;whew all done&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发二</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loadData</span>(<span class="params">urls</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 并发读取 url</span></span><br><span class="line">  <span class="keyword">const</span> textPromises = urls.map(<span class="keyword">async</span> (url) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">    <span class="keyword">return</span> response.text();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按次序输出</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> textPromise <span class="keyword">of</span> textPromises) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> textPromise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="错误捕获"><a href="#错误捕获" class="headerlink" title="错误捕获"></a>错误捕获</h2><p>尽管我们可以使用 try catch 捕获错误，但是当我们需要捕获多个错误并做不同的处理时，很快 try catch 就会导致代码杂乱，就比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;出错了&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;出错了2&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;出错了3&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了简化这种错误的捕获，我们可以给 await 后的 promise 对象添加 catch 函数，为此我们需要写一个 helper:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// to.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">to</span>(<span class="params">promise</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> promise</span><br><span class="line">    .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> [<span class="literal">null</span>, data];</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> [err]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简化后的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> to <span class="keyword">from</span> <span class="string">&quot;./to.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  [err, user] = <span class="keyword">await</span> to(</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;出错了&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (!user) <span class="built_in">console</span>.log(err);</span><br><span class="line"></span><br><span class="line">  [err, user] = <span class="keyword">await</span> to(</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;出错了2&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(err);</span><br><span class="line"></span><br><span class="line">  [err, user] = <span class="keyword">await</span> to(</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;出错了3&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (!user) <span class="built_in">console</span>.log(err);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/100">https://github.com/mqyqingfeng/Blog/issues/100</a></li>
<li><a href="https://es6.ruanyifeng.com/#docs/async">https://es6.ruanyifeng.com/#docs/async</a></li>
</ul>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Es6</tag>
      </tags>
  </entry>
  <entry>
    <title>十二、ES6系列之Class基本用法</title>
    <url>/2020/05/18/es6/class%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在 JavaScript 语言中，生成实例对象的传统方法是通过构造函数。</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;hello, I am &quot;</span> + <span class="built_in">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> kevin = <span class="keyword">new</span> Person(<span class="string">&quot;Kevin&quot;</span>);</span><br><span class="line">kevin.sayHello(); <span class="comment">// hello, I am Kevin</span></span><br></pre></td></tr></table></figure>

<p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过 class 关键字，可以定义类。<br>ES6 的 class 可以看作一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello, I am &quot;</span> + <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> kevin = <span class="keyword">new</span> Person(<span class="string">&quot;Kevin&quot;</span>);</span><br><span class="line">kevin.sayHello(); <span class="comment">// hello, I am Kevin</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到 ES5 的构造函数 Person，对应 ES6 的 Person 类的 constructor 方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Person.prototype.constructor === Person; <span class="comment">// true</span></span><br><span class="line">kevin.constructor === Person.prototype.constructor; <span class="comment">// true</span></span><br><span class="line">kevin.sayHello === Person.prototype.sayHello; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码表明，类本身就指向构造函数，类的所有方法都定义在类的 prototype 属性上面。</p>
<p>值得注意的是：类的内部所有定义的方法，都是不可枚举的（non-enumerable）</p>
<p>以上面的例子为例，在 ES6 中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(Person.prototype); <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Person.prototype); <span class="comment">// [&quot;constructor&quot;, &quot;sayHello&quot;]</span></span><br></pre></td></tr></table></figure>

<p>然而在 ES5 中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.keys(Person.prototype); <span class="comment">// [&#x27;sayHello&#x27;]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Person.prototype); <span class="comment">// [&quot;constructor&quot;, &quot;sayHello&quot;]</span></span><br></pre></td></tr></table></figure>

<h2 id="类的实例"><a href="#类的实例" class="headerlink" title="类的实例"></a>类的实例</h2><p>生成类的实例的写法，与 ES5 完全一样，也是使用 new 命令。如果忘记加上 new，像函数那样调用 Class，将会报错。<br>这也是类跟普通构造函数的一个主要区别，后者不用 new 也可以执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> person = Person(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在 this 对象上），否则都是定义在原型上（即定义在 class 上）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="string">&quot;hello, I am &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;and I&#x27;m &quot;</span> + <span class="built_in">this</span>.age + <span class="string">&quot; years old today&quot;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> kevin = <span class="keyword">new</span> Person(<span class="string">&quot;Kevin&quot;</span>，<span class="number">8</span>);</span><br><span class="line">kevin.sayHello(); <span class="comment">// &quot;hello, I am Kevinand I&#x27;m 8 years old today&quot;</span></span><br><span class="line">kevin.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">kevin.hasOwnProperty(<span class="string">&#x27;age&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">kevin.hasOwnProperty(<span class="string">&#x27;sayHello&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">kevin.__proto__.hasOwnProperty(<span class="string">&#x27;sayHello&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>同样，类的所有实例共享一个原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&quot;lilei&quot;</span>, <span class="number">13</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">&quot;hanmeimei&quot;</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">p1.__proto__ === p2.__proto__; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><p>以前，我们定义实例属性，只能写在类的 constructor 方法里面。比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而现在也可以定义在类的最顶层，其他都不变：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  _count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应到 ES5 都是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>._count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上 static 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<p>ES6 中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.sayHello(); <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> kevin = <span class="keyword">new</span> Person();</span><br><span class="line">kevin.sayHello(); <span class="comment">// TypeError: kevin.sayHello is not a function</span></span><br></pre></td></tr></table></figure>

<p>对应 ES5：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person.sayHello(); <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> kevin = <span class="keyword">new</span> Person();</span><br><span class="line">kevin.sayHello(); <span class="comment">// TypeError: kevin.sayHello is not a function</span></span><br></pre></td></tr></table></figure>

<h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><p>静态属性指的是 Class 本身的属性，即 Class.propName，而不是定义在实例对象（this）上的属性。以前，我们添加静态属性只可以这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.name = <span class="string">&quot;kevin&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>现在有一个提案提供了类的静态属性，写法是在实例属性的前面，加上 static 关键字。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> name = <span class="string">&quot;kevin&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应到 ES5 都是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.name = <span class="string">&quot;kevin&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="getter-和-setter"><a href="#getter-和-setter" class="headerlink" title="getter 和 setter"></a>getter 和 setter</h2><p>与 ES5 一样，在“类”的内部可以使用 get 和 set 关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;kevin&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">name</span>(<span class="params">newName</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;new name 为：&quot;</span> + newName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person.name = <span class="string">&quot;daisy&quot;</span>;</span><br><span class="line"><span class="comment">// new name 为：daisy</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br><span class="line"><span class="comment">// kevin</span></span><br></pre></td></tr></table></figure>

<p>对应到 ES5 中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;kevin&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title">name</span>(<span class="params">newName</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;new name 为：&quot;</span> + newName);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person.name = <span class="string">&quot;daisy&quot;</span>;</span><br><span class="line"><span class="comment">// new name 为：daisy</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br><span class="line"><span class="comment">// kevin</span></span><br></pre></td></tr></table></figure>

<h2 id="Babel-编译"><a href="#Babel-编译" class="headerlink" title="Babel 编译"></a>Babel 编译</h2><p>现在我们已经知道了有关“类”的方法中，ES6 与 ES5 是如何对应的，实际上 Babel 在编译时并不会直接就转成这种形式，Babel 会自己生成一些辅助函数，帮助实现 ES6 的特性。</p>
<p>我们可以在 Babel 官网的 <a href="https://babeljs.io/repl/#?babili=false&evaluate=true&lineWrap=false&presets=es2015%2Creact%2Cstage-2&targets=&browsers=&builtIns=false&debug=false&code_lz=Q">Try it out</a> 页面查看 ES6 的代码编译成什么样子。</p>
<h3 id="编译（一）"><a href="#编译（一）" class="headerlink" title="编译（一）"></a>编译（一）</h3><p>ES6 代码为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Babel 编译为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_instanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    right != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">&quot;undefined&quot;</span> &amp;&amp;</span><br><span class="line">    right[<span class="built_in">Symbol</span>.hasInstance]</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> !!right[<span class="built_in">Symbol</span>.hasInstance](left);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> left <span class="keyword">instanceof</span> right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!_instanceof(instance, Constructor)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Cannot call a class as a function&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  _classCallCheck(<span class="built_in">this</span>, Person);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>_instanceof 用于判断某对象是否为某构造器的实例。<br>_classCallCheck 的作用是检查 Person 是否是通过 new 的方式调用，在上面，我们也说过，类必须使用 new 调用，否则会报错。</p>
<p>当我们使用 var person = Person() 的形式调用的时候，this 指向 window，所以 instance instanceof Constructor 就会为 false，与 ES6 的要求一致。</p>
<h3 id="编译（二）"><a href="#编译（二）" class="headerlink" title="编译（二）"></a>编译（二）</h3><p>ES6 代码为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 实例属性</span></span><br><span class="line">  foo = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">  <span class="comment">// 静态属性</span></span><br><span class="line">  <span class="keyword">static</span> bar = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_instanceof</span>(<span class="params">left, right</span>) </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_defineProperty</span>(<span class="params">obj, key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">      <span class="attr">value</span>: value,</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">writable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    obj[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  _classCallCheck(<span class="built_in">this</span>, Person);</span><br><span class="line"></span><br><span class="line">  _defineProperty(<span class="built_in">this</span>, <span class="string">&quot;foo&quot;</span>, <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_defineProperty(Person, <span class="string">&quot;bar&quot;</span>, <span class="string">&#x27;bar&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>_defineProperty 的作用是给某对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p>
<h3 id="编译（三）"><a href="#编译（三）" class="headerlink" title="编译（三）"></a>编译（三）</h3><p>ES6 代码为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello, I am &quot;</span> + <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">onlySayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;kevin&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title">name</span>(<span class="params">newName</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;new name 为：&quot;</span> + newName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应到 ES5 的代码应该是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="attr">sayHello</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello, I am &quot;</span> + <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;kevin&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title">name</span>(<span class="params">newName</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;new name 为：&quot;</span> + newName);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person.onlySayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Babel 编译后为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_instanceof</span>(<span class="params">left, right</span>) </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_defineProperty</span>(<span class="params">obj, key, value</span>) </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createClass</span>(<span class="params">Constructor, protoProps, staticProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (protoProps) _defineProperties(Constructor.prototype, protoProps);</span><br><span class="line">  <span class="keyword">if</span> (staticProps) _defineProperties(Constructor, staticProps);</span><br><span class="line">  <span class="keyword">return</span> Constructor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Person = <span class="comment">/*#__PURE__*/</span><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    _classCallCheck(<span class="built_in">this</span>, Person);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _createClass(Person, [&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&quot;sayHello&quot;</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;hello, I am &quot;</span> + <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&quot;name&quot;</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;kevin&quot;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">newName</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;new name 为：&quot;</span> + newName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;], [&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&quot;onlySayHello&quot;</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> <span class="title">onlySayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Person;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<p>我们可以看到 Babel 生成了一个 _createClass 辅助函数，该函数传入三个参数，第一个是构造函数，在这个例子中也就是 Person，第二个是要添加到原型上的函数数组，第三个是要添加到构造函数本身的函数数组，也就是所有添加 static 关键字的函数。该函数的作用就是将函数数组中的方法添加到构造函数或者构造函数的原型中，最后返回这个构造函数。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/105">https://github.com/mqyqingfeng/Blog/issues/105</a></li>
<li><a href="https://es6.ruanyifeng.com/#docs/class">https://es6.ruanyifeng.com/#docs/class</a></li>
</ul>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Es6</tag>
      </tags>
  </entry>
  <entry>
    <title>十三、ES6系列之Class的继承</title>
    <url>/2020/05/20/es6/class%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在 ES5 中，实现继承的方式有多种，详细可以参考前面的文章<a href="https://hedahang.github.io/2019/09/30/deepjs/%E7%BB%A7%E6%89%BF%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9/">JavaScript 之继承的多种方式和优缺点</a>，这里主要说说 ES6 中 Class 的继承。</p>
<span id="more"></span>

<p>Class 可以通过 extends 关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name); <span class="comment">// 调用父类的 constructor(name)</span></span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">&quot;kevin&quot;</span>, <span class="string">&quot;18&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1);</span><br></pre></td></tr></table></figure>

<p>值得注意的是：</p>
<p>super 关键字表示父类的构造函数，相当于 ES5 的 Parent.call(this)。<br>子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工。如果不调用 super 方法，子类就得不到 this 对象。<br>也正是因为这个原因，在子类的构造函数中，只有调用 super 之后，才可以使用 this 关键字，否则会报错。</p>
<h2 id="类的-prototype-属性和proto属性"><a href="#类的-prototype-属性和proto属性" class="headerlink" title="类的 prototype 属性和proto属性"></a>类的 prototype 属性和<strong>proto</strong>属性</h2><p>在 ES5 实现之中，每一个对象都有__proto__属性，指向对应的构造函数的 prototype 属性。在 ES6 中，父类的静态方法，可以被子类继承，Class 作为构造函数的语法糖，同时有 prototype 属性和__proto__属性，因此同时存在两条继承链。</p>
<ol>
<li>子类的__proto__属性，表示构造函数的继承，总是指向父类。</li>
<li>子类 prototype 属性的__proto__属性，表示方法的继承，总是指向父类的 prototype 属性。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod(); <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(Child.__proto__ === Parent); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Child.prototype.__proto__ === Parent.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>ES6 的原型链示意图为：</p>
<p><img src="/images/class-prototype.png" alt="(原型图)"></p>
<p>我们会发现，相比寄生组合式继承，ES6 的 class 多了一个 Object.setPrototypeOf(Child, Parent) 的步骤。</p>
<p>Object.setPrototypeOf 等同于：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf = <span class="function"><span class="keyword">function</span> (<span class="params">obj, proto</span>) </span>&#123;</span><br><span class="line">  obj.__proto__ = proto;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h2><p>Object.getPrototypeOf 方法可以用来从子类上获取父类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(Child) === Parent;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p>
<h2 id="Babel-编译"><a href="#Babel-编译" class="headerlink" title="Babel 编译"></a>Babel 编译</h2><p>先看这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name); <span class="comment">// 调用父类的 constructor(name)</span></span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">&quot;kevin&quot;</span>, <span class="string">&quot;18&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1);</span><br></pre></td></tr></table></figure>

<p><a href="https://babeljs.io/repl">Babel 编译</a>后为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_typeof</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="string">&quot;@babel/helpers - typeof&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">&quot;function&quot;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Symbol</span>.iterator === <span class="string">&quot;symbol&quot;</span>) &#123;</span><br><span class="line">    _typeof = <span class="function"><span class="keyword">function</span> <span class="title">_typeof</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">typeof</span> obj;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _typeof = <span class="function"><span class="keyword">function</span> <span class="title">_typeof</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> obj &amp;&amp;</span><br><span class="line">        <span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">&quot;function&quot;</span> &amp;&amp;</span><br><span class="line">        obj.constructor === <span class="built_in">Symbol</span> &amp;&amp;</span><br><span class="line">        obj !== <span class="built_in">Symbol</span>.prototype</span><br><span class="line">        ? <span class="string">&quot;symbol&quot;</span></span><br><span class="line">        : <span class="keyword">typeof</span> obj;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _typeof(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherits</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> superClass !== <span class="string">&quot;function&quot;</span> &amp;&amp; superClass !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Super expression must either be null or a function&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  subClass.prototype = <span class="built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123;</span><br><span class="line">    <span class="attr">constructor</span>: &#123; <span class="attr">value</span>: subClass, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (superClass) _setPrototypeOf(subClass, superClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_setPrototypeOf</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">  _setPrototypeOf =</span><br><span class="line">    <span class="built_in">Object</span>.setPrototypeOf ||</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_setPrototypeOf</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">      o.__proto__ = p;</span><br><span class="line">      <span class="keyword">return</span> o;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="keyword">return</span> _setPrototypeOf(o, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createSuper</span>(<span class="params">Derived</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> hasNativeReflectConstruct = _isNativeReflectConstruct();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">_createSuperInternal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Super = _getPrototypeOf(Derived),</span><br><span class="line">      result;</span><br><span class="line">    <span class="keyword">if</span> (hasNativeReflectConstruct) &#123;</span><br><span class="line">      <span class="keyword">var</span> NewTarget = _getPrototypeOf(<span class="built_in">this</span>).constructor;</span><br><span class="line">      result = <span class="built_in">Reflect</span>.construct(Super, <span class="built_in">arguments</span>, NewTarget);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = Super.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _possibleConstructorReturn(<span class="built_in">this</span>, result);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_possibleConstructorReturn</span>(<span class="params">self, call</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (call &amp;&amp; (_typeof(call) === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> call === <span class="string">&quot;function&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (call !== <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">      <span class="string">&quot;Derived constructors may only return object or undefined&quot;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _assertThisInitialized(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_assertThisInitialized</span>(<span class="params">self</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (self === <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(</span><br><span class="line">      <span class="string">&quot;this hasn&#x27;t been initialised - super() hasn&#x27;t been called&quot;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_isNativeReflectConstruct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Reflect</span> === <span class="string">&quot;undefined&quot;</span> || !<span class="built_in">Reflect</span>.construct) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Reflect</span>.construct.sham) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Proxy</span> === <span class="string">&quot;function&quot;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Boolean</span>.prototype.valueOf.call(</span><br><span class="line">      <span class="built_in">Reflect</span>.construct(<span class="built_in">Boolean</span>, [], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_getPrototypeOf</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  _getPrototypeOf = <span class="built_in">Object</span>.setPrototypeOf</span><br><span class="line">    ? <span class="built_in">Object</span>.getPrototypeOf</span><br><span class="line">    : <span class="function"><span class="keyword">function</span> <span class="title">_getPrototypeOf</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o.__proto__ || <span class="built_in">Object</span>.getPrototypeOf(o);</span><br><span class="line">      &#125;;</span><br><span class="line">  <span class="keyword">return</span> _getPrototypeOf(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_instanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    right != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">&quot;undefined&quot;</span> &amp;&amp;</span><br><span class="line">    right[<span class="built_in">Symbol</span>.hasInstance]</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> !!right[<span class="built_in">Symbol</span>.hasInstance](left);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> left <span class="keyword">instanceof</span> right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!_instanceof(instance, Constructor)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Cannot call a class as a function&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Parent = <span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  _classCallCheck(<span class="built_in">this</span>, Parent);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Child = <span class="comment">/*#__PURE__*/</span> (<span class="function"><span class="keyword">function</span> (<span class="params">_Parent</span>) </span>&#123;</span><br><span class="line">  _inherits(Child, _Parent);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> _super = _createSuper(Child);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this;</span><br><span class="line"></span><br><span class="line">    _classCallCheck(<span class="built_in">this</span>, Child);</span><br><span class="line"></span><br><span class="line">    _this = _super.call(<span class="built_in">this</span>, name); <span class="comment">// 调用父类的 constructor(name)</span></span><br><span class="line"></span><br><span class="line">    _this.age = age;</span><br><span class="line">    <span class="keyword">return</span> _this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Child;</span><br><span class="line">&#125;)(Parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">&quot;kevin&quot;</span>, <span class="string">&quot;18&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child1);</span><br></pre></td></tr></table></figure>

<h3 id="inherits"><a href="#inherits" class="headerlink" title="_inherits"></a>_inherits</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherits</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// extend 的继承目标必须是函数或者是 null</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> superClass !== <span class="string">&quot;function&quot;</span> &amp;&amp; superClass !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Super expression must either be null or a function&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 类似于 ES5 的寄生组合式继承，使用 Object.create，设置子类 prototype 属性的 __proto__ 属性指向父类的 prototype 属性</span></span><br><span class="line">  subClass.prototype = <span class="built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123;</span><br><span class="line">    <span class="attr">constructor</span>: &#123;</span><br><span class="line">      <span class="attr">value</span>: subClass,</span><br><span class="line">      <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 设置子类的 __proto__ 属性指向父类</span></span><br><span class="line">  <span class="keyword">if</span> (superClass) _setPrototypeOf(subClass, superClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="createSuper"><a href="#createSuper" class="headerlink" title="_createSuper"></a>_createSuper</h3><p>函数里返回一个_possibleConstructorReturn 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">_createSuper(Child);</span><br><span class="line"><span class="comment">// 可以简化为:</span></span><br><span class="line">_possibleConstructorReturn(<span class="built_in">this</span>, Parent.call(<span class="built_in">this</span>, name));</span><br><span class="line"><span class="comment">// 也就是说_this = _super.call(this, name);可以替换为：</span></span><br><span class="line">_this = _possibleConstructorReturn(<span class="built_in">this</span>, Parent.call(<span class="built_in">this</span>, name));</span><br></pre></td></tr></table></figure>

<p>_possibleConstructorReturn 的源码为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_possibleConstructorReturn</span>(<span class="params">self, call</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (call &amp;&amp; (_typeof(call) === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> call === <span class="string">&quot;function&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (call !== <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">      <span class="string">&quot;Derived constructors may only return object or undefined&quot;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _assertThisInitialized(self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里我们判断 Parent.call(this, name) 的返回值的类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回值： undefined</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.xxx = xxx;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回值：Object</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;kevin&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回值：null</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以对于 Parent.call(this) 的值，如果是 object 类型或者是 function 类型，就返回 Parent.call(this)，如果是 null 或者基本类型的值或者是 undefined，都会返回 self 也就是子类的 this。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后总体看下如何实现继承：<br>首先执行 _inherits(Child, Parent)，建立 Child 和 Parent 的原型链关系，即 Object.setPrototypeOf(Child.prototype, Parent.prototype) 和 Object.setPrototypeOf(Child, Parent)。</p>
<p>然后调用 Parent.call(this, name)，根据 Parent 构造函数的返回值类型确定子类构造函数 this 的初始值 _this。</p>
<p>最终，根据子类构造函数，修改 _this 的值，然后返回该值。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/106">https://github.com/mqyqingfeng/Blog/issues/106</a></li>
<li><a href="https://es6.ruanyifeng.com/#docs/class-extends">https://es6.ruanyifeng.com/#docs/class-extends</a></li>
</ul>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Es6</tag>
      </tags>
  </entry>
  <entry>
    <title>一、ES6系列之let和const</title>
    <url>/2020/04/08/es6/let%E5%92%8Cconst/</url>
    <content><![CDATA[<p>在 ES6 以前，JS 只有 var 一种声明方式，但是在 ES6 之后，就多了 let 跟 const 这两种方式。用 var 定义的变量没有块级作用域的概念，而 let 跟 const 则会有，因为这三个关键字创建是不一样的。</p>
<span id="more"></span>

<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>通过 var 声明的变量存在变量提升的特性，let 和 const 声明的变量不存在变量提升。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> carName = <span class="string">&quot;BMW&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(carName); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> personName = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(personName); <span class="comment">// Uncaught ReferenceError: personName is not defined</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dogName = <span class="string">&quot;Angle&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(dogName); <span class="comment">// Uncaught ReferenceError: dogName is not defined</span></span><br></pre></td></tr></table></figure>

<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>当在全局作用域中使用 var 声明的时候，会创建一个新的全局变量作为全局对象的属性，而 let 和 const 不会。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> carName = <span class="string">&quot;BMW&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.carName); <span class="comment">// BMW</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> personName = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.personName); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">const</span> dogName = <span class="string">&quot;Angle&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.dogName); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="重复声明"><a href="#重复声明" class="headerlink" title="重复声明"></a>重复声明</h2><p>var 可以重复声明，而 let 和 const 不能。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> carName = <span class="string">&quot;BMW&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> carName = <span class="string">&quot;BMW2&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> carName = <span class="string">&quot;BMW3&quot;</span>; <span class="comment">//Uncaught SyntaxError: Identifier &#x27;carName&#x27; has already been declared</span></span><br><span class="line"><span class="keyword">const</span> carName = <span class="string">&quot;BMW4&quot;</span>; <span class="comment">//Uncaught SyntaxError: Identifier &#x27;carName&#x27; has already been declared</span></span><br></pre></td></tr></table></figure>

<h2 id="重新赋值"><a href="#重新赋值" class="headerlink" title="重新赋值"></a>重新赋值</h2><p>var 和 let 可以重新赋值，const 不行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> carName = <span class="string">&quot;BMW&quot;</span>;</span><br><span class="line">carName = <span class="string">&quot;BB&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> personName = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">personName = <span class="string">&quot;Jay&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> dogName = <span class="string">&quot;Angle&quot;</span>;</span><br><span class="line">dogName = <span class="string">&quot;Come&quot;</span>; <span class="comment">// Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>

<h2 id="暂时死区"><a href="#暂时死区" class="headerlink" title="暂时死区"></a>暂时死区</h2><p>暂时死区(Temporal Dead Zone)，简写为 TDZ。<br>let 和 const 声明的变量不会被提升到作用域顶部，如果在声明之前访问这些变量，会导致报错：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> value); <span class="comment">// Uncaught ReferenceError: value is not defined</span></span><br><span class="line"><span class="keyword">let</span> value = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这是因为 JavaScript 引擎在扫描代码发现变量声明时，要么将它们提升到作用域顶部(遇到 var 声明)，要么将声明放在 TDZ 中(遇到 let 和 const 声明)。访问 TDZ 中的变量会触发运行时错误。只有执行过变量声明语句后，变量才会从 TDZ 中移出，然后方可访问。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="string">&quot;global&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> value = <span class="string">&quot;local&quot;</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子2</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> value = <span class="string">&quot;local&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个例子中，结果并不会打印 “global”，而是报错 Uncaught ReferenceError: value is not defined，就是因为 TDZ 的缘故。</p>
<h2 id="只声明不初始化"><a href="#只声明不初始化" class="headerlink" title="只声明不初始化"></a>只声明不初始化</h2><p>在 ES6 中，const 定义的变量是必须要初始化赋值，而且以后不能变更, 是一个固定值。而像 var，let 是可以只声明，但是不进行初始化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">let</span> b;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// =&gt; undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// =&gt; undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c; <span class="comment">// Uncaught SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure>

<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>在 ES6 之前，是没有块级作用域的概念的，为了加强对变量生命周期的控制，ECMAScript 6 引入了块级作用域。<br>块级作用域存在于：</p>
<ul>
<li>函数内部</li>
<li>块中(字符 { 和 } 之间的区域)</li>
</ul>
<p>块级声明用于声明在指定块的作用域之外无法访问的变量，let 和 const 都是块级声明的一种。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(y); <span class="comment">// Uncaught ReferenceError: y is not defined</span></span><br></pre></td></tr></table></figure>

<h3 id="循环中的块级作用域"><a href="#循环中的块级作用域" class="headerlink" title="循环中的块级作用域"></a>循环中的块级作用域</h3><p>下面看一个常见的面试题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  funcs[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(funcs[<span class="number">0</span>]()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// funcs[i] = (function (i) &#123;</span></span><br><span class="line">  <span class="comment">//   return function () &#123;</span></span><br><span class="line">  <span class="comment">//     console.log(i);</span></span><br><span class="line">  <span class="comment">//   &#125;;</span></span><br><span class="line">  <span class="comment">// &#125;)(i);</span></span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">    funcs[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(funcs[<span class="number">0</span>]()); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>Es6 解决方案</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  funcs[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(funcs[<span class="number">0</span>]()); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>let 声明的变量只在 for 的循环体中有效，循环结束后 变量就消失了， 同时 const 也可以在 for 循环中声明变量，但是不能用于 常规的 for 循环中。所谓的常规 for 循环就是 for(let i =0; i &lt; 3; i++) 的格式，否则会报错。</p>
<p>在使用 for 循环的时候，每一次的迭代都会重新声明一个变量。像 for(let i = 0; i &lt; 3; i++); 这样使用时，i 变量声明了 3 次，只不过每一次迭代给 i 赋值不一样而已，并且变量只在循环体中使用。 我们可以这样理解： 第一次迭代的使用，声明了一个变量 i， 赋值为 0， 0 &lt; 3, 然后执行循环体，执行完之后 i++ 变成了 1. 这一次迭代就结束了，这个 i 的使命就完成了。然后进行第二次迭代，这时重新声明一个变量 i, 不过这次给他赋值为 1，1 &lt; 3 继续执行循环体，然后加 1. 这次迭代又结束了，这个 i 也完成了使命，消失了。第三次迭代进行同样的操作，声明一个全新的变量 i，执行循环体之类的，直达整个循环结束。</p>
<p>所以对于 for 循环来说了，<strong>每次迭代循环时都创建一个新变量，并以之前迭代中同名变量的值将其初始化。</strong>，这样对于这一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  funcs[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">funcs[<span class="number">0</span>](); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>相当于：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line">(<span class="keyword">let</span> i = <span class="number">0</span>) &#123;</span><br><span class="line">    funcs[<span class="number">0</span>] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">let</span> i = <span class="number">1</span>) &#123;</span><br><span class="line">    funcs[<span class="number">1</span>] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">let</span> i = <span class="number">2</span>) &#123;</span><br><span class="line">    funcs[<span class="number">2</span>] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当执行函数的时候，根据词法作用域就可以找到正确的值，其实你也可以理解为 let 声明模仿了闭包的做法来简化循环过程。</p>
<p>除了常规的 for 循环之外，还有 for-in 和 for-of 操作， 原理都是一样的，他们每一次的迭代都是重新声明一个全新的迭代对象，而不是给原来声明的迭代对象赋新值, 循环体内获取到的都是当前迭代对象的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> funcs = [];</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// for-in 循环, 数组是不建议使用for-in ,这里只是简单的演示</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  funcs.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</span><br><span class="line">  func(); <span class="comment">// 输出0， 1， 2</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用for-of</span></span><br><span class="line">funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  funcs.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</span><br><span class="line">  func(); <span class="comment">// 输出1， 2，3</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>现在看一下 const, const 也可以使用在 for 循环中。最简单的就是把上面的三个 for 循环中的 let 都转换为 const. for (const i = 0; i &lt; 3; i++) {}; for (const key of arr) {} , for (const key in arr) {} . 这时你会发现第一种常规 for 循环报错了。看一下第一次迭代就知道了。声明了一个 变量 i， 赋值为 0。 但这里使用 const， 也就意味着 i 在声明之后，就不能再改变了。好了，0 &lt; 3, 执行循环体，然后 加 1，报错了，i 不能变化了。一次迭代都没有走完，就报错了，说明，在使用常规 for 循环时， const 不能用来声明变量。</p>
<p>再来看一下，for-of, for-in, 没有问题，因为每一次的迭代都会声明一个全新的 key， 所有的赋值都是给一个新的变量赋值，而没有改变原来的值。那使用 let 和 const 有什么区别吗？ 当然有了，还是在于 const 声明的变量不能重新赋值了，所以如果 for-in 或 for- of 中使用 const 声明了变量（ 如 key）， 循环体中，就不能给 key 赋新值了，如果使用 let ,那就无所谓了，想干什么就干什么。只不过 for-in 或 for-of 中，我们很少改变 key 值，所以他们在实际使用时就没有什么区别了。</p>
<h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>在 Babel 中是如何编译 let 和 const 的呢？我们来看看编译后的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>编译为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>我们可以看到 Babel 直接将 let 编译成了 var，如果是这样的话，那么我们来写个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">// Uncaught ReferenceError: value is not defined</span></span><br></pre></td></tr></table></figure>

<p>如果还是直接编译成 var，打印的结果肯定是 undefined，然而 Babel 很聪明，它编译成了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> _value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(value);</span><br></pre></td></tr></table></figure>

<p>我们再写个直观的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">value = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> _value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">value = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>本质是一样的，就是改变量名，使内外层的变量名称不一样。</p>
<p>那像 const 的修改值时报错，以及重复声明报错怎么实现的呢？</p>
<p>其实就是在编译的时候直接给你报错……</p>
<p>那循环中的 let 声明呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  funcs[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">funcs[<span class="number">0</span>](); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>Babel 巧妙的编译成了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _loop = <span class="function"><span class="keyword">function</span> <span class="title">_loop</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  funcs[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  _loop(i);</span><br><span class="line">&#125;</span><br><span class="line">funcs[<span class="number">0</span>](); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后用一个图表来展示他们之间的区别：</p>
<table>
<thead>
<tr>
<th></th>
<th>var</th>
<th>let</th>
<th>const</th>
</tr>
</thead>
<tbody><tr>
<td>变量提升</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>全局变量</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>重复声明</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>重新赋值</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>暂时死区</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>只声明不初始化</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>块作用域</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/82">https://github.com/mqyqingfeng/Blog/issues/82</a></li>
<li><a href="https://www.cnblogs.com/SamWeb/p/10659352.html">https://www.cnblogs.com/SamWeb/p/10659352.html</a></li>
</ul>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Es6</tag>
      </tags>
  </entry>
  <entry>
    <title>八、ES6系列之Generator</title>
    <url>/2020/05/02/es6/%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<p>前面我们介绍过 Iterator(迭代器)，本文主要了解 Generator (生成器)函数。<br>生成器是一种返回迭代器的函数，通过 function 关键字后的星号(*)来表示，函数中会用到新的关键字 yield。</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">createIterator</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; item.length; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> item[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = createIterator([<span class="number">10</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]); <span class="comment">// 生成器函数执行返回一个新的迭代器实例it</span></span><br><span class="line"><span class="comment">// 调用迭代器it的next()方法</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">//&#123;value: 10, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">//&#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">//&#123;value: 4, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">//&#123;value: 5, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">//&#123;value: 6, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">//&#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>或者使用 for…of 方法统一遍历</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v <span class="keyword">of</span> it) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v); <span class="comment">// 10  2  4  5  6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上例可以看到，使用了 ES6 的生成器，明显简化迭代器的创建过程，给生成器函数 createIterator()传入一个 item 数组，函数内部，for 循环不断从数组中生成新的元素放入迭代器中，每遇到一个 yield 语句循环都会停止；每次调用迭代器的 next()方法，循环便继续运行并停止在下一条 yield 语句处。</p>
<p>生成器函数 createIterator()执行后创建的迭代器赋值给变量 it，变量 it 就作为这个迭代器的引用。既可以通过手工调用 next()方法来执行迭代过程，也可以使用 for..of..来完成迭代过程。</p>
<h2 id="生成器的种类"><a href="#生成器的种类" class="headerlink" title="生成器的种类"></a>生成器的种类</h2><p>一般分类四种：</p>
<ol>
<li>生成器函数声明：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">genFunc</span>(<span class="params"></span>) </span>&#123; ··· &#125;</span><br><span class="line"><span class="keyword">const</span> genObj = genFunc();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>生成器函数表达式：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> genFunc = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123; ··· &#125;;</span><br><span class="line"><span class="keyword">const</span> genObj = genFunc();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>对象字面量中的生成器方法定义：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    * <span class="function"><span class="title">generatorMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> genObj = obj.generatorMethod();</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>类定义中的生成器方法定义（类声明或类表达式）：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    * <span class="function"><span class="title">generatorMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> myInst = <span class="keyword">new</span> MyClass();</span><br><span class="line"><span class="keyword">const</span> genObj = myInst.generatorMethod();</span><br></pre></td></tr></table></figure>

<h2 id="next-方法的传参"><a href="#next-方法的传参" class="headerlink" title="next 方法的传参"></a>next 方法的传参</h2><p>在生成器函数内部使用 yield 关键字暂停，yield 表达式本身没有返回值，或者说总是返回 undefined。在该函数执行返回的迭代器上调用 next()获得暂停时的返回值。其实 next()方法可以接收参数，这个参数的值会代替生成器内部上一条 yield 语句的返回值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> first = <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> second = <span class="keyword">yield</span> first * <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> second + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建迭代器实例</span></span><br><span class="line"><span class="keyword">var</span> it = createIterator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动迭代器</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">it.next(<span class="number">4</span>); <span class="comment">// &#123;value: 12, done: false&#125;</span></span><br><span class="line">it.next(<span class="number">7</span>); <span class="comment">// &#123;value: 10, done: false&#125;</span></span><br><span class="line">it.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过 next 方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p>
<h2 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a>Generator.prototype.throw()</h2><p>throw 方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;内部捕获&quot;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = g();</span><br><span class="line">i.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  i.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">  i.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;外部捕获&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内部捕获 Error: a</span></span><br><span class="line"><span class="comment">// 外部捕获 Error: b</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，遍历器对象 i 连续抛出两个错误。第一个错误被 Generator 函数体内的 catch 语句捕获。i 第二次抛出错误，由于 Generator 函数内部的 catch 语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的 catch 语句捕获</p>
<h2 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a>Generator.prototype.return()</h2><p>return()方法，可以返回给定的值，并且终结遍历 Generator 函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">createIterator</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; item.length; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> item[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = createIterator([<span class="number">10</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">//&#123;value: 10, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.return(<span class="string">&quot;over!&quot;</span>)); <span class="comment">//&#123;value: &#x27;over!&#x27;, done: true&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">//&#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，遍历器对象 it 调用 return()方法后，返回值的 value 属性就是 return()方法的参数。并且，Generator 函数的遍历就终止了，返回值的 done 属性为 true，以后再调用 next()方法，done 属性总是返回 true。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后总结下，生成器是创建迭代器的函数，生成器函数内部有 yield 关键字来提供暂停接口，作为创建的迭代器调用 next()方法执行的节点。生成器函数与普通函数的区别是前者在 function 关键字后有星号(*)，并且生成器函数执行后会创建一个新的迭代器实例，其他则和普通函数一样，可以传参和返回值。迭代器的 next()方法可以传入参数，传入的参数值将会代替迭代器内上一条 yield 语句的返回值。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://es6.ruanyifeng.com/#docs/generator">https://es6.ruanyifeng.com/#docs/generator</a></li>
</ul>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Es6</tag>
      </tags>
  </entry>
  <entry>
    <title>六、ES6系列之Iterator 和 for...of 循环</title>
    <url>/2020/04/22/es6/%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>首先定义一个数组：</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = [</span><br><span class="line">  <span class="string">&quot;Li Lei&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Han Meimei&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Jery&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Stephen&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Li bai&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Du fu&quot;</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>在某些时候，您会想要取回数组中的所有单个值，以便将它们打印在屏幕上、操作它们或对它们执行某些操作。如果我问你，你会怎么做？你会说——这很容易。我就对他们循环中使用 for，while，for-of 或一个这些循环的方法。示例实现是:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// For loop</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; person.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(person[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// while loop</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; person.length) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(person[i]);</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// For-of loop</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> person) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，假设有一个自定义数据结构来保存所有 person，而不是之前的数组。像这样:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">subject</span>: &#123;</span><br><span class="line">    <span class="attr">english</span>: [<span class="string">&quot;Li Lei&quot;</span>, <span class="string">&quot;Han Meimei&quot;</span>],</span><br><span class="line">    <span class="attr">math</span>: [<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Jery&quot;</span>, <span class="string">&quot;Stephen&quot;</span>],</span><br><span class="line">    <span class="attr">chinese</span>: [<span class="string">&quot;Li bai&quot;</span>, <span class="string">&quot;Du fu&quot;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在，person 是一个包含另一个对象的对象 subject。subject 包含三个阵列，按键 english，math 和 chinese。现在，如果要获取 person 所有人员，我们尝试一些循环组合来获取所有数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> person) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught TypeError: person is not iterable</span></span><br></pre></td></tr></table></figure>

<p>得到一个 TypeError 说法，该对象不可迭代。那么这是为什么呢，下面我们看看什么是可迭代对象以及如何使对象可迭代。</p>
<h2 id="Iterator（迭代器）"><a href="#Iterator（迭代器）" class="headerlink" title="Iterator（迭代器）"></a>Iterator（迭代器）</h2><p>所谓迭代器，其实就是一个具有 next() 方法的对象，每次调用 next() 都会返回一个结果对象，该结果对象有两个属性，value 表示当前的值，done 表示遍历是否结束。<br>来看我们上一节中的问题，我们想要某种方法，通过它我们可以拿到所有内部数据。<br>让我们在 person 对象中添加一个方法 getAllPerson，来返回返回所有作者。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">subject</span>: &#123;</span><br><span class="line">    <span class="attr">english</span>: [<span class="string">&quot;Li Lei&quot;</span>, <span class="string">&quot;Han Meimei&quot;</span>],</span><br><span class="line">    <span class="attr">math</span>: [<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Jery&quot;</span>, <span class="string">&quot;Stephen&quot;</span>],</span><br><span class="line">    <span class="attr">chinese</span>: [<span class="string">&quot;Li bai&quot;</span>, <span class="string">&quot;Du fu&quot;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">getAllPerson</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> all = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">of</span> <span class="built_in">this</span>.subject.english) &#123;</span><br><span class="line">      all.push(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">of</span> <span class="built_in">this</span>.subject.math) &#123;</span><br><span class="line">      all.push(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">of</span> <span class="built_in">this</span>.subject.math) &#123;</span><br><span class="line">      all.push(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> all;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在我们通过一个简单的方法拿到所用人员的名字；但是，这种实现可能会出现一些问题。比如：</p>
<ul>
<li>getAllPerson 是一个具体的名字，不同的开发者会有自己的命名习惯，比如 retrieveAllPerson;</li>
<li>作为开发人员，我们总是需要知道返回所有数据的特定方法。 在本例中，它被命名为 getAllPerson。</li>
<li>getAllPerson 返回类型是固定的字符串数组。</li>
</ul>
<p>开发人员必须知道返回所有数据的方法的<strong>确切名称</strong>和<strong>返回类型</strong>。<br>如果我们制定一个规则，即方法的名称及其返回类型 将是固定的且不可更改的。<br>我们将此方法命名为 <strong>iteratorMethod</strong>。</p>
<p><a href="https://en.wikipedia.org/wiki/Ecma_International">ECMA</a>采取了类似的步骤 来标准化这个循环自定义对象的过程。但是，ECMA 没有使用 iteratorMethod 作为 方法的名称 ，而是使用 Symbol.iterator。Symbol 类型可以提供唯一且不会与其他属性名称冲突的名称。此外，Symbol.iterator 将返回一个迭代器对象。该迭代器将调用一个方法 <strong>next</strong> ，它将返回一个带有键 value 和 done 的对象。</p>
<p>图表可能有助于理解可迭代对象、迭代器和下一个之间的关系。这种关系称为迭代协议。</p>
<p><img src="/images/iterator.png" alt="(迭代协议)"></p>
<p>在<a href="https://exploringjs.com/es6/ch_iteration.html">Exploring JS</a>一书中有这样一段介绍：</p>
<ul>
<li>一个迭代是想让它的元素向公众开放的数据结构。它通过实现一个键为 的方法来实现 Symbol.iterator。该方法是迭代器的工厂。也就是说，它将创建迭代器。</li>
<li>一个迭代器是用于遍历数据结构的元素的指针。</li>
</ul>
<h2 id="使-object-可迭代"><a href="#使-object-可迭代" class="headerlink" title="使 object 可迭代"></a>使 object 可迭代</h2><p>因此，正如我们在上一节中学到的，我们需要实现一个名为 Symbol.iterator 的方法 。来创建一个迭代器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> done = i &gt;= items.length;</span><br><span class="line">      <span class="keyword">var</span> value = !done ? items[i++] : <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">done</span>: done,</span><br><span class="line">        <span class="attr">value</span>: value,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterator 就是一个迭代器对象</span></span><br><span class="line"><span class="keyword">var</span> iterator = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; done: false, value: 1 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; done: false, value: 2 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; done: false, value: 3 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="For-of"><a href="#For-of" class="headerlink" title="For-of"></a>For-of</h2><p>除了迭代器之外，我们还需要一个可以遍历迭代器对象的方式，ES6 提供了 for of 语句，我们直接用 for of 遍历一下我们上节生成的遍历器对象试试：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iterator = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> iterator) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果报错 TypeError: iterator is not iterable，表明我们生成的 iterator 对象并不是 iterable(可遍历的)。<br>那什么才是可遍历的呢？</p>
<p>其实一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。</p>
<p>ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性，或者说，一个数据结构只要具有 Symbol.iterator 属性，就可以认为是”可遍历的”（iterable）。</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (value <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 1 2 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此，我们也可以发现 for of 遍历的其实是对象的 Symbol.iterator 属性。</p>
<h2 id="默认可遍历对象"><a href="#默认可遍历对象" class="headerlink" title="默认可遍历对象"></a>默认可遍历对象</h2><p>很多东西在 JavaScript 中都是可迭代的。这是因为 ES6 默认部署了 Symbol.iterator 属性。</p>
<h3 id="数组和类数组"><a href="#数组和类数组" class="headerlink" title="数组和类数组"></a>数组和类数组</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>]) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a b</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>遍历每个字符或 Unicode 编码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> <span class="string">&quot;a\uD83D\uDC0A&quot;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// 🐊 (crocodile emoji)</span></span><br></pre></td></tr></table></figure>

<h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><p>遍历其键值对</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>).set(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> pair <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, 1]</span></span><br><span class="line"><span class="comment">// [&#x27;b&#x27;, 2]</span></span><br></pre></td></tr></table></figure>

<h2 id="Sets-元素"><a href="#Sets-元素" class="headerlink" title="Sets 元素"></a>Sets 元素</h2><p>遍历其键值对</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="string">&quot;a&quot;</span>).add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> set) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="使-person-可迭代"><a href="#使-person-可迭代" class="headerlink" title="使 person 可迭代"></a>使 person 可迭代</h2><p>最后我们来看文章开头的示例，使其实现可迭代。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">subject</span>: &#123;</span><br><span class="line">    <span class="attr">english</span>: [<span class="string">&quot;Li Lei&quot;</span>, <span class="string">&quot;Han Meimei&quot;</span>],</span><br><span class="line">    <span class="attr">math</span>: [<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Jery&quot;</span>, <span class="string">&quot;Stephen&quot;</span>],</span><br><span class="line">    <span class="attr">chinese</span>: [<span class="string">&quot;Li bai&quot;</span>, <span class="string">&quot;Du fu&quot;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="comment">// 获取所有名字</span></span><br><span class="line">    <span class="keyword">const</span> allName = <span class="built_in">Object</span>.values(<span class="built_in">this</span>.subject);</span><br><span class="line">    <span class="keyword">let</span> currentIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当前学科</span></span><br><span class="line">    <span class="keyword">let</span> currentSubjectIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> authors = allName[currentSubjectIndex];</span><br><span class="line">        <span class="comment">// 判断是否还有更多人</span></span><br><span class="line">        <span class="keyword">const</span> doNothaveMorePerson = !(currentIndex &lt; authors.length);</span><br><span class="line">        <span class="keyword">if</span> (doNothaveMorePerson) &#123;</span><br><span class="line">          <span class="comment">// 当前数组没有更多人</span></span><br><span class="line">          currentSubjectIndex++;</span><br><span class="line">          <span class="comment">// 重置</span></span><br><span class="line">          currentIndex = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否还有更多学科</span></span><br><span class="line">        <span class="keyword">const</span> doNotHaveMoresubject = !(currentSubjectIndex &lt; allName.length);</span><br><span class="line">        <span class="keyword">if</span> (doNotHaveMoresubject) &#123;</span><br><span class="line">          <span class="comment">// 没有更多学科</span></span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">value</span>: <span class="literal">undefined</span>,</span><br><span class="line">            <span class="attr">done</span>: <span class="literal">true</span>,</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">value</span>: allName[currentSubjectIndex][currentIndex++],</span><br><span class="line">          <span class="attr">done</span>: <span class="literal">false</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> author <span class="keyword">of</span> person) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(author);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后总结下，迭代器是可迭代对象，具有 Symbol.iterator 方法和 next()方法，可以通过 for..of 代替普通 for 循环来迭代，省去循环引用变量，简化了循环过程。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://codeburst.io/a-simple-guide-to-es6-iterators-in-javascript-with-examples-189d052c3d8e">https://codeburst.io/a-simple-guide-to-es6-iterators-in-javascript-with-examples-189d052c3d8e</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/90">https://github.com/mqyqingfeng/Blog/issues/90</a></li>
</ul>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Es6</tag>
      </tags>
  </entry>
  <entry>
    <title>二、ES6系列之模板字符串</title>
    <url>/2020/04/10/es6/%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>模板字面量 是允许嵌入表达式的字符串字面量。你可以使用多行字符串和字符串插值功能。它们在 ES2015 规范的先前版本中被称为“模板字符串”。</p>
<span id="more"></span>

<h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p>模板字符串使用反引号 (<code> </code>) 来代替普通字符串中的用双引号和单引号；模板字符串可以包含特定语法（${expression}）的占位符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">`Hello World`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message);</span><br></pre></td></tr></table></figure>

<p>在模版字符串内使用反引号（`）时，需要在它前面加转义符（\）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">`Hello \` World`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message);</span><br></pre></td></tr></table></figure>

<h2 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h2><p>在新行中插入的任何字符都是模板字符串中的一部分，使用普通字符串，你可以通过以下的方式获得多行字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;Hello World, \nThis is the second line&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message);</span><br></pre></td></tr></table></figure>

<p>在模板字符串中，空格、缩进、换行都会被保留，用模板字符串实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">`Hello World,</span></span><br><span class="line"><span class="string">This is the second line`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message);</span><br></pre></td></tr></table></figure>

<h2 id="嵌套变量"><a href="#嵌套变量" class="headerlink" title="嵌套变量"></a>嵌套变量</h2><p>模板字符串支持嵌入变量，只需要将变量名写在 ${} 之中，其实不止变量，任意的 JavaScript 表达式都是可以的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Fifteen is &quot;</span> + (a + b) + <span class="string">&quot; and not &quot;</span> + (<span class="number">2</span> * a + b) + <span class="string">&quot;.&quot;</span>);</span><br><span class="line"><span class="comment">// Fifteen is 15 and not 20.</span></span><br></pre></td></tr></table></figure>

<p>值得一提的是，模板字符串支持嵌套:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [&#123; <span class="attr">value</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">value</span>: <span class="number">2</span> &#125;];</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;arr.map((item) =&gt; &#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">    <span class="keyword">return</span> <span class="string">`</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">      &lt;li&gt;<span class="subst">$&#123;item.value&#125;</span>&lt;/li&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    `</span>;</span></span></span><br><span class="line"><span class="subst"><span class="string">  &#125;)&#125;</span></span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  ,</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的”,”是因为 map 后生成的数组转字符串导致的，比如一个数组 [1, 2, 3] 就会被转为 1,2,3；所以我们用 jion 处理它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [&#123; <span class="attr">value</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">value</span>: <span class="number">2</span> &#125;];</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string"> <span class="subst">$&#123;arr</span></span></span><br><span class="line"><span class="subst"><span class="string">   .map((item) =&gt; &#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">     <span class="keyword">return</span> <span class="string">`</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">     &lt;li&gt;<span class="subst">$&#123;item.value&#125;</span>&lt;/li&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">   `</span>;</span></span></span><br><span class="line"><span class="subst"><span class="string">   &#125;)</span></span></span><br><span class="line"><span class="subst"><span class="string">   .join(<span class="string">&quot;&quot;</span>)&#125;</span></span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="带标签的模板字符串"><a href="#带标签的模板字符串" class="headerlink" title="带标签的模板字符串"></a>带标签的模板字符串</h2><p>更高级的形式的模板字符串是带标签的模板字符串。标签使您可以用函数解析模板字符串。标签函数的第一个参数包含一个字符串值的数组。其余的参数与表达式相关。最后，你的函数可以返回处理好的的字符串（或者它可以返回完全不同的东西 , 如下个例子所述）。用于该标签的函数的名称可以被命名为任何名字。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="string">&quot;Mike&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">28</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTag</span>(<span class="params">strings, ...values</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(strings); <span class="comment">// [&quot;that &quot;, &quot; is a &quot;, &quot;&quot;]</span></span><br><span class="line">  <span class="built_in">console</span>.log(values); <span class="comment">// [&#x27;Mike&#x27;, 28]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拼接字符串</span></span><br><span class="line">  <span class="keyword">let</span> result = strings.reduce(<span class="function">(<span class="params">prev, next, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = values[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> prev + value + next;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> output = myTag<span class="string">`that <span class="subst">$&#123;person&#125;</span> is a <span class="subst">$&#123;age&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(output);</span><br><span class="line"><span class="comment">// that Mike is a 28</span></span><br></pre></td></tr></table></figure>

<p>当然标签函数并不一定需要返回一个字符串，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">template</span>(<span class="params">strings, ...keys</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dict = values[values.length - <span class="number">1</span>] || &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> result = [strings[<span class="number">0</span>]];</span><br><span class="line">    keys.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">key, i</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> value = <span class="built_in">Number</span>.isInteger(key) ? values[key] : dict[key];</span><br><span class="line">      result.push(value, strings[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t1Closure = template<span class="string">`<span class="subst">$&#123;<span class="number">0</span>&#125;</span><span class="subst">$&#123;<span class="number">1</span>&#125;</span><span class="subst">$&#123;<span class="number">0</span>&#125;</span>!`</span>;</span><br><span class="line">t1Closure(<span class="string">&quot;Y&quot;</span>, <span class="string">&quot;A&quot;</span>); <span class="comment">// &quot;YAY!&quot;</span></span><br><span class="line"><span class="keyword">var</span> t2Closure = template<span class="string">`<span class="subst">$&#123;<span class="number">0</span>&#125;</span> <span class="subst">$&#123;<span class="string">&quot;foo&quot;</span>&#125;</span>!`</span>;</span><br><span class="line">t2Closure(<span class="string">&quot;Hello&quot;</span>, &#123; <span class="attr">foo</span>: <span class="string">&quot;World&quot;</span> &#125;); <span class="comment">// &quot;Hello World!&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h2><p>在标签函数的第一个参数中，存在一个特殊的属性 raw ，我们可以通过它来访问模板字符串的原始字符串，而不经过特殊字符的替换。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strings</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(strings.raw);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`string text line 1 \n string text line 2`</span>;</span><br><span class="line"><span class="comment">// 输出（包含两个\）：</span></span><br><span class="line"><span class="comment">// [&quot;string text line 1 \\n string text line 2&quot;]</span></span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/orphaned/Web/JavaScript/Reference/Template_literals">https://developer.mozilla.org/zh-CN/docs/orphaned/Web/JavaScript/Reference/Template_literals</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/82">https://github.com/mqyqingfeng/Blog/issues/82</a></li>
</ul>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Es6</tag>
      </tags>
  </entry>
  <entry>
    <title>三、ES6系列之箭头函数</title>
    <url>/2020/04/14/es6/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>ES6 增加了箭头函数，箭头函数表达式的语法比函数表达式更简洁，并且没有自己的 <strong>this</strong>，<strong>arguments</strong>，<strong>super</strong> 或 <strong>new.target</strong>。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</p>
<span id="more"></span>

<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function">(<span class="params">value, label</span>) =&gt;</span> &#123;</span><br><span class="line">  value, label;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params">value, label</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; value, label &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="高级语法"><a href="#高级语法" class="headerlink" title="高级语法"></a>高级语法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加括号的函数体返回对象字面量表达式：</span></span><br><span class="line">params =&gt; (&#123;<span class="attr">foo</span>: bar&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持剩余参数和默认参数</span></span><br><span class="line">(param1, param2, ...rest) =&gt; &#123; statements &#125;</span><br><span class="line">(param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; &#123;</span><br><span class="line">statements &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同样支持参数列表解构</span></span><br><span class="line"><span class="keyword">let</span> f = <span class="function">(<span class="params">[a, b] = [<span class="number">1</span>, <span class="number">2</span>], &#123;x: c&#125; = &#123;x: a + b&#125;</span>) =&gt;</span> a + b + c;</span><br><span class="line">f();  <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<h2 id="没有-this"><a href="#没有-this" class="headerlink" title="没有 this"></a>没有 this</h2><p>箭头函数没有 this，所以需要通过查找作用域链来确定 this 的值。<br>this 的绑定一直是一个比较头疼的问题，请看下面的列子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.age = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">ageUp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.age++;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>上面这个例子中 <strong>p.age</strong> 的值一直都是 0，增加的是全局中 age 的值，因为函数 ageUp 中的 this 指向全局 window ，在 ECMAScript 3/5 中，通过将 this 值分配给封闭的变量，可以解决 this 问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="built_in">this</span>;</span><br><span class="line">  _this.age = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">ageUp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    _this.age++;</span><br><span class="line">    <span class="built_in">console</span>.log(_this); <span class="comment">// 实例p</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>或者，可以创建绑定函数，以便将预先分配的 this 值传递到绑定的目标函数（上述示例中的 growUp()函数）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.age = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ageUp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.age++;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// 实例p</span></span><br><span class="line">    &#125;.bind(<span class="built_in">this</span>),</span><br><span class="line">    <span class="number">1000</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>箭头函数不会创建自己的 this,它只会从自己的作用域链的上一层继承 this。因此，在下面的代码中，传递给 setInterval 的函数内的 this 与封闭函数中的 this 值相同：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.age++; <span class="comment">// |this| 正确地指向 p 实例</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// 实例p</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>最后，因为箭头函数没有 this，所以也不能用 call()、apply()、bind() 这些方法改变 this 的指向，可以看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> result = (<span class="function">() =&gt;</span> <span class="built_in">this</span>.value).bind(&#123; <span class="attr">value</span>: <span class="number">2</span> &#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h2 id="没有-arguments"><a href="#没有-arguments" class="headerlink" title="没有 arguments"></a>没有 arguments</h2><p>箭头函数没有自己的 arguments 对象，所以箭头函数可以访问外围函数的 arguments 对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constant</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = constant(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result()); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>在大多数情况下，使用<strong>剩余参数</strong>是相较使用 arguments 对象的更好选择。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="function">(<span class="params">...args</span>) =&gt;</span> args;</span><br></pre></td></tr></table></figure>

<h2 id="不能使用-new-操作符"><a href="#不能使用-new-操作符" class="headerlink" title="不能使用 new 操作符"></a>不能使用 new 操作符</h2><p>JavaScript 函数有两个内部方法：[[Call]] 和 [[Construct]]。</p>
<p>当通过 new 调用函数时，执行 [[Construct]] 方法，创建一个实例对象，然后再执行函数体，将 this 绑定到实例上。</p>
<p>当直接调用的时候，执行 [[Call]] 方法，直接执行函数体。<br>箭头函数并没有 [[Construct]] 方法，不能用作构造函数，和 new 一起用会抛出错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Foo = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo(); <span class="comment">// TypeError: Foo is not a constructor</span></span><br></pre></td></tr></table></figure>

<h2 id="没有-prototype"><a href="#没有-prototype" class="headerlink" title="没有 prototype"></a>没有 prototype</h2><p>箭头函数没有 prototype 属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Foo = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Foo.prototype); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="没有-new-target"><a href="#没有-new-target" class="headerlink" title="没有 new.target"></a>没有 new.target</h2><p>因为不能使用 new 调用，所以也没有 <a href="https://es6.ruanyifeng.com/#docs/class#new-target-%E5%B1%9E%E6%80%A7">new.target</a> 值。</p>
<h2 id="没有-super"><a href="#没有-super" class="headerlink" title="没有 super"></a>没有 super</h2><p>连原型都没有，自然也不能通过 super 来访问原型的属性，所以箭头函数也是没有 super 的，不过跟 this、arguments、new.target 一样，这些值由外围最近一层非箭头函数决定。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions</a></li>
</ul>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Es6</tag>
      </tags>
  </entry>
  <entry>
    <title>浮点数的二进制表示</title>
    <url>/2021/08/20/javascript/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<p>本文主要讨论下计算机如何将浮点数存储在有数量限制的内存中。</p>
<span id="more"></span>

<h2 id="如何表示二进制小数"><a href="#如何表示二进制小数" class="headerlink" title="如何表示二进制小数"></a>如何表示二进制小数</h2><p>假设我们有 16 位（2 个字节）来存储数字。在 16 位中，我们可以存储以下范围内[0, 65535]整数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(0000000000000000)₂ = (0)₁₀</span><br><span class="line"></span><br><span class="line">(0000000000010001)₂ =</span><br><span class="line">    (1 × 2⁴) +</span><br><span class="line">    (0 × 2³) +</span><br><span class="line">    (0 × 2²) +</span><br><span class="line">    (0 × 2¹) +</span><br><span class="line">    (1 × 2⁰) = (17)₁₀</span><br><span class="line"></span><br><span class="line">(1111111111111111)₂ =</span><br><span class="line">    (1 × 2¹⁵) +</span><br><span class="line">    (1 × 2¹⁴) +</span><br><span class="line">    (1 × 2¹³) +</span><br><span class="line">    (1 × 2¹²) +</span><br><span class="line">    (1 × 2¹¹) +</span><br><span class="line">    (1 × 2¹⁰) +</span><br><span class="line">    (1 × 2⁹) +</span><br><span class="line">    (1 × 2⁸) +</span><br><span class="line">    (1 × 2⁷) +</span><br><span class="line">    (1 × 2⁶) +</span><br><span class="line">    (1 × 2⁵) +</span><br><span class="line">    (1 × 2⁴) +</span><br><span class="line">    (1 × 2³) +</span><br><span class="line">    (1 × 2²) +</span><br><span class="line">    (1 × 2¹) +</span><br><span class="line">    (1 × 2⁰) = (65535)₁₀</span><br></pre></td></tr></table></figure>

<p>如果我们需要一个有符号整数， 最高位表示符号,0 为正,1 为负。在这种情况下，16 位整型数据的取值范围是[-32768, +32767]。</p>
<p>这时我们可以看出，这种方法不允许表示浮点数（如：27.15625），下面我们来看看浮点数 27.15625 用二进制如何表示：<br>整数部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(27)₁₀ = (11011)₂</span><br></pre></td></tr></table></figure>

<p>小数部分，我们按照乘 2 余 1 法则，将十进制小数转为二进制小数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.15625 * 2² = 0.3125; // &lt; 1</span><br><span class="line">0.3125 * 2 = 0.625;   // &lt; 1</span><br><span class="line">0.625 * 2 = 1.25;     // &gt; 1</span><br><span class="line">0.25 * 2 = 0.5;       // &lt; 1</span><br><span class="line">0.5 * 2 = 1;          // = 1</span><br></pre></td></tr></table></figure>

<p>则 0.15625 转换成二进制：00101</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(0.15625)₁₀ = (0 x 2⁻¹) + (0 x 2⁻²) + (1 x 2⁻³) + (0 × 2⁻⁴) + (1 × 2⁻⁵)</span><br></pre></td></tr></table></figure>

<p>现在，我们可以得到看上去有点像的二进制的小数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(27.15625)₁₀ = (11011.00101)₂</span><br><span class="line">(27.5)10 = (11011.1)₂</span><br></pre></td></tr></table></figure>

<p>但是这里小数点并不能被计算机处理，计算机认识 0 和 1。所以，我们需要进一步处理，将符号、小数点也数字化，基本思路就是：</p>
<ul>
<li>0 表示正数，1 表示负数，将符号 1，0 数字化；</li>
<li>用科学计数将小数整数化；</li>
</ul>
<p>下面我们以 IEEE754 为例，我们看下十进制浮点数如何表示成二进制浮点数进行存储。</p>
<h2 id="IEEE-754-标准"><a href="#IEEE-754-标准" class="headerlink" title="IEEE 754 标准"></a>IEEE 754 标准</h2><p>IEEE，电气和电子工程师协会( 全称是 Institute of Electrical and Electronics Engineers)是一个国际性的电子技术与信息科学工程师的协会，是目前全球最大的非营利性专业技术学会，<a href="https://zh.wikipedia.org/wiki/IEEE_754">IEEE 754</a> 标准是 IEEE 二进位浮点数算术标准（IEEE Standard for Floating-Point Arithmetic）的标准编号。<br>根据国际标准 IEEE 754，任意一个二进制浮点数 V 可以表示成下面的形式：</p>
<p><img src="/images/chart.png" alt="图片"><br>也就是浮点数的实际值，可以分为三个部分：</p>
<ul>
<li>(-1)^s 表示符号位，当 s=0，V 为正数；当 s=1，V 为负数。</li>
<li>M 表示有效数字，大于等于 1，小于 2。</li>
<li>2^E 表示指数位。</li>
</ul>
<p>举例来说：</p>
<p>十进制的 5.0，写成二进制是 101.0，相当于 1.01×2^2。那么，按照上面 V 的格式，可以得出 s=0，M=1.01，E=2。<br>十进制的-5.0，写成二进制是-101.0，相当于-1.01×2^2。那么，s=1，M=1.01，E=2。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5.0 -&gt; 101.0 -&gt; (-1)⁰ * 1.01 * 2²</span><br><span class="line">-5.0 -&gt; -101.0 -&gt; (-1)¹ * 1.01 * 2²</span><br></pre></td></tr></table></figure>

<p><img src="/images/floating_point_frac.png" alt="图片"></p>
<p>IEEE 754 对有效数字 M 和指数 E，还有一些特别规定。<br>前面说过，1≤M&lt;2，也就是说，M 可以写成 1.xxxxxx 的形式，其中 xxxxxx 表示小数部分。IEEE 754 规定，在计算机内部保存 M 时，默认这个数的第一位总是 1，因此可以被舍去，只保存后面的 xxxxxx 部分。比如保存 1.01 的时候，只保存 01，等到读取的时候，再把第一位的 1 加上去。这样做的目的，是节省 1 位有效数字。以 32 位浮点数为例，留给 M 只有 23 位，将第一位的 1 舍去以后，等于可以保存 24 位有效数字。</p>
<p>至于指数 E，情况就比较复杂。</p>
<p>首先，E 为一个无符号整数（unsigned int）。这意味着，如果 E 为 8 位，它的取值范围为 0~255；如果 E 为 11 位，它的取值范围为 0~2047。但是，我们知道，科学计数法中的 E 是可以出现负数的，<strong>所以 IEEE 754 规定，E 的真实值必须再减去一个中间数，对于 8 位的 E，这个中间数是 127；对于 11 位的 E，这个中间数是 1023。</strong></p>
<p>比如，2^10 的 E 是 10，所以保存成 32 位浮点数时，必须保存成 10+127=137，即 10001001。</p>
<p>然后，指数 E 还可以再分成三种情况：</p>
<ol>
<li><p> E 不全为 0 或不全为 1。这时，浮点数就采用上面的规则表示，即指数 E 的计算值减去 127（或 1023），得到真实值，再将有效数字 M 前加上第一位的 1。</p>
</li>
<li><p> E 全为 0。这时，浮点数的指数 E 等于 1-127（或者 1-1023），有效数字 M 不再加上第一位的 1，而是还原为 0.xxxxxx 的小数。这样做是为了表示 ±0，以及接近于 0 的很小的数字。</p>
</li>
<li><p> E 全为 1。这时，如果有效数字 M 全为 0，表示 ± 无穷大（正负取决于符号位 s）；如果有效数字 M 不全为 0，表示这个数不是一个数（NaN）。</p>
</li>
</ol>
<p>一般来说，现在的编译器都支持两种浮点格式，一种是单精度，一种是双精度。单双精度分别对应于编程语言当中的 float 和 double 类型。其中 float 是单精度的，采用 32 位二进制表示，其中 1 位符号位，8 位阶码以及 23 位尾数。double 是双精度的，采用 64 位二进制表示，其中 1 位符号位，11 位阶码以及 52 位尾数，js 中的浮点数就是双进度的。如下表所示：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>符号位</th>
<th>阶码</th>
<th>尾数</th>
<th>总位数</th>
<th>偏移值</th>
</tr>
</thead>
<tbody><tr>
<td>单精度</td>
<td>1</td>
<td>8</td>
<td>23</td>
<td>32</td>
<td>127</td>
</tr>
<tr>
<td>双精度</td>
<td>1</td>
<td>11</td>
<td>52</td>
<td>64</td>
<td>1023</td>
</tr>
</tbody></table>
<p>为了更好地了解 IEEE 754 标准的工作原理。为简单起见，这里使用 32 位数字，但同样的方法也适用于 64 位数字。</p>
<p>还是开头的例子，我们把十进制浮点数(27.15625)转换成二进制，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(27.15625)₁₀ -&gt; (11011.00101)₂ -&gt; 1.101100101 * 2⁴;</span><br><span class="line"></span><br><span class="line">1. 符号位： 正数，s = 0,</span><br><span class="line">2. 阶数为4，则阶码 = 4 + 127 = 131 = (1 × 2⁷) + (1 × 2¹) + (1 × 2⁰) = 10000011</span><br><span class="line">3. 尾数，101100101，不足23位，右侧补0。</span><br><span class="line"></span><br><span class="line">最终结果如下：</span><br><span class="line">0 10000011 10110010100000000000000</span><br></pre></td></tr></table></figure>

<p>示例图：</p>
<p><img src="/images/IEEE-754-32.png" alt="图片"></p>
<p>下面我们再看一个列子，把(-10.15)转换成二进制，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(10.15)₁₀ -&gt; (1010.0010011001...1001...)₂ -&gt; 1.0100010011001...1001... * 2³;</span><br><span class="line"></span><br><span class="line">1. 符号位： 负数，s = 1,</span><br><span class="line">2. 阶数为3，则阶码 = 3 + 127 = 130 = (1 × 2⁷) + (1 × 2¹) = 10000010</span><br><span class="line">3. 尾数，0100010011001...1001...，尾数部分是01000+n个1001无限循环小数，由于存储位数限制，只能是 23位，因此第24位0要进行舍去操作，1入0舍。</span><br><span class="line"></span><br><span class="line">最终结果如下：</span><br><span class="line">1 10000010  01000100110011001100110</span><br></pre></td></tr></table></figure>

<p>示例图：</p>
<p><img src="/images/IEEE-754-32_2.png" alt="图片"></p>
<h2 id="转换工具"><a href="#转换工具" class="headerlink" title="转换工具"></a>转换工具</h2><p>这里有个网址，可以方便查看十进制、二进制、十六进制与单精度、双精度、四精度之间的关系：(<a href="https://babbage.cs.qc.cuny.edu/IEEE-754/">https://babbage.cs.qc.cuny.edu/IEEE-754/</a>)</p>
<h2 id="0-1-0-2-0-3"><a href="#0-1-0-2-0-3" class="headerlink" title="0.1+0.2!=0.3"></a>0.1+0.2!=0.3</h2><p>最后来看看 0.1+0.2!=0.3 这个经典问题。<br>我们 javascript 为例，其浮点数是 64 位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = (0.1)₁₀ = (0.000110011...0011...)₂ = 1.10011...0011... * 2⁻⁴;</span><br><span class="line"></span><br><span class="line">那么x阶数：-4，则阶码 = 1023 + (-4) = 1019 = 01111111011;</span><br><span class="line"></span><br><span class="line">x的尾数：10011...0011...;</span><br><span class="line"></span><br><span class="line">所以最终：</span><br><span class="line">x = 0 01111111011 1001100110011001100110011001100110011001100110011010</span><br></pre></td></tr></table></figure>

<p>同理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y =  (0.2)₁₀ = (0.00110011...0011...)₂ = 1.10011...0011... * 2⁻³;</span><br><span class="line"></span><br><span class="line">那么x阶数：-3，则阶码 = 1023 + (-3) = 1020 = 01111111100;</span><br><span class="line"></span><br><span class="line">y的尾数：10011...0011...;</span><br><span class="line"></span><br><span class="line">所以最终：</span><br><span class="line">y = 0 01111111100 1001100110011001100110011001100110011001100110011010</span><br></pre></td></tr></table></figure>

<h3 id="浮点数运算"><a href="#浮点数运算" class="headerlink" title="浮点数运算"></a>浮点数运算</h3><p>浮点数的加减运算一般由以下五个步骤完成：对阶、尾数运算、规格化、舍入处理、溢出判断</p>
<h4 id="对阶"><a href="#对阶" class="headerlink" title="对阶"></a>对阶</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x的阶码 = 01111111011;</span><br><span class="line"></span><br><span class="line">y的阶码 = 01111111100;</span><br><span class="line"></span><br><span class="line">y-x 阶码 = 01111111100 - 01111111011 = 1</span><br><span class="line"></span><br><span class="line">则x的阶码需要+1，尾数需要向右移动一位，采用舍入法则，末尾0舍去，如下</span><br><span class="line"></span><br><span class="line">x = 0 01111111100 1100110011001100110011001100110011001100110011001101</span><br><span class="line">y = 0 01111111100 1001100110011001100110011001100110011001100110011010</span><br></pre></td></tr></table></figure>

<h4 id="尾数运算"><a href="#尾数运算" class="headerlink" title="尾数运算"></a>尾数运算</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x:  0.1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1100 1101</span><br><span class="line">+y: 1.1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1001 1010</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">   10.0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0111</span><br></pre></td></tr></table></figure>

<h4 id="规格化"><a href="#规格化" class="headerlink" title="规格化"></a>规格化</h4><p>简单理解就是尾数是否是 1.xxxxxx 这种格式，目前是 10.xxx，因此需要做规格化处理，即尾数需要右移 1 位（也称右规），同时阶码+1，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 尾数右移</span><br><span class="line">1.00110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 011(1);</span><br><span class="line"></span><br><span class="line">// 阶码+1</span><br><span class="line">0 01111111101 0011001100110011001100110011001100110011001100110011(1);</span><br></pre></td></tr></table></figure>

<p>规格化后，尾数高位 1，隐藏不显示。</p>
<h4 id="舍入处理"><a href="#舍入处理" class="headerlink" title="舍入处理"></a>舍入处理</h4><p>规格化时，尾数末位如果是 1，直接移除将会丢失进度，因此需要舍入处理，通常采用“1 入 0 舍”法，本例尾数末位是 1，因此需要“入”，即+1 处理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 01111111101 0011001100110011001100110011001100110011001100110011(1);</span><br><span class="line">0 01111111101 0011001100110011001100110011001100110011001100110100;</span><br></pre></td></tr></table></figure>

<h4 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h4><p>结果：0 01111111101 0011001100110011001100110011001100110011001100110100，没有溢出，阶码不调整，所以 0.1+0.2 的结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 01111111101 0011001100110011001100110011001100110011001100110100</span><br></pre></td></tr></table></figure>

<p>转为 10 进制：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 01111111101 0011001100110011001100110011001100110011001100110100</span><br><span class="line">= (-1)⁰ * 2⁻² * (2⁰ + 0.2000000000000002)</span><br><span class="line">= 0.30000000000000004</span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://trekhleb.dev/blog/2021/binary-floating-point/">https://trekhleb.dev/blog/2021/binary-floating-point/</a></li>
<li><a href="https://babbage.cs.qc.cuny.edu/IEEE-754/">https://babbage.cs.qc.cuny.edu/IEEE-754/</a></li>
</ul>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>九、JavaScript专题之偏函数</title>
    <url>/2020/03/22/jsspecial/%E5%81%8F%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="什么是偏函数"><a href="#什么是偏函数" class="headerlink" title="什么是偏函数"></a>什么是偏函数</h2><p>偏函数（Partial application），wiki 上解释：</p>
<span id="more"></span>

<blockquote>
<p>In computer science, <a href="https://en.wikipedia.org/wiki/Partial_application">partial application</a> (or partial function application) refers to the process of fixing a number of arguments to a function, producing another function of smaller arity.</p>
</blockquote>
<p>翻译成中文：</p>
<blockquote>
<p>在计算机科学中，局部应用(或局部函数应用)指将多个参数固定到一个函数上，产生另一个具有较小元数的函数的过程。<br>什么是元？元是指函数参数的个数，比如一个带有两个参数的函数被称为二元函数。<br>举个例子：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设有一个 partial 函数可以做到局部应用</span></span><br><span class="line"><span class="keyword">var</span> addOne = partial(add, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">addOne(<span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>Partial Application(偏函数应用)很容易和函数柯里化混淆，所以两者到底是有什么区别呢？</p>
<blockquote>
<p>柯里化是将一个多参数函数转换成多个单参数函数，也就是将一个 n 元函数转换成 n 个一元函数。<br>局部应用则是固定一个函数的一个或者多个参数，也就是将一个 n 元函数转换成一个 n - x 元函数。</p>
</blockquote>
<p>如果说两者有什么关系的话，引用 <a href="https://github.com/hemanth/functional-programming-jargon#partial-application">functional-programming-jargon</a> 中的描述就是：</p>
<blockquote>
<p>Curried functions are automatically partially applied.</p>
</blockquote>
<p>即柯里化过的函数会自动生成局部应用。</p>
<h2 id="偏函数实现"><a href="#偏函数实现" class="headerlink" title="偏函数实现"></a>偏函数实现</h2><p>实现过程跟柯里化有点相似：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, [...args, ...params]);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + <span class="built_in">this</span>.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var addOne = add.bind(null, 1);</span></span><br><span class="line"><span class="keyword">var</span> addOne = partial(add, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">addOne</span>: addOne,</span><br><span class="line">&#125;;</span><br><span class="line">obj.addOne(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 使用 bind 时，结果为 4</span></span><br><span class="line"><span class="comment">// 使用 partial 时，结果为 5</span></span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://github.com/mqyqingfeng/Blog/issues/43">https://github.com/mqyqingfeng/Blog/issues/43</a></p>
]]></content>
      <categories>
        <category>JavaScript专题系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>八、JavaScript专题之函数柯里化</title>
    <url>/2020/03/15/jsspecial/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    <content><![CDATA[<p>函数式编程是一种编程风格，它尝试将函数作为参数传递（回调）并返回没有副作用的函数。因此带来了一些其他东西，比如纯函数、柯里化、高阶函数。<br>这里我们主要讨论函数柯里化的实现与应用场景。</p>
<span id="more"></span>

<h2 id="什么是柯里化"><a href="#什么是柯里化" class="headerlink" title="什么是柯里化"></a>什么是柯里化</h2><p>柯里化是函数式编程中的一个过程，我们可以将具有多个参数的函数转换为一系列嵌套函数。它返回一个新函数，该函数能接受下一个参数。</p>
<blockquote>
<p>柯里化是将具有多元数的函数变成具有较少元数的函数的过程 - <a href="https://medium.com/@kbrainwave">Kristina Brainwave</a></p>
</blockquote>
<p>举个例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b * c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行multiply方法，传入三个参数</span></span><br><span class="line">multiply(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>现在我们创建一个柯里化函数版本：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a * b * c;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">multiply(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>我们已经把 multiply(1,2,3) 函数调用变成了 multiply(1)(2)(3)多个函数的调用。</p>
<p>而对于 Javascript 语言来说，我们通常说的柯里化函数的概念，与数学和计算机科学中的柯里化的概念并不完全一样。<br>在数学和计算机科学中的柯里化函数，一次只能传递一个参数；<br>而我们 Javascript 实际应用中的柯里化函数，可以传递一个或多个参数。<br>来看这个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b, c, d, e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b, c, d, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生成的柯里化函数</span></span><br><span class="line"><span class="keyword">let</span> _fn = curry(fn);</span><br><span class="line"></span><br><span class="line">_fn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// print: 1,2,3,4,5</span></span><br><span class="line">_fn(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// print: 1,2,3,4,5</span></span><br><span class="line">_fn(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>)(<span class="number">5</span>); <span class="comment">// print: 1,2,3,4,5</span></span><br><span class="line">_fn(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>); <span class="comment">// print: 1,2,3,4,5</span></span><br></pre></td></tr></table></figure>

<p>对于已经柯里化后的 _fn 函数来说，当接收的参数数量与原函数的形参数量相同时，执行原函数；<br>当接收的参数数量小于原函数的形参数量时，返回一个函数用于接收剩余的参数，直至接收的参数数量与形参数量一致，执行原函数。<br>当我们知道柯里化是什么了的时候，我们来看看柯里化到底有什么用？</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>柯里化实际是把简答的问题复杂化了，但是复杂化的同时，我们在使用函数时拥有了更加多的自由度，而这里对于函数参数的自由处理，正是柯里化的核心所在。<br>柯里化本质上是降低通用性，提高适用性。来看一个例子：<br>我们工作中会遇到各种需要通过正则检验的需求，比如校验电话号码、校验邮箱、校验身份证号、校验密码等，<br>这时我们会封装一个通用函数 checkByRegExp ,接收两个参数，校验的正则对象和待校验的字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkByRegExp</span>(<span class="params">regExp, string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> regExp.test(string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkByRegExp(<span class="regexp">/^1\d&#123;10&#125;$/</span>, <span class="string">&quot;18642838455&quot;</span>); <span class="comment">// 校验电话号码</span></span><br><span class="line">checkByRegExp(<span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/</span>, <span class="string">&quot;test@163.com&quot;</span>); <span class="comment">// 校验邮箱</span></span><br></pre></td></tr></table></figure>

<p>我们每次进行校验的时候都需要输入一串正则，再校验同一类型的数据时，相同的正则我们需要写多次，<br>这就导致我们在使用的时候效率低下，并且由于 checkByRegExp 函数本身是一个工具函数并没有任何意义，<br>一段时间后我们重新来看这些代码时，如果没有注释，我们必须通过检查正则的内容，<br>我们才能知道我们校验的是电话号码还是邮箱，还是别的什么。<br>此时，我们可以借助柯里化对 checkByRegExp 函数进行封装，以简化代码书写，提高代码可读性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进行柯里化</span></span><br><span class="line"><span class="keyword">let</span> _check = curry(checkByRegExp);</span><br><span class="line"><span class="comment">//生成工具函数，验证电话号码</span></span><br><span class="line"><span class="keyword">let</span> checkCellPhone = _check(<span class="regexp">/^1\d&#123;10&#125;$/</span>);</span><br><span class="line"><span class="comment">//生成工具函数，验证邮箱</span></span><br><span class="line"><span class="keyword">let</span> checkEmail = _check(<span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/</span>);</span><br><span class="line"></span><br><span class="line">checkCellPhone(<span class="string">&quot;18642838455&quot;</span>); <span class="comment">// 校验电话号码</span></span><br><span class="line">checkCellPhone(<span class="string">&quot;13109840560&quot;</span>); <span class="comment">// 校验电话号码</span></span><br><span class="line">checkCellPhone(<span class="string">&quot;13204061212&quot;</span>); <span class="comment">// 校验电话号码</span></span><br><span class="line"></span><br><span class="line">checkEmail(<span class="string">&quot;test@163.com&quot;</span>); <span class="comment">// 校验邮箱</span></span><br><span class="line">checkEmail(<span class="string">&quot;test@qq.com&quot;</span>); <span class="comment">// 校验邮箱</span></span><br><span class="line">checkEmail(<span class="string">&quot;test@gmail.com&quot;</span>); <span class="comment">// 校验邮箱</span></span><br></pre></td></tr></table></figure>

<p>经过柯里化后，我们生成了两个函数 checkCellPhone 和 checkEmail，<br>checkCellPhone 函数只能验证传入的字符串是否是电话号码，<br>checkEmail 函数只能验证传入的字符串是否是邮箱，<br>它们与 原函数 checkByRegExp 相比，从功能上通用性降低了，但适用性提升了。<br>柯里化的这种用途可以被理解为：参数复用。</p>
<p>我们再来看一个例子，比如我们有这样一段数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = [&#123; <span class="attr">name</span>: <span class="string">&quot;lilei&quot;</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&quot;hanmeimei&quot;</span> &#125;];</span><br></pre></td></tr></table></figure>

<p>如果我们要获取那么属性，我们可以这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = person.map(<span class="function">(<span class="params">item</span>) =&gt;</span> item.name);</span><br></pre></td></tr></table></figure>

<p>如果我们有 curry 函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> prop = curry(<span class="function"><span class="keyword">function</span> (<span class="params">key, obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = person.map(prop(<span class="string">&quot;name&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>这里我们为了获取 name 属性编写一个 prop 函数，你可能会觉得太麻烦了。<br>但是要注意，prop 函数编写一次后，以后可以多次使用，我们在考虑代码复杂的的时候，是可以将 prop 函数的实现去掉的，实际上代码从原本的三行精简成了一行。</p>
<h2 id="柯里化工具函数封装"><a href="#柯里化工具函数封装" class="headerlink" title="柯里化工具函数封装"></a>柯里化工具函数封装</h2><p>常见 curry 函数的实现为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> curry = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArgs = args.concat([].slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, newArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> addCurry = curry(add, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">addCurry(); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">var</span> addCurry = curry(add, <span class="number">1</span>);</span><br><span class="line">addCurry(<span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">var</span> addCurry = curry(add);</span><br><span class="line">addCurry(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>已经有柯里化的感觉了，但是还没有达到要求，不过我们可以把这个函数用作辅助函数，帮助我们写真正的 curry 函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub_curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, args.concat([].slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, length</span>) </span>&#123;</span><br><span class="line">  length = length || fn.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &lt; length) &#123;</span><br><span class="line">      <span class="keyword">var</span> combined = [fn].concat(slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">      <span class="keyword">var</span> sub_fn = sub_curry.apply(<span class="built_in">this</span>, combined);</span><br><span class="line">      <span class="keyword">return</span> curry(sub_fn, length - <span class="built_in">arguments</span>.length);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> fn = curry(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [a, b, c];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fn(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line">fn(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)(<span class="string">&quot;c&quot;</span>); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line">fn(<span class="string">&quot;a&quot;</span>)(<span class="string">&quot;b&quot;</span>)(<span class="string">&quot;c&quot;</span>); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line">fn(<span class="string">&quot;a&quot;</span>)(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>

<p>如果上面的实现不好理解的话，我们换一种写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sun_curry</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, [...args, ...params]);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, length = fn.length</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (params.length &lt; length) &#123;</span><br><span class="line">      <span class="keyword">var</span> sub_fn = sub_curry.apply(<span class="built_in">this</span>, [fn, ...params]);</span><br><span class="line">      <span class="keyword">return</span> curry(sub_fn, length - params.length);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, params);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sun_curry 方法的作用在与接收一个函数和若干参数，然后返回一个函数，该函数能接收后续若干参数。<br>curry 方法的作用就是递归调用辅助函数 sub_curry，实现函数柯里化。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://juejin.cn/post/6844903882208837645">https://juejin.cn/post/6844903882208837645</a></p>
]]></content>
      <categories>
        <category>JavaScript专题系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>十、JavaScript专题之惰性函数</title>
    <url>/2020/03/28/jsspecial/%E6%83%B0%E6%80%A7%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="什么是惰性函数"><a href="#什么是惰性函数" class="headerlink" title="什么是惰性函数"></a>什么是惰性函数</h2><p>惰性函数表示函数执行的分支只会在函数第一次调用的时候执行，在第一次调用过程中，该函数会被覆盖为另一个按照合适方式执行的函数，这样任何对原函数的调用就不用再经过执行的分支了。本文将详细介绍惰性函数</p>
<span id="more"></span>

<h2 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a>使用背景</h2><p>我们知道 javascript 最大的问题就是浏览器的兼容问题，一个 api 在不同的浏览器调用的结果是不一样的，有的时候我们需要通过 if 判断来实现不同的兼容问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">type, element, fun</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">    element.addEventListener(type, fun, <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">    element.attachEvent(<span class="string">&quot;on&quot;</span> + type, fun);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    element[<span class="string">&quot;on&quot;</span> + type] = fun;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是一个兼容不同浏览器事件绑定的方法，但是，他有一个问题：</p>
<p>每次调用 addEvent 函数的时候都要进行 if 判断，如果浏览器支持其中的一个方法，那么它就永远支持了，没有必要再进行其他分支的检测了。也就是说，if 语句不必每次都执行，代码可以运行的更快一些，解决方案就是惰性载入。</p>
<h2 id="函数重写"><a href="#函数重写" class="headerlink" title="函数重写"></a>函数重写</h2><p>在介绍惰性函数之前，首先介绍函数重写技术。由于一个函数可以返回另一个函数，因此可以用新的函数来覆盖旧的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a(); <span class="comment">// a</span></span><br><span class="line">a(); <span class="comment">// b</span></span><br></pre></td></tr></table></figure>

<p>第一次调用该函数时会 console.log(‘a’)会被执行；然后全局变量 a 被重定义，并被赋予新的函数。当该函数再次被调用时， console.log(‘b’)会被执行；</p>
<h2 id="惰性函数"><a href="#惰性函数" class="headerlink" title="惰性函数"></a>惰性函数</h2><p>惰性函数的本质就是函数重写。所谓惰性载入，指函数执行的分支只会发生一次，有两种实现惰性载入的方式：</p>
<p>1、第一种是在函数被调用时，再处理函数。函数在第一次调用时，该函数会被覆盖为另外一个按合适方式执行的函数，这样任何对原函数的调用都不用再经过执行的分支了。代码重写如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">type, element, fun</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">    addEvent = <span class="function"><span class="keyword">function</span> (<span class="params">type, element, fun</span>) </span>&#123;</span><br><span class="line">      element.addEventListener(type, fun, <span class="literal">false</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">    addEvent = <span class="function"><span class="keyword">function</span> (<span class="params">type, element, fun</span>) </span>&#123;</span><br><span class="line">      element.attachEvent(<span class="string">&quot;on&quot;</span> + type, fun);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    addEvent = <span class="function"><span class="keyword">function</span> (<span class="params">type, element, fun</span>) </span>&#123;</span><br><span class="line">      element[<span class="string">&quot;on&quot;</span> + type] = fun;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> addEvent(type, element, fun);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个惰性载入的 addEvent()中，if 语句的每个分支都会为 addEvent 变量赋值，有效覆盖了原函数。最后一步便是调用了新赋函数。下一次调用 addEvent()时，便会直接调用新赋值的函数，这样就不用再执行 if 语句了。<br>但是，这种方法有个缺点，如果函数名称有所改变，修改起来比较麻烦。</p>
<p>2、第二种是声明函数时就指定适当的函数。把嗅探浏览器的操作提前到代码加载的时候，在代码加载的时候就立刻进行一次判断，以便让 addEvent 返回一个包裹了正确逻辑的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> addEvent = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.addEventListener) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">type, element, fun</span>) </span>&#123;</span><br><span class="line">      element.addEventListener(type, fun, <span class="literal">false</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">document</span>.attachEvent) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">type, element, fun</span>) </span>&#123;</span><br><span class="line">      element.attachEvent(<span class="string">&quot;on&quot;</span> + type, fun);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">type, element, fun</span>) </span>&#123;</span><br><span class="line">      element[<span class="string">&quot;on&quot;</span> + type] = fun;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>综上，当我们每次都需要进行条件判断，其实只需要判断一次，接下来的使用方式都不会发生改变的时候，想想是否可以考虑使用惰性函数。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://xiaohuochai.site/JS/ECMA/types/LazyFunction.html">https://xiaohuochai.site/JS/ECMA/types/LazyFunction.html</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript专题系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>十一、JavaScript专题之数组乱序</title>
    <url>/2020/04/05/jsspecial/%E6%95%B0%E7%BB%84%E4%B9%B1%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>数组乱序指的是：将数组元素的排列顺序随机打乱。<br>通常我们在做抽奖系统或者发牌等游戏时，会遇到数组乱序的问题。 举个例子：将 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 乱序。</p>
<span id="more"></span>

<h2 id="sort-结合-Math-random"><a href="#sort-结合-Math-random" class="headerlink" title="sort 结合 Math.random"></a>sort 结合 Math.random</h2><p>先看代码实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>

<p>Math.random() - 0.5 随机得到一个正数、负数或是 0，如果是正数则升序序排列，如果是负数则降序排列，如果是 0 就不变，然后不断的升序或者降序，最终得到一个乱序的数组。<br>乍一看，这似乎是一个合理的解决方案。事实上这种方式并不是真正意思上的乱序，一些元素并没有机会相互比较， 最终数组元素停留位置的概率并不是完全随机的。</p>
<p>来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.sort(<span class="function">() =&gt;</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于验证 shuffle 方法是否完全随机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test_shuffle</span>(<span class="params">shuffleFn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 多次乱序数组的次数</span></span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">100000</span>;</span><br><span class="line">  <span class="comment">// 保存每个元素在每个位置上出现的次数</span></span><br><span class="line">  <span class="keyword">let</span> countObj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;).fill(<span class="number">0</span>),</span><br><span class="line">    <span class="attr">b</span>: <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;).fill(<span class="number">0</span>),</span><br><span class="line">    <span class="attr">c</span>: <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;).fill(<span class="number">0</span>),</span><br><span class="line">    <span class="attr">d</span>: <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;).fill(<span class="number">0</span>),</span><br><span class="line">    <span class="attr">e</span>: <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;).fill(<span class="number">0</span>),</span><br><span class="line">    <span class="attr">f</span>: <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;).fill(<span class="number">0</span>),</span><br><span class="line">    <span class="attr">g</span>: <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;).fill(<span class="number">0</span>),</span><br><span class="line">    <span class="attr">h</span>: <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;).fill(<span class="number">0</span>),</span><br><span class="line">    <span class="attr">i</span>: <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;).fill(<span class="number">0</span>),</span><br><span class="line">    <span class="attr">j</span>: <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">10</span> &#125;).fill(<span class="number">0</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="string">&quot;g&quot;</span>, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;i&quot;</span>, <span class="string">&quot;j&quot;</span>];</span><br><span class="line">    shuffleFn(arr);</span><br><span class="line">    countObj.a[arr.indexOf(<span class="string">&quot;a&quot;</span>)]++;</span><br><span class="line">    countObj.b[arr.indexOf(<span class="string">&quot;b&quot;</span>)]++;</span><br><span class="line">    countObj.c[arr.indexOf(<span class="string">&quot;c&quot;</span>)]++;</span><br><span class="line">    countObj.d[arr.indexOf(<span class="string">&quot;d&quot;</span>)]++;</span><br><span class="line">    countObj.e[arr.indexOf(<span class="string">&quot;e&quot;</span>)]++;</span><br><span class="line">    countObj.f[arr.indexOf(<span class="string">&quot;f&quot;</span>)]++;</span><br><span class="line">    countObj.g[arr.indexOf(<span class="string">&quot;g&quot;</span>)]++;</span><br><span class="line">    countObj.h[arr.indexOf(<span class="string">&quot;h&quot;</span>)]++;</span><br><span class="line">    countObj.i[arr.indexOf(<span class="string">&quot;i&quot;</span>)]++;</span><br><span class="line">    countObj.j[arr.indexOf(<span class="string">&quot;j&quot;</span>)]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.table(countObj);</span><br><span class="line">&#125;</span><br><span class="line">test_shuffle(shuffle);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们定义了两个函数，shuffle 中使用 sort 和 Math.random() 进行数组乱序操作；<br>test_shuffle 函数定义了一个长度为 10 的数组 [‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’, ‘g’, ‘h’, ‘i’, ‘j’]，并使用传入的乱序函数进行十万次操作，并将数组中每个元素在每个位置出现的次数存放到变量 countObj 中，最终将 countObj 打印出来。<br>结果如下：</p>
<p><img src="/images/shuffle.png" alt="(运行结果)"></p>
<p>从这个表格中我们能够看出，每个元素在每个位置出现的概率相差很大，比如元素 a ，<br>在索引 0 的位置上出现了 19408 次，在索引 4 的位置上只出现了 6733 次，<br>元素 a 在这两个位置出现的次数相差很大（相差一倍还多）。<br>如果排序真的是随机的，那么每个元素在每个位置出现的概率都应该一样，<br>实验结果各个位置的数字应该很接近，而不是像现在这样各个位置的数字相差很大。<br>那么问题出在哪里呢？</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>如果要追究这个问题所在，就必须了解 sort 函数的原理，然而 ECMAScript 只规定了效果，没有规定实现的方式，所以不同浏览器实现的方式还不一样。</p>
<p>为了解决这个问题，我们以 v8 为例，v8 在处理 sort 方法时，使用了插入排序和快排两种方案。 当目标数组长度小于 10 时，使用插入排序；反之，使用快速排序。</p>
<p>源码地址：<a href="https://github.com/v8/v8/blob/master/src/js/array.js">https://github.com/v8/v8/blob/master/src/js/array.js</a></p>
<p>为了简化篇幅，我们对 [1, 2, 3] 这个数组进行分析，数组长度为 3，此时采用的是插入排序。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">list = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> temp = list[i];</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; list[j] &gt; temp) &#123;</span><br><span class="line">      list[j + <span class="number">1</span>] = list[j];</span><br><span class="line">      j = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    list[j + <span class="number">1</span>] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其原理在于将第一个元素视为有序序列，遍历数组，将之后的元素依次插入这个构建的有序序列中。<br>我们来个简单的示意图：</p>
<p><img src="/images/insertion.gif" alt="(排序效果图)"></p>
<p>现在我们来具体分析[1, 2, 3]这个数组排序；</p>
<p>因为插入排序视第一个元素为有序的，所以数组的外层循环从 i = 1 开始，a[i] 值为 2，此时内层循环遍历，比较 compare(1, 2)，因为 Math.random() - 0.5 的结果有 50% 的概率小于 0 ，有 50% 的概率大于 0，所以有 50% 的概率数组变成 [2, 1, 3]，50% 的结果不变，数组依然为 [1, 2, 3]。</p>
<p>假设依然是 [1, 2, 3]，我们再进行一次分析，接着遍历，i = 2，a[i] 的值为 3，此时内层循环遍历，比较 compare(2, 3)：</p>
<p>有 50% 的概率数组不变，依然是 [1, 2, 3]，然后遍历结束。</p>
<p>有 50% 的概率变成 [1, 3, 2]，因为还没有找到 3 正确的位置，所以还会进行遍历，所以在这 50% 的概率中又会进行一次比较，compare(1, 3)，有 50% 的概率不变，数组为 [1, 3, 2]，此时遍历结束，有 50% 的概率发生变化，数组变成 [3, 1, 2]。</p>
<p>综上，在 [1, 2, 3] 中，有 50% 的概率会变成 [1, 2, 3]，有 25% 的概率会变成 [1, 3, 2]，有 25% 的概率会变成 [3, 1, 2]。</p>
<p>另外一种情况 [2, 1, 3] 与之分析类似，我们将最终的结果汇总成一个表格：</p>
<table role="table">
  <tbody>
    <tr>
      <th>数组</th>
      <th>i = 1</th>
      <th>i = 2</th>
      <th>总计</th>
    </tr>
    <tr>
      <td rowspan="6">[1, 2, 3]</td>
      <td rowspan="3">50% [1, 2, 3]</td>
      <td>50% [1, 2, 3]</td>
      <td>25% [1, 2, 3]</td>
    </tr>
    <tr>
      <td>25% [1, 3, 2]</td>
      <td>12.5% [1, 3, 2]</td>
    </tr>
    <tr>
      <td>25% [3, 1, 2]</td>
      <td>12.5% [3, 1, 2]</td>
    </tr>
    <tr>
      <td rowspan="3">50% [2, 1, 3]</td>
      <td>50% [2, 1, 3]</td>
      <td>25% [2, 1, 3]</td>
    </tr>
    <tr>
      <td>25% [2, 3, 1]</td>
      <td>12.5% [2, 3, 1]</td>
    </tr>
    <tr>
      <td>25% [3, 2, 1]</td>
      <td>12.5% [3, 2, 1]</td>
    </tr>
  </tbody>
</table>

<p>那么如何高性能的实现真正的乱序呢？而这就要提到经典的 Fisher–Yates 算法。</p>
<h2 id="Fisher–Yates"><a href="#Fisher–Yates" class="headerlink" title="Fisher–Yates"></a>Fisher–Yates</h2><p>为什么叫 Fisher–Yates 呢？ 因为这个算法是由 Ronald Fisher 和 Frank Yates 首次提出的。<br>代码实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = a.length; i; i--) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * i);</span><br><span class="line">    [a[i - <span class="number">1</span>], a[j]] = [a[j], a[i - <span class="number">1</span>]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理很简单，就是遍历数组元素，然后将当前元素与以后随机位置的元素进行交换，从代码中也可以看出，这样乱序的就会更加彻底。</p>
<p>测试代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> times = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">var</span> res = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> arr = shuffle([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> key = <span class="built_in">JSON</span>.stringify(arr);</span><br><span class="line">  res[key] ? res[key]++ : (res[key] = <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了方便展示，转换成百分比</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> res) &#123;</span><br><span class="line">  res[key] = (res[key] / times) * <span class="number">100</span> + <span class="string">&quot;%&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"><span class="comment">// 测试结果如下</span></span><br><span class="line">&#123;</span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]: <span class="string">&quot;16.667%&quot;</span>,</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]: <span class="string">&quot;16.761%&quot;</span>,</span><br><span class="line">  [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]: <span class="string">&quot;16.636%&quot;</span>,</span><br><span class="line">  [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]: <span class="string">&quot;16.624%&quot;</span>,</span><br><span class="line">  [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]: <span class="string">&quot;16.744%&quot;</span>,</span><br><span class="line">  [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]: <span class="string">&quot;16.567999999999998%&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从测试结果我们可以看出，每个元素在每个位置出现的次数相差不大，说明这种方式满足了随机性的要求。<br>而且 Fisher–Yates 算法只需要通过一次遍历即可将数组随机打乱顺序，性能极为优异~~<br>至此，我们找到了将数组乱序操作的最优办法：Fisher–Yates~</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://juejin.cn/post/6844903863812620296">https://juejin.cn/post/6844903863812620296</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/51">https://github.com/mqyqingfeng/Blog/issues/51</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript专题系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>二、JavaScript专题之数组去重</title>
    <url>/2020/01/14/jsspecial/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
    <content><![CDATA[<p>在面试中，我们常常会遇到数组去重的问题，这里整理一下。</p>
<span id="more"></span>

<h2 id="双重循环去重"><a href="#双重循环去重" class="headerlink" title="双重循环去重"></a>双重循环去重</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>, len = res.length; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[i] === res[j]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j === len) res.push(array[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;1&quot;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(uniq(arr)); <span class="comment">//[1, 2, &quot;3&quot;, &quot;2&quot;, &quot;1&quot;]</span></span><br></pre></td></tr></table></figure>

<h2 id="双循环去重优化"><a href="#双循环去重优化" class="headerlink" title="双循环去重优化"></a>双循环去重优化</h2><p>思路：获取没重复的最右一值放入新数组(判断值得右侧有无重复)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 推荐的方法</span></span><br><span class="line"><span class="comment"> * 效率较高</span></span><br><span class="line"><span class="comment"> * 实现思路：获取没重复的最右一值放入新数组。</span></span><br><span class="line"><span class="comment"> * （检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断）*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = [],</span><br><span class="line">    len = array.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[i] === array[j]) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        j = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(array[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IndexOf"><a href="#IndexOf" class="headerlink" title="IndexOf"></a>IndexOf</h2><p>利用 IndexOf 简化内层循环：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 新建一新数组，遍历传入数组，值不在新数组就push进该新数组中</span></span><br><span class="line"><span class="comment"> * IE8以下不支持数组的indexOf方法</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.indexOf(array[i]) === -<span class="number">1</span>) &#123;</span><br><span class="line">      res.push(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="排序后相邻去除法"><a href="#排序后相邻去除法" class="headerlink" title="排序后相邻去除法"></a>排序后相邻去除法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 给传入数组排序，排序后相同值相邻，</span></span><br><span class="line"><span class="comment"> * 然后遍历时,新数组只加入不与前一值重复的值。</span></span><br><span class="line"><span class="comment"> * 会打乱原来数组的顺序</span></span><br><span class="line"><span class="comment"> * [2, &quot;2&quot;, 2, &quot;2&quot;]排序会有问题</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  array.sort();</span><br><span class="line">  <span class="keyword">let</span> res = [array[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] !== array[i - <span class="number">1</span>]) &#123;</span><br><span class="line">      res.push(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象键值去重"><a href="#对象键值去重" class="headerlink" title="对象键值去重"></a>对象键值去重</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 速度最快， 占空间最多（空间换时间）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该方法执行的速度比其他任何方法都快， 就是占用的内存大一些。</span></span><br><span class="line"><span class="comment"> * 现思路：新建一js对象以及新数组，遍历传入数组时，判断值是否为js对象的键，</span></span><br><span class="line"><span class="comment"> * 不是的话给对象新增该键并放入新数组。</span></span><br><span class="line"><span class="comment"> * 注意点：判断是否为js对象键时，会自动对传入的键执行“toString()”，</span></span><br><span class="line"><span class="comment"> * 不同的键可能会被误认为一样，例如n[val]-- n[1]、n[&quot;1&quot;]；</span></span><br><span class="line"><span class="comment"> * 解决上述问题还是得调用“indexOf”。*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = [],</span><br><span class="line">    temp = &#123;&#125;;</span><br><span class="line">  array.forEach(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> type = <span class="keyword">typeof</span> val;</span><br><span class="line">    <span class="keyword">if</span> (!temp[val]) &#123;</span><br><span class="line">      temp[val] = [type];</span><br><span class="line">      res.push(val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp[val].indexOf(type) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      temp[val].push(type);</span><br><span class="line">      res.push(val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组下标法"><a href="#数组下标法" class="headerlink" title="数组下标法"></a>数组下标法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 实现思路：如果当前数组的第i项在当前数组中第一次出现的位置不是i，</span></span><br><span class="line"><span class="comment"> * 那么表示第i项是重复的，忽略掉。否则存入结果数组。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = [];</span><br><span class="line">  array.forEach(<span class="function">(<span class="params">v, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.indexOf(v) === i) &#123;</span><br><span class="line">      res.push(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>ES5 提供了 filter 方法，我们可以用来简化外层循环</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = array.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.indexOf(item) === index;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="利用-ES6-的-set"><a href="#利用-ES6-的-set" class="headerlink" title="利用 ES6 的 set"></a>利用 ES6 的 set</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用Array.from将Set结构转换成数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...new <span class="built_in">Set</span>(array)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>去重的方式有很多，我们需要知道在合适的场景要选择合适的方法，这样才能达到最优。</p>
]]></content>
      <categories>
        <category>JavaScript专题系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>六、JavaScript专题之数组取最大值和最小值</title>
    <url>/2020/03/06/jsspecial/%E6%95%B0%E7%BB%84%E5%8F%96%E6%9C%80%E5%80%BC/</url>
    <content><![CDATA[<p>数组取最大值、最小值的常用实现方式：</p>
<span id="more"></span>

<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">22</span>, <span class="number">15</span>, <span class="number">76</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr));</span><br></pre></td></tr></table></figure>

<h2 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">22</span>, <span class="number">15</span>, <span class="number">76</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  result = <span class="built_in">Math</span>.max(result, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>

<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">22</span>, <span class="number">15</span>, <span class="number">76</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...arr));</span><br></pre></td></tr></table></figure>

<h2 id="排序取值"><a href="#排序取值" class="headerlink" title="排序取值"></a>排序取值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">22</span>, <span class="number">15</span>, <span class="number">76</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">    .sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line">    .slice()</span><br><span class="line">    .pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(max(arr));</span><br></pre></td></tr></table></figure>

<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">22</span>, <span class="number">15</span>, <span class="number">76</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params">prev, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(prev, next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr.reduce(max));</span><br></pre></td></tr></table></figure>

<h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">22</span>, <span class="number">15</span>, <span class="number">76</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">eval</span>(<span class="string">&quot;Math.max(&quot;</span> + arr + <span class="string">&quot;)&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(max);</span><br></pre></td></tr></table></figure>

<p>暂时总结到这里，后续再补充。</p>
]]></content>
      <categories>
        <category>JavaScript专题系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>七、JavaScript专题之数组扁平化</title>
    <url>/2020/03/12/jsspecial/%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/</url>
    <content><![CDATA[<p>数组的扁平化，就是将一个嵌套多层的数组 array (嵌套可以是任何层数)转换为只有一层的数组。换句话说就是把多维数组转化成一维数组。</p>
<span id="more"></span>

<p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>,[<span class="string">&#x27;b&#x27;</span>,[<span class="string">&#x27;c&#x27;</span>]]]<span class="comment">//3 维数组</span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>,[<span class="string">&#x27;b&#x27;</span>,[<span class="string">&#x27;c&#x27;</span>,[.....]]]]<span class="comment">//n 维数组</span></span><br><span class="line"><span class="comment">// 转化为：</span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,...]</span><br></pre></td></tr></table></figure>

<p>通常我们都会用递归的方式来实现。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arr[i])) &#123;</span><br><span class="line">      result = result.concat(flatten(arr[i]));</span><br><span class="line">      <span class="comment">// result.push(...flatten(arr[i]))</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>

<p>利用 for 循环遍历数组的每一项并加以判断，如果不是数组，就执行 push 操作，是数组的化，就再次执行该函数（递归），直至遍历完整个数组。<br>ps: …和 concat()可以进行替换，所以完全可以算是 2 种方法。</p>
<h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (arr.some(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">    <span class="comment">// arr = [].concat(...arr);</span></span><br><span class="line">    arr = <span class="built_in">Array</span>.prototype.concat.apply([], arr);</span><br><span class="line">    <span class="built_in">console</span>.log(arr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>

<p>同理，利用 while 判断加上 some 的遍历来实现扁平化。</p>
<h2 id="reduce-方法"><a href="#reduce-方法" class="headerlink" title="reduce 方法"></a>reduce 方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> acc.concat(<span class="built_in">Array</span>.isArray(cur) ? flatten(cur) : cur);</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>

<h2 id="stack-方法"><a href="#stack-方法" class="headerlink" title="stack 方法"></a>stack 方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [...arr];</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">    <span class="keyword">let</span> first = stack.shift();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(first)) &#123;</span><br><span class="line">      stack.unshift(...first);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(first);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>

<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><p>如果全是数字，可以用 toString 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">    .toString()</span><br><span class="line">    .split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    .map(<span class="function">(<span class="params">item</span>) =&gt;</span> +item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>

<h2 id="flat"><a href="#flat" class="headerlink" title="flat"></a>flat</h2><p>es6 提供的新方法 flat(depth),参数 depth，代表展开嵌套数组的深度，默认是 1。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line">arr.flat(); <span class="comment">// [1, 2, 3, 4, [5, 6]]</span></span><br><span class="line">arr.flat(<span class="literal">Infinity</span>); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<p>depth 的值设置为 Infinity，无需知道数组的维度，直接将目标数组变成 1 维数组。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://juejin.cn/post/6844903805876699150">https://juejin.cn/post/6844903805876699150</a></p>
]]></content>
      <categories>
        <category>JavaScript专题系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>五、JavaScript专题之深浅拷贝</title>
    <url>/2020/02/26/jsspecial/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<p>本文主要记录一下深拷贝和浅拷贝的一些常用实现方式。</p>
<span id="more"></span>

<p>浅拷贝和深拷贝都只针对于引用数据类型，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存；但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象；<br>区别：浅拷贝只复制对象的第一层属性、深拷贝可以对对象的属性进行递归复制；</p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>常用方式：</p>
<ol>
<li>Object.assign 方法</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line">obj1.a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>for in 方法</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只复制第一层的浅拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleCopy</span>(<span class="params">obj1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj2 = <span class="built_in">Array</span>.isArray(obj1) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj1) &#123;</span><br><span class="line">    obj2[i] = obj1[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: &#123;</span><br><span class="line">    <span class="attr">d</span>: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = simpleCopy(obj1);</span><br><span class="line">obj2.a = <span class="number">3</span>;</span><br><span class="line">obj2.c.d = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// &#123;a:1, b:2, c:&#123;d:4&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>除了以上方法外，数组还有 slice, concat, 以及 ES6 提供的“…”运算符。当然这不是重点，重点是下面要说的深拷贝。</p>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><ol>
<li>通过 JSON 的序列化和反序列化来实现：parse、stringify:</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>, <span class="attr">dog</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;小黑&quot;</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(obj, newObj); <span class="comment">//&#123;name:&quot;张三&quot;,dog:&#123;name:&quot;小黑&quot;&#125;&#125; &#123;name:&quot;张三&quot;,dog:&#123;name:&quot;小黑&quot;&#125;&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj == newObj); <span class="comment">//false</span></span><br><span class="line">newObj.dog.name = <span class="string">&quot;小花&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj, newObj); <span class="comment">//&#123;name:&quot;张三&quot;,dog:&#123;name:&quot;小黑&quot;&#125;&#125; &#123;name:&quot;张三&quot;,dog:&#123;name:&quot;小花&quot;&#125;&#125;;</span></span><br></pre></td></tr></table></figure>

<p>上面这种方式能满足我们日常业务需要，但是他有一个缺点，就是会忽略 undefined、任意的函数、symbol 值，因为 JSON 不支持这些数据类型；</p>
<ol start="2">
<li>递归调用</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是&quot;纯粹的对象&quot;：</span></span><br><span class="line"><span class="comment"> * 该对象是通过 &quot;&#123;&#125;&quot; 或 &quot;new Object&quot; 创建的，该对象含有零个或者多个键值对</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> class2type = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> toString = class2type.toString;</span><br><span class="line"><span class="keyword">var</span> hasOwn = class2type.hasOwnProperty;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPlainObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> proto, Ctor;</span><br><span class="line">  <span class="keyword">if</span> (!obj || toString.call(obj) !== <span class="string">&quot;[object Object]&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  proto = <span class="built_in">Object</span>.getPrototypeOf(obj);</span><br><span class="line">  <span class="keyword">if</span> (!proto) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Ctor = hasOwn.call(proto, <span class="string">&quot;constructor&quot;</span>) &amp;&amp; proto.constructor;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="keyword">typeof</span> Ctor === <span class="string">&quot;function&quot;</span> &amp;&amp;</span><br><span class="line">    hasOwn.toString.call(Ctor) === hasOwn.toString.call(<span class="built_in">Object</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * extend</span></span><br><span class="line"><span class="comment"> * 内部方法：用户合并一个或多个对象到第一个对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;object&#125;</span> </span>target 目标对象  对象都合并到target里</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;source&#125;</span> </span>source 合并对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;boolean&#125;</span> </span>deep 是否执行深度合并</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">target, source, deep</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">    <span class="keyword">if</span> (deep &amp;&amp; (isPlainObject(source[key]) || <span class="built_in">Array</span>.isArray(source[key]))) &#123;</span><br><span class="line">      <span class="comment">// source[key] 是对象，而 target[key] 不是对象， 则 target[key] = &#123;&#125; 初始化一下，否则递归会出错的</span></span><br><span class="line">      <span class="keyword">if</span> (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key]))</span><br><span class="line">        target[key] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// source[key] 是数组，而 target[key] 不是数组，则 target[key] = [] 初始化一下，否则递归会出错的</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(source[key]) &amp;&amp; !<span class="built_in">Array</span>.isArray(target[key]))</span><br><span class="line">        target[key] = [];</span><br><span class="line">      <span class="comment">// 执行递归</span></span><br><span class="line">      extend(target[key], source[key], deep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不满足以上条件，说明 source[key] 是一般的值类型，直接赋值给 target 就是了</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (source[key] !== <span class="literal">undefined</span>) target[key] = source[key];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> deepClone = <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> deep,</span><br><span class="line">    args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第一个参数为boolean值时，表示是否深度合并</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target == <span class="string">&quot;boolean&quot;</span>) &#123;</span><br><span class="line">    deep = target;</span><br><span class="line">    <span class="comment">//target取第二个参数</span></span><br><span class="line">    target = args.shift();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历后面的参数，都合并到target上</span></span><br><span class="line">  args.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    extend(target, arg, deep);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="number">123</span>,<span class="attr">age</span>:<span class="number">123</span>,<span class="attr">c</span>:&#123;<span class="attr">d</span>:<span class="number">3</span>&#125;,<span class="attr">e</span>:&#123;<span class="attr">f</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;&#125;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = deepClone(<span class="literal">true</span>,&#123;&#125;, obj);</span><br><span class="line">obj2.c.d = <span class="number">12312</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj2);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript专题系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>三、JavaScript专题之类型判断(上)</title>
    <url>/2020/02/14/jsspecial/%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E4%B8%8A/</url>
    <content><![CDATA[<p>在项目开发中，我们经常会进行类型判断，这里对JS类型判断的方式进行一下总结。</p>
<span id="more"></span>
<p>在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures">MDN</a>中根据最新的 ECMAScript 标准定义了 8 种数据类型:</p>
<blockquote>
<p>基本类型（7种）：String, Number, Boolean, null, undefined, Bigint, Symbol。<br>引用类型（1种）：Object<br>下面我们来对这些类型进行检测。</p>
</blockquote>
<h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>typeof 操作符的唯一目的就是检查数据类型，但是如果我们希望检查任何从 Object 派生出来的结构类型，使用 typeof 是不起作用的，因为总是会得到 “object”。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>undefined</td>
<td>“undefined”</td>
</tr>
<tr>
<td>Boolean</td>
<td>“boolean”</td>
</tr>
<tr>
<td>Number</td>
<td>“number”</td>
</tr>
<tr>
<td>String</td>
<td>“string”</td>
</tr>
<tr>
<td>BigInt</td>
<td>“bigint”</td>
</tr>
<tr>
<td>Symbol</td>
<td>“symbol”</td>
</tr>
<tr>
<td>null</td>
<td>“object”</td>
</tr>
<tr>
<td>Function</td>
<td>“function”</td>
</tr>
<tr>
<td>其他任何对象</td>
<td>“object”</td>
</tr>
</tbody></table>
<p>注意：</p>
<ul>
<li>typeof Function: 结果是”function”，因为Function是一个构造函数，可以通过new操作符来构造对象</li>
<li>typeof null：结果是”object”，null是一个只有一个值的特殊类型。表示一个空对象引用。</li>
<li>typeof无法区分各种内置的对象，如Array, Date等。</li>
</ul>
<p>综上，typeof操作符能能返回的类型：</p>
<ul>
<li>string number boolean undefined symbol bigint</li>
<li>object 、(typeof null === ‘object’)</li>
<li>function</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>JS是动态类型的变量，每个变量在存储时除了存储变量值外，还需要存储变量的类型。JS里使用32位（bit）存储变量信息。低位的1~3个bit存储变量类型信息，叫做类型标签(type tag)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.... XXXX X000 <span class="comment">// object</span></span><br><span class="line">.... XXXX XXX1 <span class="comment">// int</span></span><br><span class="line">.... XXXX X010 <span class="comment">// double</span></span><br><span class="line">.... XXXX X100 <span class="comment">// string</span></span><br><span class="line">.... XXXX X110 <span class="comment">// boolean</span></span><br></pre></td></tr></table></figure>
<ul>
<li>只有int类型的type tag使用1个bit，并且取值为1，其他都是3个bit, 并且低位为0。这样可以通过type tag低位取值判断是否为int数据；</li>
<li>为了区分int，还剩下2个bit，相当于使用2个bit区分这四个类型：object, double, string, boolean；</li>
<li>但是null，undefined和Function并没有分配type tag。</li>
</ul>
<h4 id="如何识别Function"><a href="#如何识别Function" class="headerlink" title="如何识别Function"></a>如何识别Function</h4><p>函数并没有单独的type tag，因为函数也是对象。typeof内部判断如果一个对象实现了[[call]]内部方法则认为是函数。</p>
<h4 id="如何识别undefined"><a href="#如何识别undefined" class="headerlink" title="如何识别undefined"></a>如何识别undefined</h4><p>undefined变量存储的是个特殊值JSVAL_VOID（0-2^30），typeof内部判断如果一个变量存储的是这个特殊值，则认为是undefined。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#define JSVAL_VOID INT_TO_JSVAL(<span class="number">0</span> - JSVAL_INT_POW2(<span class="number">30</span>))</span><br></pre></td></tr></table></figure>
<h4 id="如何识别null"><a href="#如何识别null" class="headerlink" title="如何识别null"></a>如何识别null</h4><p>null变量存储的也是个特殊值JSVAL_NULL，并且恰巧取值是空指针机器码(0)，正好低位bit的值跟对象的type tag是一样的，这也是 <em>typeof null === ‘object’</em> 的原因。</p>
<h2 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>前面已经知道typeof Object 只会返回’object’,无法区分 Object 下细分的类型呐，如 Array、Function、Date、RegExp、Error 等。<br>所以我们一般使用Object.prototype.toString区分各种内置对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>)); <span class="comment">// [object Number]，隐式类型转换</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="string">&#x27;&#x27;</span>)); <span class="comment">// [object String]，隐式类型转换</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>)); <span class="comment">// [object Null]，特殊处理</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>)); <span class="comment">// [object Undefined]，特殊处理</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>)); <span class="comment">// [object Boolean]，隐式类型转换</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call( &#123;&#125;)); <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call([])); <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)); <span class="comment">// [object Function]</span></span><br></pre></td></tr></table></figure>
<ol>
<li>如果实参是个基本类型，会自动转成对应的引用类型;<blockquote>
<p>Object.prototype.toString不能区分基本类型的，只是用于区分各种对象；</p>
</blockquote>
</li>
<li>null和undefined不存在对应的引用类型，内部特殊处理了;</li>
</ol>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>每个对象都有个内部属性[[Class]]，内置对象的[[Class]]的值都是不同的（”Arguments”, “Array”, “Boolean”, “Date”, “Error”, “Function”, “JSON”, “Math”, “Number”, “Object”, “RegExp”, “String”），并且目前[[Class]]属性值只能通过Object.prototype.toString访问。</p>
<h4 id="Symbol-toStringTag属性"><a href="#Symbol-toStringTag属性" class="headerlink" title="Symbol.toStringTag属性"></a>Symbol.toStringTag属性</h4><p>其实Object.prototype.toString内部先访问对象的Symbol.toStringTag属性值拼接返回值的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(a)); <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改Symbol.toStringTag值</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">String</span>.prototype, <span class="built_in">Symbol</span>.toStringTag, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;MyString&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(a)); <span class="comment">// &quot;[object MyString]&quot;</span></span><br></pre></td></tr></table></figure>
<p>所以不要轻易修改内置对象的Symbol.toStringTag属性值，否则Object.prototype.toString就不能正常使用。</p>
<h4 id="Object-prototype-toString内部逻辑"><a href="#Object-prototype-toString内部逻辑" class="headerlink" title="Object.prototype.toString内部逻辑"></a>Object.prototype.toString内部逻辑</h4><p>在<a href="https://262.ecma-international.org/6.0/#sec-object.prototype.tostring">ECMA-262</a>规范中，第19.1.3.6 Object.prototype.toString ( )条介绍：</p>
<blockquote>
<p>When the toString toString method is called, the following steps are taken:</p>
<ol>
<li>If the this value is undefined, return “[object Undefined]”.</li>
<li>If the this value is null, return “[object Null]”.</li>
<li>Let O be ToObject(this value).</li>
<li>Let isArray be IsArray(O).</li>
<li>ReturnIfAbrupt(isArray).</li>
<li>If isArray is true, let builtinTag be “Array”.</li>
<li>Else, if O is an exotic String object, let builtinTag be “String”.</li>
<li>Else, if O has an [[ParameterMap]] internal slot, let builtinTag be “Arguments”.</li>
<li>Else, if O has a [[Call]] internal method, let builtinTag be “Function”.</li>
<li>Else, if O has an [[ErrorData]] internal slot, let builtinTag be “Error”.</li>
<li>Else, if O has a [[BooleanData]] internal slot, let builtinTag be “Boolean”.</li>
<li>Else, if O has a [[NumberData]] internal slot, let builtinTag be “Number”.</li>
<li>Else, if O has a [[DateValue]] internal slot, let builtinTag be “Date”.</li>
<li>Else, if O has a [[RegExpMatcher]] internal slot, let builtinTag be “RegExp”.</li>
<li>Else, let builtinTag be “Object”.</li>
<li>Let tag be Get (O, @@toStringTag).</li>
<li>ReturnIfAbrupt(tag).</li>
<li>If Type(tag) is not String, let tag be builtinTag.</li>
<li>Return the String that is the result of concatenating “[object “, tag, and “]”.</li>
</ol>
</blockquote>
<h2 id="Instanceof"><a href="#Instanceof" class="headerlink" title="Instanceof"></a>Instanceof</h2><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">object <span class="keyword">instanceof</span> <span class="title">constructorFunc</span></span><br></pre></td></tr></table></figure>
<p>instanceof 操作符判断构造函数constructorFunc的prototype属性是否在对象object的原型链上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create(&#123;&#125;) <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ol>
<li>作为类型判断的一种方式，instanceof 操作符不会对变量object进行隐式类型转换<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// false，基本类型不会转成对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;&#x27;</span>) <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li>对于没有原型的对象或则基本类型直接返回false<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
<li>constructorFunc必须是个对象。并且大部分情况要求是个构造函数（即要具有prototype属性）<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TypeError: Right-hand side of &#x27;instanceof&#x27; is not an object</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">instanceof</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeError: Right-hand side of &#x27;instanceof&#x27; is not callable</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">instanceof</span> (&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeError: Function has non-object prototype &#x27;undefined&#x27; in instanceof check</span></span><br><span class="line">(&#123;&#125;) <span class="keyword">instanceof</span> (<span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>参照<a href="https://tc39.es/ecma262/#sec-instanceofoperator">ECMA</a>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 如果constructorFunc不是个对象，或则是null，直接抛TypeError异常；</span><br><span class="line">2. 如果constructorFunc[Symbole.hasInstance]方法，则返回!!constructorFunc[Symbole.hasInstance](object )</span><br><span class="line">3. 如果constructorFunc不是函数，直接抛TypeError异常；</span><br><span class="line">4. 遍历object的原型链，逐个跟constructorFunc.prototype属性比较：</span><br><span class="line">   - 如果object没有原型，则直接返回false;</span><br><span class="line">   - 如果constructorFunc.prototype不是对象，则直接抛TypeError异常。</span><br></pre></td></tr></table></figure>

<h2 id="内置的类型判断方法"><a href="#内置的类型判断方法" class="headerlink" title="内置的类型判断方法"></a>内置的类型判断方法</h2><h3 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray"></a>Array.isArray</h3><p>ES5引入了方法Array.isArray专门用于数组类型判断。Object.prototype.toString和instanceof都不够严格</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Array</span>.prototype, <span class="built_in">Symbol</span>.toStringTag, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;myArray&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arr)); <span class="comment">// [object myArray]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arr)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(<span class="built_in">Array</span>.prototype)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>不过现实情况下基本都是利用Object.prototype.toString作为Array.isArray的polyfill:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.isArray = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(arg) === <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://bbs.huaweicloud.com/blogs/238951">https://bbs.huaweicloud.com/blogs/238951</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/28">https://github.com/mqyqingfeng/Blog/issues/28</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript专题系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>四、JavaScript专题之类型判断(下)</title>
    <url>/2020/02/18/jsspecial/%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E4%B8%8B/</url>
    <content><![CDATA[<p>上一篇文章中我们总结了类型判断的几种方式（typeof、Object.prototype.toString、Instanceof、isArray），这里我们写一个 type 函数来帮我们区分识别各种类型的值。</p>
<span id="more"></span>

<h2 id="基础函数-type"><a href="#基础函数-type" class="headerlink" title="基础函数 type"></a>基础函数 type</h2><p>首先，列出我们需要判断的常用类型（11 种）：Boolean Number String Function Array Date RegExp Object Error Null Undefined；<br>我们的目标是：type(123) // 得到：number;<br>这里我们通过 typeof 和 Object.prototype.toString 来分别处理基础类型和引用类型，由于 null 和 undefined 会被 Object.prototype.toString 识别成 [object Object]，所以它俩需要单独处理，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> class2type = &#123;&#125;;</span><br><span class="line"><span class="string">&quot;Boolean Number String Function Array Date RegExp Object Error&quot;</span></span><br><span class="line">  .split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">  .map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    class2type[<span class="string">&quot;[object &quot;</span> + item + <span class="string">&quot;]&quot;</span>] = item.toLowerCase();</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj + <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> obj === <span class="string">&quot;function&quot;</span></span><br><span class="line">    ? class2type[<span class="built_in">Object</span>.prototype.toString.call(obj)] || <span class="string">&quot;object&quot;</span> <span class="comment">// 这里主要处理新增的类型：Set Map等等</span></span><br><span class="line">    : <span class="keyword">typeof</span> obj;</span><br><span class="line">&#125;</span><br><span class="line">type(<span class="number">123</span>); <span class="comment">// &quot;number&quot;</span></span><br><span class="line">type(class2type); <span class="comment">// &quot;object&quot;</span></span><br><span class="line">type(type); <span class="comment">// &quot;function&quot;</span></span><br><span class="line">type(<span class="literal">null</span>); <span class="comment">// &quot;null&quot;</span></span><br><span class="line">type(<span class="regexp">/^\d+$/</span>); <span class="comment">// &quot;regexp&quot;</span></span><br><span class="line">type(<span class="keyword">new</span> <span class="built_in">Error</span>()); <span class="comment">// &quot;error&quot;</span></span><br><span class="line">type(<span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">// &quot;date&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="常用函数封装"><a href="#常用函数封装" class="headerlink" title="常用函数封装"></a>常用函数封装</h2><p>有了 type 函数后，我们就可以直接对常用函数进行封装</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> type(obj) === <span class="string">&quot;function&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isDate</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> type(obj) === <span class="string">&quot;date&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">var</span> isArray =</span><br><span class="line">  <span class="built_in">Array</span>.isArray ||</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> type(obj) === <span class="string">&quot;array&quot;</span>;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="isEmptyObject"><a href="#isEmptyObject" class="headerlink" title="isEmptyObject"></a>isEmptyObject</h2><p>判断是否是空对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmptyObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(isEmptyObject(&#123;&#125;)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isEmptyObject([])); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isEmptyObject(<span class="literal">null</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isEmptyObject(<span class="literal">undefined</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isEmptyObject(<span class="number">1</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isEmptyObject(<span class="string">&quot;&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isEmptyObject(<span class="literal">true</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="isWindow"><a href="#isWindow" class="headerlink" title="isWindow"></a>isWindow</h2><p>Window 对象作为客户端 JavaScript 的全局对象，它有一个 window 属性指向自身，基于这个特性来判断是否是 Window 对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isWindow</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj != <span class="literal">null</span> &amp;&amp; obj === obj.window;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="isElement"><a href="#isElement" class="headerlink" title="isElement"></a>isElement</h2><p>判断是否是 DOM 节点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isElement</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!(obj &amp;&amp; obj.nodeType === <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/30">https://github.com/mqyqingfeng/Blog/issues/30</a></li>
<li><a href="https://github.com/jquery/jquery/blob/ac9e3016645078e1e42120822cfb2076151c8cbe/src/core.js#L269">https://github.com/jquery/jquery/blob/ac9e3016645078e1e42120822cfb2076151c8cbe/src/core.js#L269</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript专题系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>一、JavaScript专题之防抖和节流</title>
    <url>/2020/01/12/jsspecial/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<p>在项目中，我们经常会绑定一些持续触发的事件，比如 resize、scroll、mousemove 等等，如果事件调用无限制，会加重浏览器负担，导致用户体验差，我们可以使用 debounce(防抖)和 throttle(节流)的方式来减少频繁的调用，同时也不会影响实际的效果。</p>
<span id="more"></span>

<h2 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖(debounce)"></a>防抖(debounce)</h2><p>防抖，顾名思义，防止抖动，指在一段时间内，不论触发多少次，都已最后一次为准。<br>换句话说，在触发事件后 n 秒后才执行函数，如果在 n 秒内再次触发了事件，则会重新计算函数执行时间。<br>总而言之，就是不管触发多少次，都要最后一次事件后 n 秒内不再触发事件，才会执行。<br>那么防抖有哪些应用场景呢？</p>
<ol>
<li>登录、发短信等按钮避免用户点击太快，以致于发送了多次请求，需要防抖；</li>
<li>调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖</li>
<li>文本编辑器实时保存，当无任何更改操作一秒后进行保存</li>
</ol>
<p>下面我们实现了一个简单的示例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">f, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      f(...args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> actionFun = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count++);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, debounce(actionFun, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>

<p>从上面代码可以看出<strong>防抖重在清零 clearTimeout(timer)</strong><br>接下来处理 this 的指向和 event 对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">f, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="built_in">this</span>;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      f.call(context, ...args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> actionFun = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count++); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">  <span class="built_in">console</span>.log(e); <span class="comment">// Event</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, debounce(actionFun, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>

<p>防抖函数可以分为立即执行和非立即执行版本：</p>
<ul>
<li>立即执行函数：立即执行就是触发事件后马上先执行一次，之后在设定 wait 时间内触犯的事件无效，不会执行，直到用户停止执行事件等待 wait 秒后才可以重新触发执行</li>
<li>非立即执行函数： 多次触发事件，只会在最后一次触发事件后等待设定的 wait 时间结束时执行一次。<br>下面我们增加一个参数 immediate 来判断是否立即执行：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc </span>函数防抖</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn 函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>wait 延迟执行毫秒数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>immediate true 表立即执行，false 表示非立即执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">f, wait, immediate = <span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer;</span><br><span class="line">  <span class="keyword">var</span> dobounced = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">      <span class="comment">// 如果已经执行过，则不再执行</span></span><br><span class="line">      <span class="keyword">var</span> callNow = !timer;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;, wait);</span><br><span class="line">      <span class="keyword">if</span> (callNow) f.call(context, ...args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        f.call(context, ...args);</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> actionFun = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count++); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">  <span class="built_in">console</span>.log(e); <span class="comment">// Event</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, debounce(actionFun, <span class="number">1000</span>, <span class="literal">true</span>));</span><br></pre></td></tr></table></figure>

<p>如过希望能取消 debounce 函数，比如说我 debounce 的时间间隔是 10 秒钟，immediate 为 true，这样的话，我只有等 10 秒后才能重新触发事件，现在我希望有一个按钮，点击后，取消防抖，这样我再去触发，就可以又立刻执行啦。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">f, wait, immediate = <span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer;</span><br><span class="line">  <span class="keyword">var</span> dobounced = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">      <span class="comment">// 如果已经执行过，则不再执行</span></span><br><span class="line">      <span class="keyword">var</span> callNow = !timer;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;, wait);</span><br><span class="line">      <span class="keyword">if</span> (callNow) f.call(context, ...args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        f.call(context, ...args);</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  dobounced.cancel = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    clearTimout(timer);</span><br><span class="line">    timer = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> dobounced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流 (throttle)"></a>节流 (throttle)</h2><p>节流，顾名思义，控制水的流量。控制事件发生的频率，如控制为 1s 发生一次，甚至 1 分钟发生一次。与服务端(server)及网关(gateway)控制的限流 (Rate Limit) 类似。<br>换句话说，连续触发事件但在 n 秒内只执行一次函数。<br>那么节流又有哪些应用场景呢？</p>
<ol>
<li>scroll 事件，每隔一秒计算一次位置信息等</li>
<li>浏览器播放事件，每个一秒计算一次进度信息等</li>
<li>input 框实时搜索并发送请求展示下拉列表，没隔一秒发送一次请求 (也可做防抖)</li>
</ol>
<p>关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。</p>
<h3 id="使用时间戳"><a href="#使用时间戳" class="headerlink" title="使用时间戳"></a>使用时间戳</h3><p>让我们来看第一种方法：使用时间戳，当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prev = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (now - prev &gt; wait) &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">      prev = now;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> actionFun = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count++); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">  <span class="built_in">console</span>.log(e); <span class="comment">// Event</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, throttle(actionFun, <span class="number">5000</span>));</span><br></pre></td></tr></table></figure>

<h3 id="使用定时器"><a href="#使用定时器" class="headerlink" title="使用定时器"></a>使用定时器</h3><p>接下来，我们讲讲第二种实现方式: 使用定时器,当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行结束，然后执行函数，清空定时器，这样就可以设置下个定时器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">        fn.apply(context, args);</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> actionFun = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count++); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">  <span class="built_in">console</span>.log(e); <span class="comment">// Event</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, throttle(actionFun, <span class="number">5000</span>));</span><br></pre></td></tr></table></figure>

<p>所以比较两个方法：</p>
<ul>
<li>第一种事件会立刻执行，第二种事件会在 n 秒后第一次执行</li>
<li>第一种事件停止触发后没有办法再执行事件，第二种事件停止触发后依然会再执行一次事件</li>
</ul>
<h3 id="节流优化"><a href="#节流优化" class="headerlink" title="节流优化"></a>节流优化</h3><p>现在我们将上面两种方法合并，既可以立刻执行，又可以停止触发的时候还能再执行一次。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer, context, args, result;</span><br><span class="line">  <span class="keyword">var</span> prev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    prev = <span class="built_in">Date</span>.now();</span><br><span class="line">    timer = <span class="literal">null</span>;</span><br><span class="line">    fn.apply(context, args);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下次触发剩余时间</span></span><br><span class="line">    <span class="keyword">var</span> remaining = wait - (now - prev);</span><br><span class="line"></span><br><span class="line">    context = <span class="built_in">this</span>;</span><br><span class="line">    args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="comment">// 如果没有剩余的时间或者修改了系统时间</span></span><br><span class="line">    <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      prev = now;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">      <span class="keyword">if</span> (!timer) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(later, remaining);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> throttled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> actionFun = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count++); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">  <span class="built_in">console</span>.log(e); <span class="comment">// Event</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, throttle(actionFun, <span class="number">5000</span>));</span><br></pre></td></tr></table></figure>

<p>现在，我需要能够自定义是否立刻执行、和是否可以停止触发的时候还能再执行一次，现在增加第三个参数 options，然后根据传值判断如何执行：</p>
<ul>
<li>leading: fasle，表示禁用立刻执行；</li>
<li>trailing: false，表示禁用停止触发的回调</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer, context, args, result;</span><br><span class="line">  <span class="keyword">var</span> prev = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    prev = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : <span class="built_in">Date</span>.now();</span><br><span class="line">    timer = <span class="literal">null</span>;</span><br><span class="line">    fn.apply(context, args);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!prev &amp;&amp; options.leading === <span class="literal">false</span>) prev = now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下次触发剩余时间</span></span><br><span class="line">    <span class="keyword">var</span> remaining = wait - (now - prev);</span><br><span class="line"></span><br><span class="line">    context = <span class="built_in">this</span>;</span><br><span class="line">    args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="comment">// 如果没有剩余的时间或者修改了系统时间</span></span><br><span class="line">    <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      prev = now;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">      <span class="keyword">if</span> (!timer) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timer &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(later, remaining);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> throttled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> actionFun = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count++); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">  <span class="built_in">console</span>.log(e); <span class="comment">// Event</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, throttle(actionFun, <span class="number">5000</span>, &#123;</span><br><span class="line">  <span class="attr">leading</span>: <span class="literal">false</span> </span><br><span class="line">&#125;));</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, throttle(actionFun, <span class="number">5000</span>, &#123;</span><br><span class="line">  <span class="attr">trailing</span>: <span class="literal">false</span> </span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>注意，这里leading和trailing不能同时设为false。<br>同样取消也是增加一个cancel函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">throttled.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    prev = <span class="number">0</span>;</span><br><span class="line">    timer = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://github.com/mqyqingfeng/Blog/issues/26">https://github.com/mqyqingfeng/Blog/issues/26</a></p>
]]></content>
      <categories>
        <category>JavaScript专题系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 下安装 nvm 管理 nodejs 版本</title>
    <url>/2021/08/12/node/nvm/</url>
    <content><![CDATA[<p>最近维护一个旧项目（祖传代码），由于本地 node 版本太高导致无法运行成功，然后尝试是用 nvm 来管理 node 版本切换，这里做下安装记录。</p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li>卸载 node，删除路径以及残留文件</li>
<li>安装 nvm-windows</li>
<li>安装 node</li>
<li>安装 nrm 配置镜像源</li>
</ol>
<h2 id="卸载-node"><a href="#卸载-node" class="headerlink" title="卸载 node"></a>卸载 node</h2><p>如果没有安装可以跳过本步骤。</p>
<ul>
<li>在卸载程序中卸载 node(控制面板\程序\程序和功能)。</li>
<li>在环境变量中删除所有与 node 相关的路径(无论是 user 级，还是 system 级)<br>删除以下路径的文件(可能只有部分文件才有) ,如:<br>C:\Program Files\nodejs<br>C:\Users{User}\AppData\Roaming\npm<br>C:\Users{User}\AppData\Roaming\npm-cache<br>C:\Users{User}\node_modules</li>
</ul>
<h2 id="安装-nvm"><a href="#安装-nvm" class="headerlink" title="安装 nvm"></a>安装 nvm</h2><p>nvm 是 nodejs 的版本管理工具，可以快速切换\更新 nodejs 版本。<br>windows 系统使用 <a href="https://github.com/coreybutler/nvm-windows/releases">nvm-windows</a>。安装时会需要选择两个安装目录，一个是 nvm 的目录，另一个是 node 的版本库目录，我这里分别用 D:\tools\nvm 和 D:\tools\nodejs。</p>
<p>安装完成检查是否成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;nvm version</span><br><span class="line">1.1.7</span><br></pre></td></tr></table></figure>

<h2 id="安装-node"><a href="#安装-node" class="headerlink" title="安装 node"></a>安装 node</h2><p>nvm 安装完后就可以开始管理 nodejs 的版本了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看线上所有版本</span><br><span class="line">nvm list available</span><br><span class="line"></span><br><span class="line"># 下载指定版本</span><br><span class="line">nvm install 14.15.0</span><br><span class="line"></span><br><span class="line"># 查看已安装的 node 版本</span><br><span class="line">nvm list</span><br><span class="line"></span><br><span class="line"># 切换版本</span><br><span class="line">nvm use 14.15.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这时就会在 D:\tools 的目录出现个 nodejs 的快捷方式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看node是否安装成功</span><br><span class="line">node -v</span><br></pre></td></tr></table></figure>

<p>如果显示 v14.15.0，那么就表示安装成功了。</p>
<h2 id="安装-nrm"><a href="#安装-nrm" class="headerlink" title="安装 nrm"></a>安装 nrm</h2><p>nrm 是管理 npm 源的，为了下载包更快。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装nrm</span><br><span class="line">npm install -g nrm</span><br><span class="line"></span><br><span class="line"># 列出可用源</span><br><span class="line">nrm ls</span><br><span class="line"></span><br><span class="line"># 切换源</span><br><span class="line">nrm use taobao</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>6.Z字形变换(N字形)。</title>
    <url>/2017/05/13/leetcode/Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行  Z 字形排列。</p>
<p>比如输入字符串为 “PAYPALISHIRING”  行数为 3 时，排列如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure>

<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;PAYPALISHIRING&quot;, numRows = 3</span><br><span class="line">输出：&quot;PAHNAPLSIIGYIR&quot;</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class="line">输出：&quot;PINALSIGYAHRPI&quot;</span><br><span class="line">解释：</span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;A&quot;, numRows = 1</span><br><span class="line">输出：&quot;A&quot;</span><br></pre></td></tr></table></figure>

<p>实现方法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">numRows</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> convert = <span class="function"><span class="keyword">function</span> (<span class="params">s, numRows</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (numRows === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> len = s.length;</span><br><span class="line">  <span class="comment">// 每个模块个数；</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">2</span> * numRows - <span class="number">2</span> || <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 可以划分几个模块</span></span><br><span class="line">  <span class="keyword">let</span> group = <span class="built_in">Math</span>.ceil(len / a);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; numRows; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; group; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> args = s.slice(i * a, (i + <span class="number">1</span>) * a);</span><br><span class="line">      result += args[j] || <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">if</span> (j !== <span class="number">0</span> &amp;&amp; j !== numRows - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; numRows &amp;&amp; args[a - j]) &#123;</span><br><span class="line">          result += args[a - j];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>15.三数之和</title>
    <url>/2017/05/18/leetcode/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>给你一个包含 n 个整数的数组  nums，判断  nums  中是否存在三个元素 a，b，c ，使得  a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<h3 id="暴力破解法"><a href="#暴力破解法" class="headerlink" title="暴力破解法:"></a>暴力破解法:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">let</span> zeroIndex = arr.findIndex(<span class="function">(<span class="params">e</span>) =&gt;</span> e &gt;= <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">let</span> minus = [];</span><br><span class="line">  <span class="keyword">let</span> plus = [];</span><br><span class="line">  minus = arr.slice(<span class="number">0</span>, zeroIndex);</span><br><span class="line">  plus = arr.slice(zeroIndex + <span class="number">1</span>, arr.length);</span><br><span class="line">  <span class="keyword">if</span> (arr[zeroIndex] === <span class="number">0</span>) &#123;</span><br><span class="line">    minus.push(<span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    plus.unshift(arr[zeroIndex]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; minus.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; minus.length; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> add = (minus[i] + minus[j]) * -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (plus.indexOf(add) !== -<span class="number">1</span>) &#123;</span><br><span class="line">        result[<span class="string">`<span class="subst">$&#123;minus[i]&#125;</span>,<span class="subst">$&#123;minus[j]&#125;</span>,<span class="subst">$&#123;add&#125;</span>`</span>] = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; plus.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; plus.length; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> add = (plus[i] + plus[j]) * -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (minus.indexOf(add) !== -<span class="number">1</span>) &#123;</span><br><span class="line">        result[<span class="string">`<span class="subst">$&#123;add&#125;</span>,<span class="subst">$&#123;plus[i]&#125;</span>,<span class="subst">$&#123;plus[j]&#125;</span>`</span>] = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.keys(result).map(<span class="function">(<span class="params">item</span>) =&gt;</span> item.split(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行结果：通过</span><br><span class="line"></span><br><span class="line">执行用时：6520 ms, 在所有 JavaScript 提交中击败了5.02%的用户</span><br><span class="line">内存消耗：52 MB, 在所有 JavaScript 提交中击败了5.02%的用户</span><br></pre></td></tr></table></figure>

<p>一顿操作猛如虎，击败用户百分五。看了题解有了下面的代码：</p>
<h3 id="排序-双指针："><a href="#排序-双指针：" class="headerlink" title="排序+双指针："></a>排序+双指针：</h3><p>思路</p>
<ul>
<li>数组遍历</li>
<li>首先对数组进行排序，排序后固定一个数 nums[i]，再使用左右指针指向 nums[i]后面的两端，数字分别为 nums[L]和 nums[R]，计算三个数的和 sum 判断是否满足为 0，满足则添加进结果集</li>
<li>如果 nums[i]大于 0，则三数之和必然无法等于 0，结束循环</li>
<li>如果 nums[i] == nums[i-1]，则说明该数字重复，会导致结果重复，所以应该跳过</li>
<li>当 sum == 0 时，nums[L] == nums[L+1] 则会导致结果重复，应该跳过，L++</li>
<li>当 sum == 0 时，nums[R] == nums[R−1] 则会导致结果重复，应该跳过，R–</li>
<li>时间复杂度：O(n^2)，n 为数组长度</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">const</span> len = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (nums == <span class="literal">null</span> || len &lt; <span class="number">3</span>) <span class="keyword">return</span> result;</span><br><span class="line">  nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 结束循环</span></span><br><span class="line">    <span class="keyword">if</span> (nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 去重</span></span><br><span class="line">    <span class="keyword">let</span> L = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> R = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">      <span class="keyword">let</span> sum = nums[i] + nums[L] + nums[R];</span><br><span class="line">      <span class="keyword">if</span> (sum === <span class="number">0</span>) &#123;</span><br><span class="line">        result.push([nums[L], nums[i], nums[R]]);</span><br><span class="line">        <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[L] == nums[L + <span class="number">1</span>]) L++; <span class="comment">// 去重</span></span><br><span class="line">        <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[R] == nums[R - <span class="number">1</span>]) R--; <span class="comment">// 去重</span></span><br><span class="line">        L++;</span><br><span class="line">        R--;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        L++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        R--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-数组</tag>
      </tags>
  </entry>
  <entry>
    <title>268. 丢失的数字</title>
    <url>/2017/05/26/leetcode/%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。</p>
<p>进阶：</p>
<ul>
<li>你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?</li>
</ul>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,0,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure>

<p>示例 3:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [9,6,4,2,3,5,7,0,1]</span><br><span class="line">输出：8</span><br><span class="line">解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure>

<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：1</span><br><span class="line">解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure>

<h3 id="先排序再循环"><a href="#先排序再循环" class="headerlink" title="先排序再循环"></a>先排序再循环</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> missingNumber = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = nums.length;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i !== nums[i]) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">if</span> (j !== nums[j - <span class="number">1</span>]) <span class="keyword">return</span> j;</span><br><span class="line">    i++;</span><br><span class="line">    j--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>原理: 对一个数进行两次完全相同的异或运算会得到原来的数，即：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a ^ b ^ b = a</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> missingNumber = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = nums.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    result ^= i ^ nums[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="高斯求和"><a href="#高斯求和" class="headerlink" title="高斯求和"></a>高斯求和</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> missingNumber = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = nums.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur);</span><br><span class="line">  result = (nums.length * (nums.length + <span class="number">1</span>)) / <span class="number">2</span> - result;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-数组</tag>
      </tags>
  </entry>
  <entry>
    <title>167. 两数之和 II - 输入有序数组</title>
    <url>/2017/05/24/leetcode/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20II%20-%20%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>给定一个已按照 升序排列   的整数数组  numbers ，请你从数组中找出两个数满足相加之和等于目标数  target 。</p>
<p>函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length 。</p>
<p>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：numbers = [2,7,11,15], target = 9</span><br><span class="line">输出：[1,2]</span><br><span class="line">解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：numbers = [2,3,4], target = 6</span><br><span class="line">输出：[1,3]</span><br></pre></td></tr></table></figure>

<p>示例 3:</p>
<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>一开始尝试循环暴力破解，然后就超时了。最后还是双指针实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">numbers</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span> (<span class="params">numbers, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = numbers.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    <span class="keyword">let</span> mul = target - numbers[i];</span><br><span class="line">    <span class="keyword">if</span> (mul &lt; numbers[j]) &#123;</span><br><span class="line">      j--;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mul &gt; numbers[j]) &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> [i + <span class="number">1</span>, j + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-数组</tag>
      </tags>
  </entry>
  <entry>
    <title>1.两数之和</title>
    <url>/2017/05/07/leetcode/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个整数数组 nums  和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那   两个   整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>

<p>常规方法：</p>
<blockquote>
<p>时间复杂度 O(n²)、空间复杂度 O(1)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> items = nums[i];</span><br><span class="line">    <span class="keyword">let</span> index = nums.indexOf(target - items, i + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (index !== -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> [i, index];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>哈希表的方式:</p>
<blockquote>
<p>时间复杂度 O(n)、空间复杂度 O(n)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map.has(target - nums[i])) &#123;</span><br><span class="line">      <span class="keyword">return</span> [map.get(target - nums[i]), i];</span><br><span class="line">    &#125;</span><br><span class="line">    map.set(nums[i], i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-数组</tag>
      </tags>
  </entry>
  <entry>
    <title>2.两数相加</title>
    <url>/2017/05/07/leetcode/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<p>给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照   逆序   的方式存储的，并且每个节点只能存储   一位   数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0  开头。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure>

<p>链表定义如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListNode</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.val = val;</span><br><span class="line">  <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入参数的封装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createListNode</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  nums += <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> row = <span class="keyword">new</span> ListNode(<span class="built_in">Number</span>(nums[i]));</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      row.next = result;</span><br><span class="line">    &#125;</span><br><span class="line">    result = row;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> l1 = createListNode(<span class="number">342</span>);</span><br><span class="line"><span class="keyword">let</span> l2 = createListNode(<span class="number">465</span>);</span><br></pre></td></tr></table></figure>

<p>实现方式:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">l2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> addTwoNumbers = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">new</span> ListNode(<span class="number">0</span>),</span><br><span class="line">    node = result;</span><br><span class="line">  <span class="keyword">while</span> (l1 || l2) &#123;</span><br><span class="line">    <span class="keyword">let</span> r = node.val,</span><br><span class="line">      i = (l1 &amp;&amp; l1.val) || <span class="number">0</span>,</span><br><span class="line">      j = (l2 &amp;&amp; l2.val) || <span class="number">0</span>,</span><br><span class="line">      sum = r + i + j,</span><br><span class="line">      m,</span><br><span class="line">      n;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      m = <span class="number">1</span>;</span><br><span class="line">      n = sum - <span class="number">10</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      m = <span class="number">0</span>;</span><br><span class="line">      n = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    l1 = l1 &amp;&amp; l1.next;</span><br><span class="line">    l2 = l2 &amp;&amp; l2.next;</span><br><span class="line">    node.val = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m || l1 || l2) &#123;</span><br><span class="line">      node.next = <span class="keyword">new</span> ListNode(m);</span><br><span class="line">      node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>122. 买卖股票的最佳时机 II</title>
    <url>/2017/05/21/leetcode/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II/</url>
    <content><![CDATA[<p>给定一个数组 prices ，其中  prices[i] 是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: prices = [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: prices = [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>

<h3 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">prices</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span> (<span class="params">prices</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> min = prices[<span class="number">0</span>],</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prices[i] &gt; min) &#123;</span><br><span class="line">      <span class="keyword">let</span> val = prices[i] - min;</span><br><span class="line">      result += val;</span><br><span class="line">      min = prices[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      min = prices[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>简化代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">prices</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span> (<span class="params">prices</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">      result += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-数组</tag>
      </tags>
  </entry>
  <entry>
    <title>121. 买卖股票的最佳时机</title>
    <url>/2017/05/21/leetcode/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<p>给定一个数组 prices ，它的第  i 个元素  prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>

<h3 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">prices</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span> (<span class="params">prices</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> min = prices[<span class="number">0</span>],</span><br><span class="line">    max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prices[i] &gt; min) &#123;</span><br><span class="line">      <span class="keyword">if</span> (prices[i] - min &gt; max) &#123;</span><br><span class="line">        max = prices[i] - min;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      min = prices[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-数组</tag>
      </tags>
  </entry>
  <entry>
    <title>23.删除有序数组中的重复项</title>
    <url>/2017/05/18/leetcode/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：2, nums = [1,2]</span><br><span class="line">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">输出：5, nums = [0,1,2,3,4]</span><br><span class="line">解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<h3 id="暴力破解法"><a href="#暴力破解法" class="headerlink" title="暴力破解法:"></a>暴力破解法:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">      nums.splice(i, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Set-去重："><a href="#Set-去重：" class="headerlink" title="Set 去重："></a>Set 去重：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> list = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(nums));</span><br><span class="line">  list.forEach(<span class="function">(<span class="params">el, i</span>) =&gt;</span> &#123;</span><br><span class="line">    nums[i] = el;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> list.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>思路： 这里使用快慢指针实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> fast = <span class="number">1</span>,</span><br><span class="line">    slow = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[fast] != nums[fast - <span class="number">1</span>]) &#123;</span><br><span class="line">      nums[slow] = nums[fast];</span><br><span class="line">      ++slow;</span><br><span class="line">    &#125;</span><br><span class="line">    ++fast;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> slow;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-数组</tag>
      </tags>
  </entry>
  <entry>
    <title>66. 加一</title>
    <url>/2017/05/19/leetcode/%E5%8A%A01/</url>
    <content><![CDATA[<p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = [1,2,3]</span><br><span class="line">输出：[1,2,4]</span><br><span class="line">解释：输入数组表示数字 123。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = [4,3,2,1]</span><br><span class="line">输出：[4,3,2,2]</span><br><span class="line">解释：输入数组表示数字 4321。</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = [0]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">digits</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> plusOne = <span class="function"><span class="keyword">function</span> (<span class="params">digits</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = digits.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    digits[i]++;</span><br><span class="line">    digits[i] %= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (digits[i] != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, ...digits];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-数组</tag>
      </tags>
  </entry>
  <entry>
    <title>88. 合并两个有序数组</title>
    <url>/2017/05/21/leetcode/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>给你两个按 非递减顺序 排列的整数数组  nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p>
<p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p>
<p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span><br><span class="line">输出：[1,2,2,3,5,6]</span><br><span class="line">解释：需要合并 [1,2,3] 和 [2,5,6] 。</span><br><span class="line">合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1], m = 1, nums2 = [], n = 0</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并 [1] 和 [] 。</span><br><span class="line">合并结果是 [1] 。</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [0], m = 0, nums2 = [1], n = 1</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并的数组是 [] 和 [1] 。</span><br><span class="line">合并结果是 [1] 。</span><br><span class="line">注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</span><br></pre></td></tr></table></figure>

<h3 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">m</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span> (<span class="params">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class="line">  nums1.splice(m, nums1.length - m, ...nums2);</span><br><span class="line">  nums1.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span> (<span class="params">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = m - <span class="number">1</span>,</span><br><span class="line">    j = n - <span class="number">1</span>,</span><br><span class="line">    cur = m + n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> isMax = i &gt;= <span class="number">0</span> &amp;&amp; nums1[i] &gt; nums2[j];</span><br><span class="line">    nums1[cur--] = isMax ? nums1[i--] : nums2[j--];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-数组</tag>
      </tags>
  </entry>
  <entry>
    <title>9.回文数</title>
    <url>/2017/05/16/leetcode/%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p>
<p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 121</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = -121</span><br><span class="line">输出：false</span><br><span class="line">解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = -101</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p>暴力破解方法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> s = <span class="built_in">String</span>(x);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] !== s[s.length - <span class="number">1</span> - i]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>数组倒序比较：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="built_in">String</span>(x);</span><br><span class="line">  <span class="keyword">let</span> reverseStr = str.split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> str === reverseStr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>反转一半数字：</p>
<p>如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。<br>例如，输入 1221，我们可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，因为二者相同，我们得知数字 1221 是回文。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 排除负数、10的倍数（0除外）</span></span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> === <span class="number">0</span> &amp;&amp; x !== <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> reverseNum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (x &gt; reverseNum) &#123;</span><br><span class="line">    reverseNum = reverseNum * <span class="number">10</span> + (x % <span class="number">10</span>);</span><br><span class="line">    x = <span class="built_in">Math</span>.floor(x / <span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">  <span class="keyword">return</span> x === reverseNum || x === <span class="built_in">Math</span>.floor(reverseNum / <span class="number">10</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>169. 多数元素</title>
    <url>/2017/05/25/leetcode/%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于  ⌊ n/2 ⌋  的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[3,2,3]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[2,2,1,1,1,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<h3 id="排序取值"><a href="#排序取值" class="headerlink" title="排序取值"></a>排序取值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> majorityElement = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">return</span> nums[(nums.length / <span class="number">2</span>) &gt;&gt; <span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Boyer-Moore-投票算法"><a href="#Boyer-Moore-投票算法" class="headerlink" title="Boyer-Moore 投票算法"></a>Boyer-Moore 投票算法</h3><p>摩尔投票法的核心就是对拼消耗。</p>
<p>玩一个诸侯争霸的游戏，假设你方人口超过总人口一半以上，并且能保证每个人口出去干仗都能一对一同归于尽。最后还有人活下来的国家就是胜利。</p>
<p>那就大混战呗，最差所有人都联合起来对付你（对应你每次选择作为计数器的数都是众数），或者其他国家也会相互攻击（会选择其他数作为计数器的数），但是只要你们不要内斗，最后肯定你赢。</p>
<p>最后能剩下的必定是自己人。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> candidate = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">      candidate = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    candidate === nums[i] ? count++ : count--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-数组</tag>
      </tags>
  </entry>
  <entry>
    <title>136. 只出现一次的数字</title>
    <url>/2017/05/24/leetcode/%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<h3 id="循环-二分法-查找"><a href="#循环-二分法-查找" class="headerlink" title="循环(二分法)查找"></a>循环(二分法)查找</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> singleNumber = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = nums.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    <span class="keyword">let</span> mid = (j + i) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] !== nums[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mid % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        i = mid;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        j = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] !== nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mid % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">        j = mid;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums[i];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="对象唯一属性"><a href="#对象唯一属性" class="headerlink" title="对象唯一属性"></a>对象唯一属性</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumber = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj[nums[i]]) &#123;</span><br><span class="line">      <span class="keyword">delete</span> obj[nums[i]];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      obj[nums[i]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但题目中要求时间复杂度 O(n)，空间复杂度是 O(1)，看了题解，答案是使用位运算。对于这道题，可使用异或运算 ⊕。异或运算有以下三个性质。</p>
<ol>
<li>任何数和 0 做异或运算，结果仍然是原来的数，即 a⊕0=a。</li>
<li>任何数和其自身做异或运算，结果是 0，即 a⊕a=0。</li>
<li>异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b</li>
</ol>
<h3 id="异或预算"><a href="#异或预算" class="headerlink" title="异或预算"></a>异或预算</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumber = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> nums.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x ^ y);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-数组</tag>
      </tags>
  </entry>
  <entry>
    <title>8.字符串转换整数 (atoi)</title>
    <url>/2017/05/16/leetcode/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0%20(atoi)/</url>
    <content><![CDATA[<p>请你来实现一个  myAtoi(string s)  函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。</p>
<p>函数  myAtoi(string s) 的算法如下：</p>
<blockquote>
<p>读入字符串并丢弃无用的前导空格<br>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。<br>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。<br>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。<br>如果整数数超过 32 位有符号整数范围 [−2^31,  2^31 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −2^31 的整数应该被固定为 −2^31 ，大于 2^31 − 1 的整数应该被固定为 2^31 − 1 。<br>返回整数作为最终结果。</p>
</blockquote>
<p>注意：</p>
<blockquote>
<p>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。</p>
</blockquote>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;42&quot;</span><br><span class="line">输出：42</span><br><span class="line">解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。</span><br><span class="line">第 1 步：&quot;42&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;42&quot;（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;42&quot;（读入 &quot;42&quot;）</span><br><span class="line">           ^</span><br><span class="line">解析得到整数 42 。</span><br><span class="line">由于 &quot;42&quot; 在范围 [-2^31, 2^31 - 1] 内，最终结果为 42 。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;   -42&quot;</span><br><span class="line">输出：-42</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;   -42&quot;（读入前导空格，但忽视掉）</span><br><span class="line">            ^</span><br><span class="line">第 2 步：&quot;   -42&quot;（读入 &#x27;-&#x27; 字符，所以结果应该是负数）</span><br><span class="line">             ^</span><br><span class="line">第 3 步：&quot;   -42&quot;（读入 &quot;42&quot;）</span><br><span class="line">               ^</span><br><span class="line">解析得到整数 -42 。</span><br><span class="line">由于 &quot;-42&quot; 在范围 [-2^31, 2^31 - 1] 内，最终结果为 -42 。</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;4193 with words&quot;</span><br><span class="line">输出：4193</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;4193 with words&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;4193 with words&quot;（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;4193 with words&quot;（读入 &quot;4193&quot;；由于下一个字符不是一个数字，所以读入停止）</span><br><span class="line">             ^</span><br><span class="line">解析得到整数 4193 。</span><br><span class="line">由于 &quot;4193&quot; 在范围 [-2^31, 2^31 - 1] 内，最终结果为 4193 。</span><br></pre></td></tr></table></figure>

<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;words and 987&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;words and 987&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;words and 987&quot;（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;words and 987&quot;（由于当前字符 &#x27;w&#x27; 不是一个数字，所以读入停止）</span><br><span class="line">         ^</span><br><span class="line">解析得到整数 0 ，因为没有读入任何数字。</span><br><span class="line">由于 0 在范围 [-2^31, 2^31 - 1] 内，最终结果为 0 。</span><br></pre></td></tr></table></figure>

<p>示例  5：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;-91283472332&quot;</span><br><span class="line">输出：-2147483648</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;-91283472332&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;-91283472332&quot;（读入 &#x27;-&#x27; 字符，所以结果应该是负数）</span><br><span class="line">          ^</span><br><span class="line">第 3 步：&quot;-91283472332&quot;（读入 &quot;91283472332&quot;）</span><br><span class="line">                     ^</span><br><span class="line">解析得到整数 -91283472332 。</span><br><span class="line">由于 -91283472332 小于范围 [-2^31, 2^31 - 1] 的下界，最终结果被截断为 -2^31 = -2147483648 。</span><br></pre></td></tr></table></figure>
<p>暴力破解方法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> myAtoi = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> INT_MAX = <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> INT_MIN = -(<span class="number">2</span> ** <span class="number">31</span>);</span><br><span class="line">  s = s.match(<span class="regexp">/^\s*([-+]?\d+)/g</span>);</span><br><span class="line">  <span class="keyword">let</span> num = s ? <span class="built_in">Number</span>(s[<span class="number">0</span>]) : <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (num &gt; INT_MAX) &#123;</span><br><span class="line">    <span class="keyword">return</span> INT_MAX;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; INT_MIN) &#123;</span><br><span class="line">    <span class="keyword">return</span> INT_MIN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>219. 存在重复元素 II</title>
    <url>/2017/05/26/leetcode/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20II/</url>
    <content><![CDATA[<p>给定一个整数数组和一个整数  k，判断数组中是否存在两个不同的索引  i  和  j，使得  nums [i] = nums [j]，并且 i 和 j  的差的 绝对值 至多为 k。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,2,3,1], k = 3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,0,1,1], k = 1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p>示例 3:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,2,3,1,2,3], k = 2</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<h3 id="暴力破解法"><a href="#暴力破解法" class="headerlink" title="暴力破解法"></a>暴力破解法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> containsNearbyDuplicate = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt;= i + k; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] === nums[j]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="利用-Map"><a href="#利用-Map" class="headerlink" title="利用 Map"></a>利用 Map</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> containsNearbyDuplicate = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = map.get(nums[i]);</span><br><span class="line">    <span class="keyword">if</span> (j === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      map.set(nums[i], i);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i - j &lt;= k) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      map.set(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-数组</tag>
      </tags>
  </entry>
  <entry>
    <title>217. 存在重复元素</title>
    <url>/2017/05/25/leetcode/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p>示例 3:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> containsDuplicate = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Set</span>(nums).size != nums.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-数组</tag>
      </tags>
  </entry>
  <entry>
    <title>4.寻找两个正序数组的中位数</title>
    <url>/2017/05/10/leetcode/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,3], nums2 = [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,2], nums2 = [3,4]</span><br><span class="line">输出：2.50000</span><br><span class="line">解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出：0.00000</span><br></pre></td></tr></table></figure>

<p>实现方式一:</p>
<blockquote>
<p>时间复杂度：遍历全部数组 O(m+n)；空间复杂度：开辟了一个数组，保存合并后的两个数组 O(m+n)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findMedianSortedArrays = <span class="function"><span class="keyword">function</span> (<span class="params">nums1, nums2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = nums1.concat(nums2);</span><br><span class="line">  arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">if</span> (arr.length % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (arr[arr.length / <span class="number">2</span>] + arr[arr.length / <span class="number">2</span> - <span class="number">1</span>]) / <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arr[(arr.length - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解法二：</p>
<blockquote>
<p>时间复杂度依旧是 O(m+n)；空间复杂度 O(1)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findMedianSortedArrays = <span class="function"><span class="keyword">function</span> (<span class="params">nums1, nums2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m = nums1.length;</span><br><span class="line">  <span class="keyword">var</span> n = nums2.length;</span><br><span class="line">  <span class="keyword">var</span> len = m + n,</span><br><span class="line">    left = <span class="number">0</span>,</span><br><span class="line">    right = <span class="number">0</span>,</span><br><span class="line">    aStart = <span class="number">0</span>,</span><br><span class="line">    bStart = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= len / <span class="number">2</span>; i++) &#123;</span><br><span class="line">    left = right;</span><br><span class="line">    <span class="keyword">if</span> (aStart &lt; m &amp;&amp; (bStart &gt;= n || nums1[aStart] &lt; nums2[bStart])) &#123;</span><br><span class="line">      right = nums1[aStart++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right = nums2[bStart++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (len % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解法三：</p>
<blockquote>
<p>时间复杂度依旧是 O(log(m+n))，空间复杂度 O(1)。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums1</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums2</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findMedianSortedArrays = <span class="function"><span class="keyword">function</span> (<span class="params">nums1, nums2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = nums1.length;</span><br><span class="line">  <span class="keyword">var</span> m = nums2.length;</span><br><span class="line">  <span class="keyword">var</span> left = <span class="built_in">Math</span>.floor((n + m + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">var</span> right = <span class="built_in">Math</span>.floor((n + m + <span class="number">2</span>) / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    (getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, left) +</span><br><span class="line">      getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, right)) *</span><br><span class="line">    <span class="number">0.5</span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getKth</span>(<span class="params">nums1, start1, end1, nums2, start2, end2, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len1 = end1 - start1 + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> len2 = end2 - start2 + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (len1 &gt; len2) <span class="keyword">return</span> getKth(nums2, start2, end2, nums1, start1, end1, k);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (len1 == <span class="number">0</span>) <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">Math</span>.min(nums1[start1], nums2[start2]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> i = start1 + <span class="built_in">Math</span>.min(len1, <span class="built_in">Math</span>.floor(k / <span class="number">2</span>)) - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> j = start2 + <span class="built_in">Math</span>.min(len2, <span class="built_in">Math</span>.floor(k / <span class="number">2</span>)) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">    <span class="keyword">return</span> getKth(</span><br><span class="line">      nums1,</span><br><span class="line">      start1,</span><br><span class="line">      end1,</span><br><span class="line">      nums2,</span><br><span class="line">      j + <span class="number">1</span>,</span><br><span class="line">      end2,</span><br><span class="line">      k - (j - start2 + <span class="number">1</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getKth(</span><br><span class="line">      nums1,</span><br><span class="line">      i + <span class="number">1</span>,</span><br><span class="line">      end1,</span><br><span class="line">      nums2,</span><br><span class="line">      start2,</span><br><span class="line">      end2,</span><br><span class="line">      k - (i - start1 + <span class="number">1</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-数组</tag>
      </tags>
  </entry>
  <entry>
    <title>108. 将有序数组转换为二叉搜索树</title>
    <url>/2017/05/21/leetcode/%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<p>给你两个按 非递减顺序 排列的整数数组  nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p>
<p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p>
<p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span><br><span class="line">输出：[1,2,2,3,5,6]</span><br><span class="line">解释：需要合并 [1,2,3] 和 [2,5,6] 。</span><br><span class="line">合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1], m = 1, nums2 = [], n = 0</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并 [1] 和 [] 。</span><br><span class="line">合并结果是 [1] 。</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [0], m = 0, nums2 = [1], n = 1</span><br><span class="line">输出：[1]</span><br><span class="line">解释：需要合并的数组是 [] 和 [1] 。</span><br><span class="line">合并结果是 [1] 。</span><br><span class="line">注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> sortedArrayToBST = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helper</span>(<span class="params">nums, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> mid = <span class="built_in">Math</span>.ceil((left + right) / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">let</span> root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">  root.left = helper(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">  root.right = helper(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-数组</tag>
      </tags>
  </entry>
  <entry>
    <title>35.搜索插入位置</title>
    <url>/2017/05/19/leetcode/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 O(log n) 的算法。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<h3 id="暴力破解法"><a href="#暴力破解法" class="headerlink" title="暴力破解法"></a>暴力破解法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> searchInsert = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt;= target) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法:"></a>二分法:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> searchInsert = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>,</span><br><span class="line">    j = len - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> result = len;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">    <span class="keyword">let</span> mid = ((j - i) &gt;&gt; <span class="number">1</span>) + i;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">      result = mid;</span><br><span class="line">      j = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      i = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-数组</tag>
      </tags>
  </entry>
  <entry>
    <title>7.整数反转</title>
    <url>/2017/05/13/leetcode/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：x = 123</span><br><span class="line">输出：321</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure>

<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ac&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>

<p>暴力破解方法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">x</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverse = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="built_in">String</span>(<span class="built_in">Math</span>.abs(x));</span><br><span class="line">  <span class="keyword">let</span> len = str.length;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    result = <span class="string">&quot;-&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    result += str[len - i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="built_in">Number</span>(result);</span><br><span class="line">  <span class="keyword">if</span> (b &lt;= <span class="number">2147483647</span> &amp;&amp; b &gt;= -<span class="number">2147483648</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverse = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (x !== <span class="number">0</span>) &#123;</span><br><span class="line">    n = n * <span class="number">10</span> + (x % <span class="number">10</span>);</span><br><span class="line">    x = ~~(x / <span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span> &amp;&amp; n &lt; -(<span class="number">2</span> ** <span class="number">31</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法三：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverse = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> point = x &gt;= <span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> absNumString = <span class="built_in">String</span>(<span class="built_in">Math</span>.abs(x));</span><br><span class="line">  <span class="keyword">let</span> result =</span><br><span class="line">    <span class="built_in">Array</span>.prototype.reduceRight.call(absNumString, <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;) * point;</span><br><span class="line">  <span class="keyword">if</span> (result &gt;= -(<span class="number">2</span> ** <span class="number">31</span>) &amp;&amp; result &lt;= <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>3.无重复字符的最长子串</title>
    <url>/2017/05/09/leetcode/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>

<p>实现方式:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = s.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    set.add(s.charAt(i));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (set.has(s.charAt(j))) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      set.add(s.charAt(j));</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="built_in">Math</span>.max(result, set.size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>53.最大子序和</title>
    <url>/2017/05/19/leetcode/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<h3 id="暴力破解法"><a href="#暴力破解法" class="headerlink" title="暴力破解法"></a>暴力破解法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> max = nums[i];</span><br><span class="line">    <span class="keyword">let</span> add = nums[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">      add += nums[j];</span><br><span class="line">      max = <span class="built_in">Math</span>.max(max, add);</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="built_in">Math</span>.max(result, max);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划:"></a>动态规划:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      sum += nums[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sum = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="built_in">Math</span>.max(result, sum);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-数组</tag>
      </tags>
  </entry>
  <entry>
    <title>5.无重复字符的最长子串</title>
    <url>/2017/05/12/leetcode/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p>给你一个字符串 s，找到 s 中最长的回文子串。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>

<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ac&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>

<p>暴力破解方法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = s.length;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt;= len; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> str = s.slice(i, j);</span><br><span class="line">      <span class="keyword">if</span> (str.length &gt; max &amp;&amp; isPalindromic(str)) &#123;</span><br><span class="line">        max = str.length;</span><br><span class="line">        result = str;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isPalindromic = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] !== s[s.length - <span class="number">1</span> - i]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最长公共子串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">let</span> reverse = s.split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> maxLen = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> maxEnd = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    arr[i] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; reverse.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s[i] === reverse[j]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i === <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">          arr[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          arr[i][j] = arr[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[i][j] &gt; maxLen) &#123;</span><br><span class="line">          <span class="keyword">let</span> beforeRev = s.length - <span class="number">1</span> - j;</span><br><span class="line">          <span class="comment">//判断下标是否对应</span></span><br><span class="line">          <span class="keyword">if</span> (beforeRev + arr[i][j] - <span class="number">1</span> === i) &#123;</span><br><span class="line">            maxLen = arr[i][j];</span><br><span class="line">            maxEnd = i;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        arr[i][j] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s.slice(maxEnd + <span class="number">1</span> - maxLen, maxEnd + <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>119. 杨辉三角 II</title>
    <url>/2017/05/21/leetcode/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%20II/</url>
    <content><![CDATA[<p>给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。</p>
<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<p><img src="https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif" alt="杨辉三角"></p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: rowIndex = 3</span><br><span class="line">输出: [1,3,3,1]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: rowIndex = 0</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure>

<h3 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">rowIndex</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getRow = <span class="function"><span class="keyword">function</span> (<span class="params">rowIndex</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [],</span><br><span class="line">    cur = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rowIndex + <span class="number">1</span>; i++) &#123;</span><br><span class="line">    cur = <span class="keyword">new</span> <span class="built_in">Array</span>(i + <span class="number">1</span>).fill(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">      cur[j] = result[j - <span class="number">1</span>] + [j];</span><br><span class="line">    &#125;</span><br><span class="line">    result = cur;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="线性递推"><a href="#线性递推" class="headerlink" title="线性递推"></a>线性递推</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getRow = <span class="function"><span class="keyword">function</span> (<span class="params">rowIndex</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> row = <span class="keyword">new</span> <span class="built_in">Array</span>(rowIndex + <span class="number">1</span>).fill(<span class="number">0</span>);</span><br><span class="line">  row[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= rowIndex; ++i) &#123;</span><br><span class="line">    row[i] = (row[i - <span class="number">1</span>] * (rowIndex - i + <span class="number">1</span>)) / i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> row;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-数组</tag>
      </tags>
  </entry>
  <entry>
    <title>118. 杨辉三角</title>
    <url>/2017/05/21/leetcode/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</url>
    <content><![CDATA[<p>给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。</p>
<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<p><img src="https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif" alt="杨辉三角"></p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: numRows = 5</span><br><span class="line">输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: numRows = 1</span><br><span class="line">输出: [[1]]</span><br></pre></td></tr></table></figure>

<h3 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">numRows</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> generate = <span class="function"><span class="keyword">function</span> (<span class="params">numRows</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(i + <span class="number">1</span>).fill(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">      arr[j] = result[i - <span class="number">1</span>][j - <span class="number">1</span>] + result[i - <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(arr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-数组</tag>
      </tags>
  </entry>
  <entry>
    <title>10.正则表达式匹配</title>
    <url>/2017/05/17/leetcode/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>给你一个字符串  s  和一个字符规律  p，请你来实现一个支持 ‘.’  和  ‘*‘  的正则表达式匹配。</p>
<p>‘.’ 匹配任意单个字符<br>‘*‘ 匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖   整个   字符串  s 的，而不是部分字符串。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aa&quot; p = &quot;a&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：&quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aa&quot; p = &quot;a*&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：因为 &#x27;*&#x27; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#x27;a&#x27;。因此，字符串 &quot;aa&quot; 可被视为 &#x27;a&#x27; 重复了一次。</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ab&quot; p = &quot;.*&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：&quot;.*&quot; 表示可匹配零个或多个（&#x27;*&#x27;）任意字符（&#x27;.&#x27;）。</span><br></pre></td></tr></table></figure>

<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aab&quot; p = &quot;c*a*b&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：因为 &#x27;*&#x27; 表示零个或多个，这里 &#x27;c&#x27; 为 0 个, &#x27;a&#x27; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure>

<p>示例 5：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;mississippi&quot; p = &quot;mis*is*p*.&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p>取巧通过方法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">s</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">p</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isMatch = <span class="function"><span class="keyword">function</span> (<span class="params">s, p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`^<span class="subst">$&#123;p&#125;</span>$`</span>);</span><br><span class="line">  <span class="keyword">return</span> reg.test(s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的方法虽然能过，但这不是出题的本意，下面我们换一种实现方式。</p>
<p>动态规划：</p>
<!-- TODO 待补充 -->


]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>11.盛最多水的容器</title>
    <url>/2017/05/17/leetcode/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点  (i, ai) 。在坐标内画 n 条垂直线，垂直线 i  的两个端点分别为  (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与  x  轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器。</p>
<p>示例 1：</p>
<p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="示例图"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49</span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。</span><br><span class="line">在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [4,3,2,1,4]</span><br><span class="line">输出：16</span><br></pre></td></tr></table></figure>

<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：height = [1,2,1]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p>暴力破解法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">height</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxArea = <span class="function"><span class="keyword">function</span> (<span class="params">height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = height.length;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> area = (j - i) * <span class="built_in">Math</span>.min(height[i], height[j]);</span><br><span class="line">      max = <span class="built_in">Math</span>.max(max, area);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面的方法虽然功能实现了，但是不能 AC（因为超时了），所以我们得换一种实现方式。</p>
<p>双指针：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxArea = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = height.length;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">      , j = len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i !== j) &#123;</span><br><span class="line">        <span class="keyword">let</span> area = (j - i) * <span class="built_in">Math</span>.min(height[i], height[j]);</span><br><span class="line">        max = <span class="built_in">Math</span>.max(max, area);</span><br><span class="line">        <span class="keyword">if</span> (height[i] &lt;= height[j]) &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-数组</tag>
      </tags>
  </entry>
  <entry>
    <title>283. 移动零</title>
    <url>/2017/05/26/leetcode/%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>

<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> moveZeroes = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] === <span class="number">0</span>) &#123;</span><br><span class="line">      nums.splice(i, <span class="number">1</span>);</span><br><span class="line">      nums.push(<span class="number">0</span>);</span><br><span class="line">      len--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="左右排序右侧补-0"><a href="#左右排序右侧补-0" class="headerlink" title="左右排序右侧补 0"></a>左右排序右侧补 0</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> moveZeroes = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] !== <span class="number">0</span>) &#123;</span><br><span class="line">      nums[start++] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (start &lt; nums.length) &#123;</span><br><span class="line">    nums[start++] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-数组</tag>
      </tags>
  </entry>
  <entry>
    <title>228. 汇总区间</title>
    <url>/2017/05/26/leetcode/%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<p>给定一个无重复元素的有序整数数组 nums 。</p>
<p>返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。</p>
<p>列表中的每个区间范围 [a,b] 应该按如下格式输出：</p>
<p>“a-&gt;b” ，如果 a != b<br>“a” ，如果 a == b</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,2,4,5,7]</span><br><span class="line">输出：[&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[0,2] --&gt; &quot;0-&gt;2&quot;</span><br><span class="line">[4,5] --&gt; &quot;4-&gt;5&quot;</span><br><span class="line">[7,7] --&gt; &quot;7&quot;</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,2,3,4,6,8,9]</span><br><span class="line">输出：[&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[0,0] --&gt; &quot;0&quot;</span><br><span class="line">[2,4] --&gt; &quot;2-&gt;4&quot;</span><br><span class="line">[6,6] --&gt; &quot;6&quot;</span><br><span class="line">[8,9] --&gt; &quot;8-&gt;9&quot;</span><br></pre></td></tr></table></figure>

<p>示例 3:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1]</span><br><span class="line">输出：[&quot;-1&quot;]</span><br></pre></td></tr></table></figure>

<p>示例 5：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[&quot;0&quot;]</span><br></pre></td></tr></table></figure>

<h3 id="暴力破解法"><a href="#暴力破解法" class="headerlink" title="暴力破解法"></a>暴力破解法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;string[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> summaryRanges = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] + <span class="number">1</span> !== nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">      result.push(ans === nums[i] ? <span class="string">`<span class="subst">$&#123;ans&#125;</span>`</span> : <span class="string">`<span class="subst">$&#123;ans&#125;</span>-&gt;<span class="subst">$&#123;nums[i]&#125;</span>`</span>);</span><br><span class="line">      ans = nums[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-数组</tag>
      </tags>
  </entry>
  <entry>
    <title>27.移除元素</title>
    <url>/2017/05/18/leetcode/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>给你一个数组 nums  和一个值 val，你需要 原地 移除所有数值等于  val  的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2]</span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<h3 id="暴力破解法"><a href="#暴力破解法" class="headerlink" title="暴力破解法:"></a>暴力破解法:</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">nums, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; nums.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">      nums.splice(i, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>思路： 这里使用快慢指针实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">nums, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> fast = <span class="number">0</span>,</span><br><span class="line">    slow = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (fast &lt; n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[fast] != val) &#123;</span><br><span class="line">      nums[slow] = nums[fast];</span><br><span class="line">      ++slow;</span><br><span class="line">    &#125;</span><br><span class="line">    ++fast;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> slow;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-数组</tag>
      </tags>
  </entry>
  <entry>
    <title>204. 计数质数</title>
    <url>/2017/05/25/leetcode/%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/</url>
    <content><![CDATA[<p>统计所有小于非负整数 n 的质数的数量。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 10</span><br><span class="line">输出：4</span><br><span class="line">解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p>示例 3:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> countPrimes = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">    ans += isPrime(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> isPrime = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i * i &lt;= x; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x % i === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode题库</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LeetCode-数组</tag>
      </tags>
  </entry>
</search>
