<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AJAX的XMLHttpRequest对象使用</title>
    <url>/2016/05/20/AJAX%E7%9A%84XMLHttpRequest%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3></blockquote>
<span id="more"></span>
<blockquote>
<pre><code>   //1 创建XHR对象
    var xhr = null;
    if(window.XMLHttpRequest)&#123;  //新IE、其它浏览器
        xhr = new XMLHttpRequest();  
    &#125;else &#123; //老IE
        xhr = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;);
    &#125;
//2 监听XHR的状态改变
    xhr.onreadystatechange = function()&#123;
      if(xhr.readyState===4)&#123; //DONE响应消息接收完成
        if(xhr.status===200)&#123;
          console.log(&#39;响应接收完成且成功&#39;);
          console.log(&#39;响应主体：&#39;+xhr.responseText);
          doResponse(xhr.responseText);//调用自定义的函数，处理响应数据
        &#125;else &#123;
          console.log(&#39;响应接收完成但不成功&#39;);
          console.log(&#39;响应状态码为：&#39;+xhr.status);
        &#125;
      &#125;
    &#125;
//3 打开连接
    xhr.open(&#39;GET&#39;,&#39;test.php?uname=&#39;+n, true);
//4 发送请求消息
    xhr.send( null );
</code></pre>
</blockquote>
]]></content>
      <tags>
        <tag>AJAX</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>关于JS的模块化开发总结</title>
    <url>/2017/04/10/CommonJSAMDCMD%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>一直都在说JS的模块化开发，以前研究和使用过require之类的方法，但是一直不是很明确，今天还是在总结一下：</p>
<ul>
<li><strong>知识点一</strong> ：AMD/CMD/CommonJs是JS模块化开发的标准；</li>
<li><strong>知识点二</strong> ：commonjs是用在服务器端的，同步的，如nodejs；amd, cmd是用在浏览器端的，异步的，如requirejs和seajs；</li>
<li><strong>知识点三</strong> ：AMD/CMD区别，虽然都是并行加载js文件，但还是有所区别，AMD是预加载，在并行加载js文件同时，还会解析执行该模块（因为还需要执行，所以在加载某个模块前，这个模块的依赖模块需要先加载完成）；而CMD是懒加载，虽然会一开始就并行加载js文件，但是不会执行，而是在需要的时候才执行。<span id="more"></span></li>
</ul>
<p><strong>CommonJS</strong></p>
<blockquote>
<p>CommonJs 是服务器端模块的规范。<br>根据CommonJS规范，一个单独的文件就是一个模块。加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的exports对象。<br>例如:<br>// foobar.js</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//私有变量</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公有方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foobar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// do someing ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//do someing ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>//exports对象上的方法和变量是公有的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foobar = <span class="keyword">new</span> foobar();</span><br><span class="line"><span class="built_in">exports</span>.foobar = foobar;</span><br></pre></td></tr></table></figure>
<p>//require方法默认读取js文件，所以可以省略js后缀</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="built_in">require</span>(<span class="string">&#x27;./boobar&#x27;</span>).foobar;</span><br><span class="line">test.bar();</span><br></pre></td></tr></table></figure>
<p>CommonJS 加载模块是同步的，所以只有加载完成才能执行后面的操作。像Node.js主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式，所以CommonJS规范比较适用。但如果是浏览器环境，要从服务器加载模块，这是就必须采用异步模式。所以就有了 AMD  CMD 解决方案。</p>
<p><strong>AMD</strong></p>
<blockquote>
<p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出<br>AMD异步加载模块。它的模块支持对象 函数 构造器 字符串 JSON等各种类型的模块。<br>适用AMD规范适用define方法定义模块。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过数组引入依赖 ，回调函数通过形参传入依赖</span></span><br><span class="line">define([<span class="string">&#x27;someModule1&#x27;</span>, ‘someModule2’], <span class="function"><span class="keyword">function</span> (<span class="params">someModule1, someModule2</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">/// someing</span></span><br><span class="line">        someModule1.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">foo</span>: foo&#125;</span><br><span class="line">&#125;);</span><br><span class="line">AMD规范允许输出模块兼容CommonJS规范，这时define方法如下：</span><br><span class="line"></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> reqModule = <span class="built_in">require</span>(<span class="string">&quot;./someModule&quot;</span>);</span><br><span class="line">    requModule.test();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exports</span>.asplode = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//someing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>CMD</strong></p>
<blockquote>
<p>CMD是SeaJS 在推广过程中对模块定义的规范化产出</p>
</blockquote>
<p>CMD和AMD的区别有以下几点：</p>
<blockquote>
<p>1.对于依赖的模块AMD是提前执行，CMD是延迟执行。不过RequireJS从2.0开始，也改成可以延迟执行（根据写法不同，处理方式不通过）。<br>2.CMD推崇依赖就近，AMD推崇依赖前置。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AMD</span></span><br><span class="line">define([<span class="string">&#x27;./a&#x27;</span>,<span class="string">&#x27;./b&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//依赖一开始就写好</span></span><br><span class="line">    a.test();</span><br><span class="line">    b.test();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//CMD</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">requie, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//依赖可以就近书写</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a&#x27;</span>);</span><br><span class="line">    a.test();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//软依赖</span></span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> b = requie(<span class="string">&#x27;./b&#x27;</span>);</span><br><span class="line">        b.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 虽然 AMD也支持CMD写法，但依赖前置是官方文档的默认模块定义写法。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>3.AMD的api默认是一个当多个用，CMD严格的区分推崇职责单一。例如：AMD里require分全局的和局部的。CMD里面没有全局的 require,提供 seajs.use()来实现模块系统的加载启动。CMD里每个API都简单纯粹。</p>
</blockquote>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>H5新特性——音视频</title>
    <url>/2016/07/11/H5%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<p>HTML5 之前在页面播放需要使用 flash 播放器；HTML5 添加两个标签：</p>
<pre><code>&lt;video&gt;&lt;/video&gt;
&lt;audio&gt;&lt;/audio&gt;
</code></pre>
<p>这两个标签有一些特殊属性、事件、方法。</p>
<span id="more"></span>
<h3 id="HTML5-新特性——视频"><a href="#HTML5-新特性——视频" class="headerlink" title="HTML5 新特性——视频"></a>HTML5 新特性——视频</h3><p>1.Video 标签可用的属性：</p>
<pre><code>(1)src：待播放的资源的URL
(2)width：播放区域的宽度
(3)height：播放区域的高度
(4)controls：是否显示播放控件，默认不显示
(5)autoplay：是否自动播放，默认不自动播放
(6)loop：是否循环播放，默认不循环
(7)preload：如何预加载视频，可以赋值为
    “none”：不预加载
    “metadata”：只预加载元数据，如影片宽、高、大小、时长
    “auto”：（默认值）自动预加载元数据以及部分影片数据
(8)poster：影片播放之前显示的“电影海报”
</code></pre>
<p>2.Video 对象的成员</p>
<pre><code>1.autoplay:false
2.controls:false
3.currentTime:0             当前播放到哪一秒
4.duration:NaN            总时长
5.ended:false
6.loop:false            是否循环
7.muted:false            是否静音
8.oncanplay:null            当能够播放时触发
9.oncanplaythrough:null    当能够顺利播放一段时间
10.onended:null            当播放的结尾时触发
11.onerror:null            当播放错误时触发
12.onloadeddata:null        当加载了影片数据时触发
13.onloadedmetadata:null    当加载了影片元数据时触发
14.onpause:null            当影片暂停时触发
15.onplay:null            当影片开始播放时触发
16.paused:true            当前是否处于暂停状态
17.poster:&quot;&quot;                电影海报
18.preload:&quot;auto&quot;            如何预加载
19.src:&quot;http://127.0.0.1/html5_day02/resource/birds.mp4&quot;
20.videoHeight:0
21.videoWidth:0
22.volume:1
23.play(): function()&#123;&#125;    使用JS控制影片播放
24.pause(): function()&#123;&#125;    使用JS控制影片暂停
</code></pre>
<h3 id="HTML5-新特性——音频"><a href="#HTML5-新特性——音频" class="headerlink" title="HTML5 新特性——音频"></a>HTML5 新特性——音频</h3><p>HTML5 之前，播放音频可以使用 flash 播放器，或者使用 bgsound（IE 专有，只能网页的背景音乐，不能使用 JS 控制播放、音量）。<br>HTML5 中，使用 audio 标签来播放音频。该标签的常用属性与 video 几乎一样，如：</p>
<pre><code>(1)src
(2)autoplay：是否自动播放，默认为false
(3)controls：是否显示播放控制条，默认为false
(4)loop：是否循环播放，默认为false
</code></pre>
]]></content>
      <tags>
        <tag>HTML5</tag>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title>Canvas绘图技术</title>
    <url>/2016/07/12/H5%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94Canvas/</url>
    <content><![CDATA[<h2 id="HTML5-新特性——Canvas-绘图技术"><a href="#HTML5-新特性——Canvas-绘图技术" class="headerlink" title="HTML5 新特性——Canvas 绘图技术"></a>HTML5 新特性——Canvas 绘图技术</h2><p>提示：Canvas 绘图的难点在方法和属性的记忆上！<br>Canvas 技术用于在网页上实现绘图，主要应用领域：</p>
<span id="more"></span>

<blockquote>
<ul>
<li>绘制各种统计图表，柱状图、饼图、曲线图、分布图…</li>
<li>动画和游戏</li>
</ul>
</blockquote>
<p>使用 Canvas 的方法：<br><canvas width="500"  height="400"><br>您的浏览器不支持 Canvas 标签！<br></canvas><br>提示：</p>
<ol>
<li><p> Canvas 的宽和高只能用属性方式声明！若使用样式来声明则无效。</p>
</li>
<li><p> Canvas 的本意是“画布/画板”，可以盛放绘制的内容；真正执行绘图任务的是“画笔/绘图上下文对象”——Context</p>
</li>
<li><p> 每一个画布，有且只有一个画笔对象：</p>
<pre>
var ctx = canvas.getContext( '2d' );
</pre></li>
<li><p>画笔/绘图上下文对象的成员：</p>
 <pre>
     1.fillStyle:"#000000"            填充颜色
     2.font:"10px sans-serif"            字体
     3.globalAlpha:1                    全局透明度
     4.lineCap:"butt"                    线的端点样式
     5.lineJoin:"miter"                线的连接处样式
     6.lineWidth:1                    线条的宽度
     7.shadowBlur:0                    阴影部分模糊距离
     8.shadowColor:"rgba(0, 0, 0, 0)"    阴影部分颜色
     9.shadowOffsetX:0                阴影水平偏移量
     10.shadowOffsetY:0                阴影竖直偏移量
     11.strokeStyle:"#000000"            轮廓/描边颜色
     12.arc:arc()                    绘制一个弧线
     13.beginPath:beginPath()        开始绘制路径
     14.clearRect:clearRect()        清除一个矩形范围
     15.clip:clip()                裁切
     16.closePath:closePath()        闭合一条路径
     17.createLinearGradient:createLinearGradient() 创建一个线性渐变色
     18.createRadialGradient:createRadialGradient() 创建一个径向渐变色
     19.drawImage:drawImage()        绘制一幅图像
     20.ellipse:ellipse()            绘制一个椭圆
     21.fill:fill()                填充一条路径
     22.fillRect:fillRect()        填充一个矩形区域
     23.fillText:fillText()        填充一段文本
     24.lineTo:lineTo()            绘制一条直线
     25.measureText:measureText()    测量一段文本，得到宽度
     26.moveTo:moveTo()            移动画笔到指定点
     27.rect:rect()                绘制一个矩形路径
     28.rotate:rotate()            旋转
     29.scale:scale()                缩放
     30.stroke:stroke()            对一条路径描边
     31.strokeRect:strokeRect()    对一个矩形进行描边
     32.strokeText:strokeText()    对一段文本进行描边
     33.translate:translate()        进行位移
 </pre>

<p> 5.使用画笔在画布上绘制图形<br><br> 5.1 绘制矩形(长方形)——矩形以自己的左上角作定位点</p>
<pre><code> &lt;pre&gt;ctx.lineWidth = 10;                修改描边的宽度
 ctx.strokeStyle = &#39;颜色&#39;/渐变色;    修改描边的颜色
 ctx.strokeRect(x, y, w, h)            描边一个矩形
 ctx.fillStyle = &#39;颜色&#39;/渐变色对象;    填充样式
 ctx.fillRect(x, y, w, h)            填充一个矩形
 ctx.clearRect(x,y, w, h);            清除一个矩形范围内所有内容
</code></pre>
<p> </pre><br> 5.2  绘制文本——文字以自己的坐下角作定位点</p>
<pre><code> &lt;pre&gt;ctx.font = &#39;20px SimHei&#39;;        设置字体大小和样式
 var w = ctx.measureText(txt).width;    获取一段文本的宽度
 ctx.strokeStyle = &quot;颜色&quot;/渐变;
 ctx.strokeText(txt, x, y)            对文字进行描边
 ctx.fillStyle = &quot;颜色&quot;/渐变;
 ctx.fillText(txt, x, y)                对文字进行填充
 &lt;/pre&gt;
</code></pre>
<p> 5.3 绘制路径</p>
<pre><code>     ctx.beginPath( );        //开始一条新路径

 ...在路径上添加定位点...

     ctx.closePath( );        //闭合当前路径
 路径的两个用途：

     (1)ctx.stroke();    //描边刚刚绘制的路径
     (2)ctx.fill();        //填充刚刚绘制的路径
 常见的添加定位点的方法：

     ctx.moveTo(x,y);    //把画笔移动到指定点
     ctx.lineTo(x,y);        //从上一个点开始到当前点绘制一条直线
     ctx.arc(x,y,r,sAngle,eAngle);        //绘制一条圆弧线
     ctx.ellipse(x,y,rx,ry,sAngle,eAngle);    //绘制一条椭圆弧线
</code></pre>
<p> 5.4 绘制图像——以图像的左上角为定位点</p>
<pre><code>     ctx.rotate( angle );    //旋转画笔，此后绘制的图像/图像都会旋转——旋转围绕着画布的坐标原点为轴
     ctx.translate(x, y);    //平移坐标轴的原点
     ctx.drawImage(img, x, y);        //原宽原高的绘制图像
     ctx.drawImage(img, x, y, width, height);  //使用指定的宽和高绘制图像

 提示：
     1)创建图片： var img =new Image();  img.src=&quot;xx.jpg&quot;;
     2)使用图片必须等待加载完成！  img.onload = function()&#123; ... &#125;
</code></pre>
</li>
</ol>
]]></content>
      <tags>
        <tag>HTML5</tag>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>H5新特性</title>
    <url>/2016/07/10/H5%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h3 id="表单新特性————新的-input-type"><a href="#表单新特性————新的-input-type" class="headerlink" title="表单新特性————新的 input type"></a>表单新特性————新的 input type</h3><pre><code>&lt;input type=&quot;?&quot;&gt;
</code></pre>
<p>1.1 原有的 type:</p>
<pre><code>text、password、radio、checkbox、hidden、file、image、button、submit、reset
</code></pre>
<span id="more"></span>
<p>1.2 新增的 type:</p>
<pre><code>email、search、url、tel、number、range、color、date、week、month

1. email:  要求输入必需符合邮箱格式  xx@xx
2. url:  要求输入必需符合URL格式  xx:yy
3. tel:  无输入格式验证，在手机中弹出的数字键盘，而不是字母键盘
4. number: 要求输入一个整型数字，可以配合max/min/step新属性使用
5. search: Chrome中会显示一个x号
6. range: 范围选择器、滑块，可以配合max/min/step新属性使用
7. color：颜色选择器，Chrome/FF偷懒了，都直接使用操作系统自带的颜色选择器
8. date：日期选择器，FF不支持
9. month：月份选择器，FF不支持
10. week：星期选择器，FF不支持
</code></pre>
<!-- more -->

<blockquote>
<p>提示：<br>(1) HTML5 新添的 input type 存在严重的兼容性问题！<br>(2) 新特性弹出的提示消息本质是“窗口”，不是 HTML 元素，无法使用 JS、CSS 进行控制！</p>
</blockquote>
<h3 id="表单新特性————新的表单元素"><a href="#表单新特性————新的表单元素" class="headerlink" title="表单新特性————新的表单元素"></a>表单新特性————新的表单元素</h3><p>2.1 原有的表单输入元素：<br>input、textarea、select/option<br>2.2 新增的表单元素</p>
<pre><code>(1)&lt;datalist&gt;&lt;/datalist&gt;        数据列表，本身是不可见元素，为某个input提供可选输入的列表，使用方法：
    &lt;datalist id=&quot;LISTID&quot;&gt;&lt;option&gt;选项名&lt;/option&gt;&lt;/datalist&gt;
    &lt;input type=&quot;text&quot; list=&quot;LISTID&quot;&gt;

(2)&lt;progress&gt;&lt;/progress&gt;    进度条，仅用于进度的提示，不能被用户操作，也不会被提交。
    &lt;progress value=&quot;0.5&quot;&gt;&lt;/progress&gt;

(3)&lt;meter&gt;&lt;/meter&gt;        刻度尺，仅用于水平/数量的提示，不能被用户操作，也不会被提交。需要指定如下属性：
    &lt;meter min=&quot;最小值&quot; max=&quot;最大值&quot; low=&quot;下限值&quot; high=&quot;上限值&quot; optimum=&quot;最优值&quot;  value=&quot;当前实际值&quot;&gt;&lt;/meter&gt;
    如果最优值小于下限值，刻度尺颜色分配：
    min (绿色) low (黄色) high (红色) max
    如果最优值大于下限值且小于上限值，刻度尺颜色分配：
    min (黄色) low (绿色) high (黄色) max
    如果最优值大于上限值，刻度尺颜色分配：
    min (红色) low (黄色) high (绿色) max

(4)&lt;output&gt;&lt;/output&gt;    语义标签，表示一个计算的输出值，仅用于计算结果的提示，不能被用户操作，也不会被提交。
</code></pre>
<p>提示：上述四个新元素存在兼容性问题。</p>
<h3 id="表单新特性————input-的新属性"><a href="#表单新特性————input-的新属性" class="headerlink" title="表单新特性————input 的新属性"></a>表单新特性————input 的新属性</h3><p>3.1 原有的 input 属性</p>
<pre><code>&lt;input id=&quot;&quot; class=&quot;&quot; style=&quot;&quot; title=&quot;&quot; name=&quot;&quot; value=&quot;&quot; type=&quot;&quot; readonly  checked  selected  diabled &gt;
</code></pre>
<p>3.2 新增的 input 属性</p>
<pre><code>&lt;input type=&quot;number&quot; max=&quot;最大值&quot; min=&quot;最小值&quot; step=&quot;步长&quot;&gt;
&lt;input type=&quot;text&quot; list=&quot;datalist元素的ID&quot;  autocomplete=&quot;on/off&quot;&gt;
&lt;meter min=&quot;最小值&quot; max=&quot;最大值&quot; low=&quot;下限值&quot; high=&quot;上限值&quot; optimum=&quot;最优值&quot;  value=&quot;当前实际值&quot;&gt;&lt;/meter&gt;

(1)placeholder：占位符，用于在input中显示提示性文字，注意：不是value
(2)autocomplete：可赋值为on或off，是否记录之前提交的内容，以实现下次输入时的自动提示
(3)autofocus：自动获得输入焦点
(4)multiple：用于email/url/tel等，允许使用逗号指定多个输入
(5)form：为input指定form属性，可以将input从form内部提到外部，且不影响输入域的提交
  与表单输入验证有关的属性：
(6)required：必填属性，若用户未填写内容，则无法提交
(7)minlength：限制最少的字符个数，非标准，FF不支持
(8)maxlength：限制最大的字符个数
(9)max：一般用于number、range、&lt;meter&gt;、&lt;progress&gt;，表示允许的数字最大值
(10)min：一般用于number、range、&lt;meter&gt;、&lt;progress&gt;，表示允许的数字最小值
(11)step：一般用于number、range，表示步长
(12)pattern：使用正则表达式进行验证
&lt;input type=&quot;text&quot; name=&quot;cellphone&quot; placeholder=&quot;请输入手机号&quot; pattern=&quot;^1[358]\d&#123;9&#125;$&quot; required&gt;
</code></pre>
<h3 id="如何修改表单的提示消息"><a href="#如何修改表单的提示消息" class="headerlink" title="如何修改表单的提示消息"></a>如何修改表单的提示消息</h3><p>HTML5 表单可能在如下情形下弹出提示消息：<br>(1)特定的 input type 不被满足，如 email、url<br>(2)特定的验证属性不被满足，如 required、pattern、step、minlength<br>不同的浏览器会弹出不同的提示消息。如何自定义弹出的提示消息：<br>HTML5 为所有的表单输入域都添加了一个 validity 对象属性，该对象中包含如下的属性：</p>
<blockquote>
<p>1.badInput:false 无效的输入，如<br>2.customError:false 是否存在自定义错误<br>3.patternMismatch:false 正则表达式不匹配，违反 pattern 验证<br>4.rangeOverflow:false 数字范围过大，违反了 max 验证<br>5.rangeUnderflow:false 数字范围过小，违反了 min 验证<br>6.stepMismatch:false 步长不匹配，违反 step 验证<br>7.tooLong:false 字符个数太长，违反 maxlength 验证<br>8.tooShort:false 字符个数太短，违反 minlength 验证<br>9.typeMismatch:false 类型不匹配，如 email/url 格式错误<br>10.valid:true 当前输入值是否有效<br>11.valueMissing:false 缺少值，违反 required 验证</p>
</blockquote>
<p>上述属性会随着用户的输入即时的发生改变，只要有一项验证失败，对应的 boolean 值就会变成 true，导致 valid 属性变为 false；只有当所有其他属性都变为 false，valid 属性才会变为 true，该输入域是有效的，可以被提交了。<br>通过检查上述属性是否为 true，可以通过“设置自定义的有效性消息 setCustomValidity”设置自定义的错误消息——validity.customError 就会变为 true，自定义错误消息的优先级高于浏览器默认的消息优先级。<br>if( input.validity.xxx === true ){<br>input.setCustomValidity(“自定义消息”);<br>}else {<br>input.setCustomValidity(“”);<br>}</p>
]]></content>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5离线存储和本地缓存</title>
    <url>/2016/07/15/H5%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E5%92%8C%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="一、离线缓存"><a href="#一、离线缓存" class="headerlink" title="一、离线缓存"></a>一、离线缓存</h1><p>有一个 web 应用有三个文件 index.html,a.js,b.css，现在需要把 js 和 css 文件缓存起来</p>
<span id="more"></span>
<p>1.在 index.html 里加上<html manifest="test.manifest"></p>
<p>2.manifest 清单格式如下</p>
<blockquote>
<pre><code> CACHE MANIFEST
</code></pre>
</blockquote>
<pre><code>#上面一句必须
#v1.0.0
#需要缓存的文件
CACHE:
a.js
b.css
#不需要缓存的文件
NETWORK:
*
#无法访问页面
FALLBACK:
404.html
复制代码
</code></pre>
<p>3.manifest 文件的 mime-type 必须是 text/cache-manifest 类型</p>
<blockquote>
<p>注意点：<br>a.对于每个 index.html?id=1 或 index.html?id=2 都会分别缓存 index.html 页面，可以通过 chrome 浏览器 Resources/Application Cache 观察<br>b.如果想更新缓存内容，只要修改下 manifest 文件即可，如改版本号 v1.0.1</p>
</blockquote>
<!-- more -->

<p>4.离线存储如果资源有更新，可以通过如下代码来监听，但第一次加载还会是原来的版本</p>
<blockquote>
<pre><code> window.applicationCache.addEventListener(&#39;updateready&#39;,function(e)&#123;
</code></pre>
</blockquote>
<pre><code>    if(window.applicationCache.status == window.applicationCache.UPDATEREADY)&#123;
        window.applicationCache.swapCache();
        if(confirm(&quot;loding new?&quot;))&#123;
            window.location.reload()
        &#125;
    &#125;
&#125;,false)
</code></pre>
<h1 id="二、本地缓存"><a href="#二、本地缓存" class="headerlink" title="二、本地缓存"></a>二、本地缓存</h1><pre><code>localStorage.setItem(&quot;key&quot;,&quot;value&quot;)

localStorage.getItem(&quot;key&quot;,&quot;value&quot;)

localStorage.removeItem(&quot;key&quot;)

localStorage.clear()
</code></pre>
<p>1.本地存储永不过期，除非自己去清除</p>
<p>2.可以通过 chrome 浏览器 Resources/Local Storage 来查看</p>
<p>3.不同域下就算 key 相同取不到的值也不同，如 localhost 和 127.0.0.1</p>
]]></content>
      <tags>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title>Hamming Distance</title>
    <url>/2016/09/03/HammingDistance/</url>
    <content><![CDATA[<h1 style="color:#2dbe60"> Hamming Distance </h1>
The <a href="https://en.wikipedia.org/wiki/Hamming_distance" target="_blank" style="box-sizing: border-box; color: rgb(0, 136, 204); text-decoration: none; background-color: transparent;">Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.
Given two integers x and y, calculate the Hamming distance.
<span id="more"></span>
**Note:**
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> ≤ x, y &lt; <span class="number">2</span>^<span class="number">31.</span></span><br></pre></td></tr></table></figure>
**Example:**
``` flow
Input: x = 1, y = 4

<p>Output: 2</p>
<p>Explanation:<br>1 (0 0 0 1)<br>4 (0 1 0 0)<br>? ?</p>
<p>The above arrows point to positions where the corresponding bits are different.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**代码如下:**</span><br><span class="line">``` javascript</span><br><span class="line">/**</span><br><span class="line"> * @param &#123;number&#125; x</span><br><span class="line"> * @param &#123;number&#125; y</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var  hammingDistance = function(x, y) &#123;</span><br><span class="line">         var z = x^y;</span><br><span class="line">         z = z.toString(2).split(&quot;&quot;);</span><br><span class="line">         var result = 0;</span><br><span class="line">         z.forEach(function(val)&#123;</span><br><span class="line">              if(val === &#x27;1&#x27;)&#123;</span><br><span class="line">                    result++;</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;)</span><br><span class="line">         return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>JS 算法</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript代码收集</title>
    <url>/2016/07/20/Javascript%E4%BB%A3%E7%A0%81%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<h2 id="1-根据userAgent判断是否手机"><a href="#1-根据userAgent判断是否手机" class="headerlink" title="1.根据userAgent判断是否手机"></a>1.根据userAgent判断是否手机</h2><span id="more"></span>
<pre><code>if(/AppleWebKit.*Mobile/i.test(navigator.userAgent) || (/MIDP|SymbianOS|NOKIA|SAMSUNG|LG|NEC|TCL|Alcatel|BIRD|DBTEL|Dopod|PHILIPS|HAIER|LENOVO|MOT-|Nokia|SonyEricsson|SIE-|Amoi|ZTE/.test(navigator.userAgent)))&#123;
    if(window.location.href.indexOf(&quot;?mobile&quot;)&lt;0)&#123;
        try&#123;
            if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent))&#123;
                //移动端
            &#125;else if(/iPad/i.test(navigator.userAgent))&#123;
                //这里对ipad做了处理
            &#125;else&#123;
                //移动端
            &#125;
        &#125;catch(e)&#123;&#125;
    &#125;
&#125;else&#123;
    //pc端
&#125;
var ISWP = !!(navigator.userAgent.match(/Windows\sPhone/i));
</code></pre>
<h2 id="2-this-constructor-prototype例子"><a href="#2-this-constructor-prototype例子" class="headerlink" title="2.this, constructor, prototype例子"></a>2.this, constructor, prototype例子</h2><pre><code>var Tinker = function()&#123;
    this.elements = [];

&#125;;
    Tinker.fn = Tinker.prototype = &#123;
        constructor: Tinker,
        extend: function(obj)&#123;
            var p;
            for(p in obj)&#123;
                this.constructor.prototype[p] = obj[p];//此处若看明白了, 那么前面的就理解了
            &#125;
        &#125;
    
    &#125;
    Tinker.fn.extend(&#123;
       get: function()&#123;
            var length = arguments.length,
            i = 0;
           for(; i &lt; length; i++)&#123;
               this.elements.push(arguments[i]); //此处若看明白了, 那么前面的就理解了
           &#125;
           return this;//此处若看明白了, 那么前面的就理解了
       &#125;,
       each: function(fn)&#123;
            var i = 0,
                length = this.elements.length;
            for(; i &lt; length; i++)&#123;
                fn.call(this.elements[i], i, this.elements[i]);
            &#125;
            return this;//此处若看明白了, 那么前面的就理解了
       &#125;
        
    &#125;);
</code></pre>
<h2 id="3-模仿jquery-each"><a href="#3-模仿jquery-each" class="headerlink" title="3.模仿jquery each"></a>3.模仿jquery each</h2><pre><code>function each(obj, fn)&#123;
    var i;
    if(Object.prototype.toString.call(obj) === &#39;[object Array]&#39;)&#123;
        for(i = 0, length = obj.length; i &lt; length; i++)&#123;
            fn.call(obj[i], i, obj[i]);
        &#125;
    &#125;
    else if(typeof obj === &#39;object&#39;)&#123;
        for(i in obj)&#123;
            if(obj.hasOwnProperty(i))&#123;
               fn.call(obj[i], i, obj[i]);
            &#125;
        &#125;
    &#125;
    else&#123;
        return false;
    &#125;
&#125;
    
</code></pre>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>aplly&amp;call方法的使用</title>
    <url>/2016/07/02/aplly&amp;call%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>在一个对象中绑定函数，称为这个对象的方法。<br>在JavaScript中，对象的定义是这样的：</p>
<pre><code>var xiaoming = &#123;
    name: ‘小明’,
    birth: 1990
&#125;;
</code></pre>
<p>但是，如果我们给xiaoming绑定一个函数，就可以做更多的事情。比如，写个age()方法，返回xiaoming的年龄：</p>
<span id="more"></span>

<pre><code>var xiaoming = &#123;
    name: ‘小明’,
    birth: 1990,
    age: function () &#123;
    var y = new Date().getFullYear();
        return y - this.birth;
    &#125;
&#125;;
xiaoming.age; // function xiaoming.age()
xiaoming.age(); // 今年调用是25,明年调用就变成26了
</code></pre>
<p>绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个this关键字，这个东东是什么？</p>
<p>在一个方法内部，this是一个特殊变量，它始终指向当前对象，也就是xiaoming这个变量。所以，this.birth可以拿到xiaoming的birth属性。<br>让我们拆开写：</p>
<pre><code>function getAge() &#123;
    var y = new Date().getFullYear();
r    eturn y - this.birth;
&#125;

var xiaoming = &#123;
    name: ‘小明’,
    birth: 1990,
    age: getAge
&#125;;
xiaoming.age(); // 25, 正常结果
getAge(); // NaN
</code></pre>
<p>单独调用函数getAge()怎么返回了NaN？请注意，我们已经进入到了JavaScript的一个大坑里。</p>
<p>JavaScript的函数内部如果调用了this，那么这个this到底指向谁？</p>
<p>答案是，视情况而定！</p>
<p>如果以对象的方法形式调用，比如xiaoming.age()，该函数的this指向被调用的对象，也就是xiaoming，这是符合我们预期的。</p>
<p>如果单独调用函数，比如getAge()，此时，该函数的this指向全局对象，也就是window。</p>
<p>坑爹啊！</p>
<p>更坑爹的是，如果这么写：</p>
<pre><code>var fn = xiaoming.age; // 先拿到xiaoming的age函数
fn(); // NaN
</code></pre>
<p>也是不行的！要保证this指向正确，必须用obj.xxx()的形式调用！</p>
<p>由于这是一个巨大的设计错误，要想纠正可没那么简单。ECMA决定，在strict模式下让函数的this指向undefined，因此，在strict模式下，你会得到一个错误：</p>
<pre><code>‘use strict’;

var xiaoming = &#123;
    name: ‘小明’,
    birth: 1990,
    age: function () &#123;
        var y = new Date().getFullYear();
        return y - this.birth;
    &#125;
&#125;;
var fn = xiaoming.age;
fn(); // Uncaught TypeError: Cannot read property ‘birth’ of undefined
</code></pre>
<p>这个决定只是让错误及时暴露出来，并没有解决this应该指向的正确位置。</p>
<p>有些时候，喜欢重构的你把方法重构了一下：</p>
<pre><code>‘use strict’;

var xiaoming = &#123;
    name: ‘小明’,
    birth: 1990,
    age: function () &#123;
    function getAgeFromBirth() &#123;
        var y = new Date().getFullYear();
        return y - this.birth;
    &#125;
    return getAgeFromBirth();
    &#125;
&#125;;
xiaoming.age(); // Uncaught TypeError: Cannot read property ‘birth’ of undefined
</code></pre>
<p>结果又报错了！原因是this指针只在age方法的函数内指向xiaoming，在函数内部定义的函数，this又指向undefined了！（在非strict模式下，它重新指向全局对象window！）</p>
<p>修复的办法也不是没有，我们用一个that变量首先捕获this：</p>
<pre><code>‘use strict’;

var xiaoming = &#123;
    name: ‘小明’,
    birth: 1990,
    age: function () &#123;
        var that = this; // 在方法内部一开始就捕获this
        function getAgeFromBirth() &#123;
            var y = new Date().getFullYear();
            return y - that.birth; // 用that而不是this
        &#125;
        return getAgeFromBirth();
    &#125;
&#125;;
xiaoming.age(); // 25
</code></pre>
<p>用var that = this;，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。</p>
<h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p>虽然在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window，不过，我们还是可以控制this的指向的！</p>
<p>要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。</p>
<p>用apply修复getAge()调用：</p>
<pre><code>function getAge() &#123;
    var y = new Date().getFullYear();
    return y - this.birth;
&#125;

var xiaoming = &#123;
    name: ‘小明’,
    birth: 1990,
    age: getAge
&#125;;
xiaoming.age(); // 25
getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空
</code></pre>
<p>另一个与apply()类似的方法是call()，唯一区别是：</p>
<p>apply()把参数打包成Array再传入；</p>
<p>call()把参数按顺序传入。</p>
<p>比如调用Math.max(3, 5, 4)，分别用apply()和call()实现如下：</p>
<p>Math.max.apply(null, [3, 5, 4]); // 5<br>Math.max.call(null, 3, 5, 4); // 5<br>对普通函数调用，我们通常把this绑定为null。</p>
<h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><p>利用apply()，我们还可以动态改变函数的行为。</p>
<p>JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。</p>
<p>现在假定我们想统计一下代码一共调用了多少次parseInt()，可以把所有的调用都找出来，然后手动加上count += 1，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的parseInt()：</p>
<pre><code>var count = 0;
var oldParseInt = parseInt; // 保存原函数

window.parseInt = function () &#123;
count += 1;
return oldParseInt.apply(null, arguments); // 调用原函数
&#125;;

// 测试:
parseInt(‘10’);
parseInt(‘20’);
parseInt(‘30’);
count; // 3
</code></pre>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>九、JavaScript之call、apply和bind的模拟实现</title>
    <url>/2019/09/21/call%E3%80%81apply%E3%80%81bind%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>简单来说</p>
<blockquote>
<p>call()方法在将函数的第一个参数值指定到 this 和剩余参数指定的情况下调用某个函数或方法。</p>
</blockquote>
<span id="more"></span>
<p>使用示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lilei&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// this指向第一个参数foo;</span></span><br><span class="line">bar.call(foo, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// &#123;name: &quot;lilei&quot;&#125; 1 2</span></span><br><span class="line"><span class="comment">// a,b未传参数，默认是undefined</span></span><br><span class="line">bar.call(foo); <span class="comment">// &#123;name: &quot;lilei&quot;&#125; undefined undefined</span></span><br><span class="line"><span class="comment">// call方法不传参数或传递null/undefined，this都指向window(非严格模式)</span></span><br><span class="line">bar.call(); <span class="comment">// window undefined undefined</span></span><br><span class="line">bar.call(<span class="literal">null</span>); <span class="comment">// window undefined undefined</span></span><br><span class="line">bar.call(<span class="literal">undefined</span>); <span class="comment">// window undefined undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h3><p>call 方法的模拟实现需要明白 call 的原理：</p>
<ol>
<li>this 指向的改变</li>
<li>call 函数中执行调用的函数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context === <span class="literal">null</span> || context === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    context = <span class="built_in">window</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    context = <span class="built_in">Object</span>(context);</span><br><span class="line">  &#125;</span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">delete</span> context.fn(...args);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lilei&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line">bar.myCall(foo, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// &#123;name: &quot;lilei&quot;, fn: ƒ&#125; 1 2</span></span><br><span class="line">bar.myCall(foo); <span class="comment">// &#123;name: &quot;lilei&quot;, fn: ƒ&#125; undefined undefined</span></span><br><span class="line">bar.myCall(); <span class="comment">// Window undefined undefined</span></span><br><span class="line">bar.myCall(<span class="literal">null</span>); <span class="comment">// Window undefined undefined</span></span><br><span class="line">bar.myCall(<span class="literal">undefined</span>); <span class="comment">// Window undefined undefined</span></span><br><span class="line">bar.myCall(<span class="number">23</span>, <span class="number">24</span>); <span class="comment">// Number &#123;23, fn: ƒ&#125; undefined undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>apply 的使用与 apply 基本一致，两者之间的区别：apply 的第二个参数是数组[arg1,arg2,arg3,…]，call 的第二个参数是列表(arg1,arg2,arg3,…)；<br>使用示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lilei&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line">bar.apply(foo, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// &#123;name: &quot;lilei&quot;&#125; 1 2</span></span><br><span class="line">bar.apply(foo); <span class="comment">// &#123;name: &quot;lilei&quot;&#125; undefined undefined</span></span><br><span class="line">bar.apply(); <span class="comment">// window undefined undefined</span></span><br><span class="line">bar.apply(<span class="literal">null</span>); <span class="comment">// window undefined undefined</span></span><br><span class="line">bar.apply(<span class="literal">undefined</span>); <span class="comment">// window undefined undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="模拟实现-1"><a href="#模拟实现-1" class="headerlink" title="模拟实现"></a>模拟实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context === <span class="literal">null</span> || context === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    context = <span class="built_in">window</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    context = <span class="built_in">Object</span>(context);</span><br><span class="line">  &#125;</span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">delete</span> context.fn(args);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>引用 MDN 中的介绍</p>
<blockquote>
<p>bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p>
</blockquote>
<p>由此看出 bind 的特点：</p>
<ul>
<li>bind 返回一个新的函数。</li>
<li>这个新的函数可以预置参数。</li>
</ul>
<p>举个例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;lilei&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn = bar.bind(foo, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">fn(); <span class="comment">//// &#123;name: &quot;lilei&quot;&#125; 1 2</span></span><br></pre></td></tr></table></figure>

<h3 id="模拟实现-2"><a href="#模拟实现-2" class="headerlink" title="模拟实现"></a>模拟实现</h3><p>1.实现返回一个函数，并可以传递参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 保存要绑定的this</span></span><br><span class="line">  <span class="keyword">var</span> _this = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// 获取预置参数</span></span><br><span class="line">  <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取执行时传入的参数</span></span><br><span class="line">    <span class="keyword">var</span> restArgs = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 合并参数</span></span><br><span class="line">    <span class="keyword">var</span> allArgs = args.concat(restArgs);</span><br><span class="line">    <span class="keyword">return</span> self.apply(_this, allArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>接下来最重要的一点，bind 返回的函数支持 new 调用：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;绑定的目标必须是函数&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 保存要绑定的this</span></span><br><span class="line">  <span class="keyword">var</span> _this = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// 获取预置参数</span></span><br><span class="line">  <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取执行时传入的参数</span></span><br><span class="line">    <span class="keyword">var</span> restArgs = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 合并参数</span></span><br><span class="line">    <span class="keyword">var</span> allArgs = args.concat(restArgs);</span><br><span class="line">    <span class="comment">// instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。</span></span><br><span class="line">    <span class="comment">// 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值</span></span><br><span class="line">    <span class="comment">// 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context </span></span><br><span class="line">    <span class="keyword">return</span> self.apply(<span class="built_in">this</span> <span class="keyword">instanceof</span> fBound ? <span class="built_in">this</span> : _this, allArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 原型链关系处理</span></span><br><span class="line">  <span class="comment">// fBound.prototype = Object.create(self.prototype || Function.prototype);</span></span><br><span class="line">  fNOP.prototype = <span class="built_in">this</span>.prototype;</span><br><span class="line">  fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">  <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://github.com/mqyqingfeng/Blog/issues/11">https://github.com/mqyqingfeng/Blog/issues/11</a></p>
]]></content>
      <categories>
        <category>深入理解JavaScript系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>content换行符与打点loading效果实例页面</title>
    <url>/2020/06/19/content%E6%8D%A2%E8%A1%8C%E7%AC%A6%E4%B8%8E%E6%89%93%E7%82%B9loading%E6%95%88%E6%9E%9C%E5%AE%9E%E4%BE%8B%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<p>代码如下：</p>
<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><span id="more"></span>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">dot &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block; </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: left;</span><br><span class="line">    <span class="attribute">vertical-align</span>: -.<span class="number">25em</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line">dot<span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;...\A..\A.&#x27;</span>;</span><br><span class="line">    <span class="attribute">white-space</span>: pre-wrap;</span><br><span class="line">    <span class="attribute">animation</span>: dot <span class="number">3s</span> infinite step-start both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> dot &#123;</span><br><span class="line">    <span class="number">33%</span> &#123; <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">2em</span>); &#125;</span><br><span class="line">    <span class="number">66%</span> &#123; <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">1em</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span>正在加载中<span class="tag">&lt;<span class="name">dot</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dot</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题</title>
    <url>/2016/06/23/count%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="count方法"><a href="#count方法" class="headerlink" title="count方法"></a>count方法</h3><p>封装一个count方法，能实现如此调用：count(a)(b)(c)(d)(e)… 并且返回的值为参数连乘的结果，即abcde*…。如count(1)(3)(7) 得到21</p>
<span id="more"></span>

<pre><code>function count(x)&#123;
    var fn = function(y)&#123;
        return count(x*y);
    &#125;
    fn.toString = function()&#123;
        return x;
    &#125;;
    return fn;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>css中overflow滑动效果在IOS中不流畅</title>
    <url>/2017/04/23/css%E4%B8%ADoverflow%E6%BB%91%E5%8A%A8%E6%95%88%E6%9E%9C%E5%9C%A8IOS%E4%B8%AD%E4%B8%8D%E6%B5%81%E7%95%85/</url>
    <content><![CDATA[<p>最近新作的一个项目中遇到一个问题，有一段很长的表格，手机显示器展示不全，需要做滑动继续展示的效果；<br>OK，很简单，使用overflow-x:auto;谷歌模拟器一切正常，安卓正常，可是打完包在IOS上，滑动效果慢到完全跟随手指的移动而移动，这样是肯定不行的经过百度发现了解决之道；<br>-webkit-overflow-scrolling: touch;<br>度娘说这句话是启动了硬件加速的特性，所以滑动起来会非常流畅；不过会影响性能；经过测试，发现影响看不出，果断选择用它；<br>完美解决~~~~~~~</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Flex布局</title>
    <url>/2018/08/01/flex%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p>
<span id="more"></span>
<h3 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h3><h4 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h4><p><span style="color: cornflowerblue">flex-direction属性决定主轴的方向（即项目的排列方向）。</span></p>
<ul>
<li>row（默认值）：主轴为水平方向，起点在左端。</li>
<li>row-reverse：主轴为水平方向，起点在右端。</li>
<li>column：主轴为垂直方向，起点在上沿。</li>
<li>column-reverse：主轴为垂直方向，起点在下沿。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#89479B</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>:row;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box box1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h4><p><span style="color: cornflowerblue">默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</span></p>
<ul>
<li>nowrap（默认）：不换行。</li>
<li>wrap：换行，第一行在上方。</li>
<li>wrap-reverse：换行，第一行在下方。</li>
</ul>
<h4 id="flex-flow属性"><a href="#flex-flow属性" class="headerlink" title="flex-flow属性"></a>flex-flow属性</h4><p><span style="color: cornflowerblue">flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。。</span></p>
<h4 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h4><p><span style="color: cornflowerblue">justify-content属性定义了项目在主轴上的对齐方式。</span></p>
<ul>
<li>flex-start（默认值）：左对齐</li>
<li>flex-end：右对齐</li>
<li>center： 居中</li>
<li>space-between：两端对齐，项目之间的间隔都相等。</li>
<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
<h4 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h4><p><span style="color: cornflowerblue">align-items属性定义项目在交叉轴上如何对齐</span></p>
<ul>
<li>flex-start：交叉轴的起点对齐。</li>
<li>flex-end：交叉轴的终点对齐。</li>
<li>center：交叉轴的中点对齐。</li>
<li>baseline: 项目的第一行文字的基线对齐。</li>
<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
<h4 id="align-content属性"><a href="#align-content属性" class="headerlink" title="align-content属性"></a>align-content属性</h4><p><span style="color: cornflowerblue">align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</span></p>
<ul>
<li>flex-start：与交叉轴的起点对齐。</li>
<li>flex-end：与交叉轴的终点对齐。</li>
<li>center：与交叉轴的中点对齐。</li>
<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li>stretch（默认值）：轴线占满整个交叉轴。</li>
</ul>
<h3 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h3><h4 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h4><p><span style="color: cornflowerblue">order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</span></p>
<h4 id="flex-grow属性"><a href="#flex-grow属性" class="headerlink" title="flex-grow属性"></a>flex-grow属性</h4><p><span style="color: cornflowerblue">flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</span><br>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
<h4 id="flex-shrink属性"><a href="#flex-shrink属性" class="headerlink" title="flex-shrink属性"></a>flex-shrink属性</h4><p><span style="color: cornflowerblue">flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</span><br>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。</p>
<h4 id="flex-basis属性"><a href="#flex-basis属性" class="headerlink" title="flex-basis属性"></a>flex-basis属性</h4><p><span style="color: cornflowerblue">flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</span><br>它可以设为跟width或height属性一样的值（比如100px），则项目将占据固定空间。</p>
<h4 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h4><p><span style="color: cornflowerblue">flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</span><br>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>
<h4 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h4><p><span style="color: cornflowerblue">align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</span><br>该属性可能取6个值，除了auto，其他都与align-items属性完全一致</p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2015/07/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>hexo 常用命令</title>
    <url>/2016/06/28/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="常用部署步骤"><a href="#常用部署步骤" class="headerlink" title="常用部署步骤"></a>常用部署步骤</h2><blockquote>
<p>每次部署的步骤，可按以下三步来进行。</p>
</blockquote>
<pre><code>hexo clean
hexo generate
hexo deploy
</code></pre>
<span id="more"></span>
<h6 id="一些常用命令："><a href="#一些常用命令：" class="headerlink" title="一些常用命令："></a>一些常用命令：</h6><pre><code>hexo new ”postName” #新建文章

hexo new page ”pageName” #新建页面

hexo generate #生成静态页面至public目录

hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）

hexo deploy #将.deploy目录部署到GitHub

hexo help # 查看帮助

hexo version #查看Hexo的版本
</code></pre>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Markdown的基本用法</title>
    <url>/2018/07/11/markerdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>Markdown 是一种文本格式。你可以用它来控制文档的显示。使用 markdown，你可以创建粗体的文字，斜体的文字，添加图片，并且创建列表 等等。基本上来讲，Markdown 就是普通的文字加上 # 或者 * 等符号。</p>
<span id="more"></span>

<h3 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h3><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># 这是 <span class="tag">&lt;<span class="name">h1</span>&gt;</span> 一级标题</span><br><span class="line">## 这是 <span class="tag">&lt;<span class="name">h2</span>&gt;</span> 二级标题</span><br><span class="line">### 这是 <span class="tag">&lt;<span class="name">h3</span>&gt;</span> 三级标题</span><br><span class="line">#### 这是 <span class="tag">&lt;<span class="name">h4</span>&gt;</span> 四级标题</span><br><span class="line">##### 这是 <span class="tag">&lt;<span class="name">h5</span>&gt;</span> 五级标题</span><br><span class="line">###### 这是 <span class="tag">&lt;<span class="name">h6</span>&gt;</span> 六级标题</span><br></pre></td></tr></table></figure>
<h4 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">*这会是 斜体 的文字*</span><br><span class="line">_这会是 斜体 的文字_</span><br><span class="line"></span><br><span class="line">**这会是 粗体 的文字**</span><br><span class="line">__这会是 粗体 的文字__</span><br><span class="line"></span><br><span class="line">_你也 **组合** 这些符号_</span><br><span class="line"></span><br><span class="line">~~这个文字将会被横线删除~~</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">- Item 1</span><br><span class="line">- Item 2</span><br><span class="line">  - Item 2a</span><br><span class="line">  - Item 2b</span><br></pre></td></tr></table></figure>
<h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1. Item 1</span><br><span class="line">1. Item 2</span><br><span class="line">1. Item 3</span><br><span class="line">   1. Item 3a</span><br><span class="line">   1. Item 3b</span><br></pre></td></tr></table></figure>
<h4 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">![GitHub Logo](/images/logo.png)</span><br><span class="line">Format: ![Alt Text](url)</span><br></pre></td></tr></table></figure>
<p>测试图片：<br><img src="/uploads/author.jpg" alt="GitHub Logo"></p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">https://github.com - 自动生成！</span><br><span class="line">[GitHub](https://github.com)</span><br></pre></td></tr></table></figure>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">正如 Kanye West 所说：</span><br><span class="line"></span><br><span class="line">&gt; We&#x27;re living the future so</span><br><span class="line">&gt; the present is our past.</span><br></pre></td></tr></table></figure>
<h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">如下，三个或者更多的:</span><br><span class="line"></span><br><span class="line">连字符: ---</span><br><span class="line"></span><br><span class="line">星号: ***</span><br><span class="line"></span><br><span class="line">下划线: ___</span><br></pre></td></tr></table></figure>
<h4 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">我觉得你应该在这里使用</span><br><span class="line">`function()&#123;console.log(&#x27;行内代码&#x27;)&#125;` </span><br><span class="line">才对。</span><br></pre></td></tr></table></figure>
<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>你可以在你的代码上面和下面添加 ``` 来表示代码块</p>
<h5 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h5><p>代码块可以添加任何一种语言的语法高亮，如：</p>
<figure class="highlight javascript"><figcaption><span>&#123;.class1 .class&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="代码行数"><a href="#代码行数" class="headerlink" title="代码行数"></a>代码行数</h5><p>如果你想要你的代码块显示代码行数，只要添加 line-numbers class 就可以了。例如：</p>
<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以通过添加 highlight 属性的方式来高亮代码行数，例如：</p>
<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers, highlight</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> number = add(<span class="number">10</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<h4 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">- [x] @mentions, #refs, [links](), **formatting**, and <span class="tag">&lt;<span class="name">del</span>&gt;</span>tags<span class="tag">&lt;/<span class="name">del</span>&gt;</span> supported</span><br><span class="line">- [x] list syntax required (any unordered or ordered list supported)</span><br><span class="line">- [x] this is a complete item</span><br><span class="line">- [ ] this is an incomplete item</span><br></pre></td></tr></table></figure>
<ul>
<li><input checked="" disabled="" type="checkbox"> @mentions, #refs, <a href="">links</a>, <strong>formatting</strong>, and <del>tags</del> supported</li>
<li><input checked="" disabled="" type="checkbox"> list syntax required (any unordered or ordered list supported)</li>
<li><input checked="" disabled="" type="checkbox"> this is a complete item</li>
<li><input disabled="" type="checkbox"> this is an incomplete item<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">First Header | Second Header</span><br><span class="line">------------ | -------------</span><br><span class="line">Content from cell 1 | Content from cell 2</span><br><span class="line">Content in the first column | Content in the second column</span><br></pre></td></tr></table></figure>
First Header | Second Header</li>
<li>———– | ————-<br>Content from cell 1 | Content from cell 2<br>Content in the first column | Content in the second column</li>
</ul>
<h3 id="扩展的语法"><a href="#扩展的语法" class="headerlink" title="扩展的语法"></a>扩展的语法</h3><h4 id="Emoji-amp-Font-Awesome"><a href="#Emoji-amp-Font-Awesome" class="headerlink" title="Emoji &amp; Font-Awesome"></a>Emoji &amp; Font-Awesome</h4><p>只适用于 markdown-it parser 而不适用于 pandoc parser。 缺省下是启用的。你可以在插件设置里禁用此功能。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">:smile:</span><br><span class="line">:fa-car:</span><br></pre></td></tr></table></figure>
<p>:smile:<br>:fa-car:</p>
<h4 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">30^th^</span><br></pre></td></tr></table></figure>
<p>30^th^</p>
<h4 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">H~2~O</span><br></pre></td></tr></table></figure>
<p>H<del>2</del>O</p>
<h4 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Content [^1]</span><br><span class="line">[^1]: Hi! This is a footnote</span><br></pre></td></tr></table></figure>
<p>Content [^1]<br>[^1]: Hi! This is a footnote</p>
<h4 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">==marked==</span><br></pre></td></tr></table></figure>
<p>==marked==</p>
<p><span>213123</span></p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>九、JavaScript之new的模拟实现</title>
    <url>/2019/09/28/new%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>在MDN中对new运算符的解释是：</p>
<blockquote>
<p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</p>
</blockquote>
<span id="more"></span>
<p>为了更清楚理解，举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">make, model, year</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>)); <span class="comment">// &#123;&#125;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.__proto__ === Car.prototype); <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">this</span>.make = make;</span><br><span class="line">  <span class="built_in">this</span>.model = model;</span><br><span class="line">  <span class="built_in">this</span>.year = year;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>)); <span class="comment">//&#123;&quot;make&quot;:&quot;Eagle&quot;,&quot;model&quot;:&quot;Talon TSi&quot;,&quot;year&quot;:1993&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car1 = <span class="keyword">new</span> Car(<span class="string">&#x27;Eagle&#x27;</span>, <span class="string">&#x27;Talon TSi&#x27;</span>, <span class="number">1993</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(car1.make); <span class="comment">// Eagle</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，new运算符会进行如下操作：</p>
<ol>
<li>创建一个空的简单JavaScript对象（即{}）；</li>
<li>新对象的__proto__属性指向构造函数的prototype属性 ；</li>
<li>将步骤1新创建的对象作为this的上下文 ；</li>
<li>如果该函数没有返回对象，则返回this。</li>
</ol>
<h3 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h3><p>实现一个new也就意味着不能用new关键字，那么要完成这么一系列步骤，我们通过一个函数newFactory来实现。</p>
<p>请看下面示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 取出第一个参数，就是我们要传入的构造函数</span></span><br><span class="line">  <span class="keyword">var</span> func = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 创建一个空对象，并且指定原型为func.prototype</span></span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(func.prototype);</span><br><span class="line">  <span class="comment">// 使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性</span></span><br><span class="line">  <span class="keyword">var</span> ret = func.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// 判断构造函数是否返回对象，有则return该对象，没有则返回this;(特殊情况返回null处理)</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">typeof</span> ret === <span class="string">&quot;object&quot;</span> &amp;&amp; ret !== <span class="literal">null</span>) ? ret : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试一(构造函数无返回对象)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Otaku</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.habit = <span class="string">&#x27;Games&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Otaku.prototype.strength = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">Otaku.prototype.sayYourName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I am &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = newFactory(Otaku, <span class="string">&#x27;Kevin&#x27;</span>, <span class="string">&#x27;18&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Kevin</span></span><br><span class="line"><span class="built_in">console</span>.log(person.habit) <span class="comment">// Games</span></span><br><span class="line"><span class="built_in">console</span>.log(person.strength) <span class="comment">// 60</span></span><br><span class="line"></span><br><span class="line">person.sayYourName(); <span class="comment">// I am Kevin</span></span><br></pre></td></tr></table></figure>

<p>测试二(构造函数有返回对象)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Otaku</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.habit = <span class="string">&#x27;Games&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Otaku.prototype.strength = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">Otaku.prototype.sayYourName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;I am &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = newFactory(Otaku, <span class="string">&#x27;Kevin&#x27;</span>, <span class="string">&#x27;18&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// Kevin</span></span><br><span class="line"><span class="built_in">console</span>.log(person.habit) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(person.strength) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">person.sayYourName(); <span class="comment">// person.sayYourName is not a function</span></span><br></pre></td></tr></table></figure>


<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://github.com/mqyqingfeng/Blog/issues/11">https://github.com/mqyqingfeng/Blog/issues/11</a></p>
]]></content>
      <categories>
        <category>深入理解JavaScript系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法学习</title>
    <url>/2016/06/13/next_study/</url>
    <content><![CDATA[<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><pre><code># 这是 H1 #

## 这是 H2 ##

### 这是 H3 ######
</code></pre>
<span id="more"></span>
<h3 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h3><pre><code>&gt;This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
&gt;&gt;Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
&gt; 
&gt; 1.   这是第一行列表项。
&gt; 2.   这是第二行列表项。
&gt; 
&gt; 给出一些例子代码：
&gt; 
&gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);
</code></pre>
<blockquote>
<p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,<br>consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</p>
<blockquote>
<p>Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>
</blockquote>
<ol>
<li>  这是第一行列表项。</li>
<li>  这是第二行列表项。</li>
</ol>
<p>给出一些例子代码：</p>
<pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);
</code></pre>
</blockquote>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><pre><code>&gt;&gt; * Red
* Green
* Blue
&gt;&gt; + Tom
+ Jack 
+ Jerry
&gt;&gt; + 张三丰
+ 张翠山
+ 张无忌
&gt; 有序列表 1.
&gt;&gt; 1.  Bird
2.  McHale
3.  Parish

&gt; 1.  This is a list item with two paragraphs. Lorem ipsum dolor
    sit amet, consectetuer adipiscing elit. Aliquam hendrerit
    mi posuere lectus.

&gt;   Vestibulum enim wisi, viverra nec, fringilla in, laoreet
    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
    sit amet velit.

&gt; 2.  Suspendisse id sem consectetuer libero luctus adipiscing.
1986\. What a great season.
</code></pre>
<blockquote>
<p>无序列表 *,+,-</p>
<blockquote>
<ul>
<li>Red</li>
</ul>
</blockquote>
</blockquote>
<ul>
<li>Green</li>
<li>Blue<blockquote>
<blockquote>
<ul>
<li>Tom</li>
</ul>
</blockquote>
</blockquote>
</li>
</ul>
<ul>
<li>Jack </li>
<li>Jerry<blockquote>
<blockquote>
<ul>
<li>张三丰</li>
</ul>
</blockquote>
</blockquote>
</li>
<li>张翠山</li>
<li>张无忌<blockquote>
<p>有序列表 1.</p>
<blockquote>
<ol>
<li> Bird</li>
</ol>
</blockquote>
</blockquote>
</li>
</ul>
<ol start="2">
<li> McHale</li>
<li> Parish</li>
</ol>
<blockquote>
<ol>
<li>This is a list item with two paragraphs. Lorem ipsum dolor<br> sit amet, consectetuer adipiscing elit. Aliquam hendrerit<br> mi posuere lectus.</li>
</ol>
</blockquote>
<blockquote>
<p>  Vestibulum enim wisi, viverra nec, fringilla in, laoreet<br>    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum<br>    sit amet velit.</p>
</blockquote>
<blockquote>
<ol start="2">
<li> Suspendisse id sem consectetuer libero luctus adipiscing.<br>1986. What a great season.</li>
</ol>
</blockquote>
<h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><p>这是一个普通的段落：</p>
<pre><code>这是一个代码区块
&lt;div class=&quot;footer&quot;&gt;
    &amp;copy; 2004 Foo Corporation
&lt;/div&gt;
</code></pre>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>

<pre><code>* * *

***

*****

- - -

---------------------------------------
</code></pre>
<hr/>

<h3>区段元素</h3>
> #### 链接
<p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。
不管是哪一种，链接文字都是用 [方括号] 来标记。
要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：</p>
>
>     This is [an example](http://example.com/ "Title") inline link.
> 
>     [This link](http://example.net/) has no title attribute.
> 会产生
> This is [an example](https://munachar.github.io/404.html "Title") inline link.
> 
> [This link](http://www.baidu.com/) has no title attribute.
> 下面是一个参考式链接的范例：
>
>      I get 10 times more traffic from [Google] [1] than from[Yahoo] [2] or [MSN] [3].
>
>          [1]: http://google.com/        "Google"
>          [2]: http://search.yahoo.com/  "Yahoo Search"
>          [3]: http://search.msn.com/    "MSN Search" 
> 或者：
>
>     I get 10 times more traffic from [Google][] than from[Yahoo][] or [MSN][].
>
>          [google]: http://google.com/        "Google"
>          [yahoo]:  http://search.yahoo.com/  "Yahoo Search"
>          [msn]:    http://search.msn.com/    "MSN Search"br
> #### 强调
<p>Markdown 使用星号（\*）和底线（\_）作为标记强调字词的符号，被 \* 或 \_ 包围的字词会被转成用 <\em\> 标签包围，用两个 \* 或 \_ 包起来的话，则会被转成 <strong>，例如：</p>
>
>     *single asterisks*
>
>     _single underscores_
>
>     **double asterisks**
>
>     __double underscores__
>效果如下：
> *single asterisks*
>
> _single underscores_
>
> **double asterisks**
>
> __double underscores__
> #### 代码
如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如：
>
>     Use the `printf()` function.
效果如下：
> Use the `printf()` function.
> A single backtick in a code span: `` ` ``
>
> A backtick-delimited string in a code span: `` `<foo>` ``
> #### 图片
Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。

<blockquote>
<p>行内式的图片语法看起来像是：</p>
<pre><code>![Alt text](/path/to/img.jpg)

![Alt text](/path/to/img.jpg &quot;Optional title&quot;)
</code></pre>
<p>详细叙述如下：</p>
<ul>
<li>一个惊叹号 !</li>
<li>接着一个方括号，里面放上图片的替代文字</li>
<li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 ‘title’ 文字。</li>
</ul>
</blockquote>
<blockquote>
<p>参考式的图片语法则长得像这样：</p>
</blockquote>
<pre>![Alt text][id]</pre>
<blockquote>
<p>「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：</p>
<pre><code>[id]: url/to/image  &quot;Optional title attribute&quot;
</code></pre>
<p>到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 <img> 标签。</p>
</blockquote>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><blockquote>
<h4 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h4><p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p>
<pre><code>&lt;http://example.com/&gt;
</code></pre>
<p>Markdown 会转为：</p>
<pre><code>&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;
</code></pre>
<p>邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：</p>
<pre><code>&lt;address@example.com&gt;
</code></pre>
<p>Markdown 会转成：</p>
<pre><code> &lt;a href=&quot;&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;
&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;
&amp;#109;&quot;&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;
&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;
</code></pre>
<p>在浏览器里面，这段字串（其实是 <a href="mailto:address@example.com">address@example.com</a>）会变成一个可以点击的「<a href="mailto:&#x61;&#x64;&#100;&#x72;&#101;&#x73;&#x73;&#64;&#x65;&#x78;&#x61;&#109;&#112;&#x6c;&#x65;&#46;&#99;&#x6f;&#x6d;">&#x61;&#x64;&#100;&#x72;&#101;&#x73;&#x73;&#64;&#x65;&#x78;&#x61;&#109;&#112;&#x6c;&#x65;&#46;&#99;&#x6f;&#x6d;</a>」链接。</p>
</blockquote>
<p>（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）</p>
<blockquote>
<h4 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h4><p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 <em> 标签），你可以在星号的前面加上反斜杠：</p>
<pre><code>\*literal asterisks\*
</code></pre>
<p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p>
<pre><code>\   反斜线
`   反引号
*   星号
_   底线
&#123;&#125;  花括号
[]  方括号
()  括弧
#   井字号
+   加号
-   减号
.   英文句点
!   惊叹号
</code></pre>
</blockquote>
]]></content>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>postName</title>
    <url>/2015/08/12/postName/</url>
    <content><![CDATA[<pre><code>1. Git安装和Github设置
使用Mac电脑可以直brew安装,
</code></pre>
<span id="more"></span>

<pre><code>brew install git         #Mac电脑使用brew安装
sudo apt-get install git #Ubuntu系统使用这条命令安装
git操作和github上SSH设置请看这篇博文

使用Github Page搭建博客, 需要遵循一定的规则, 需要在github建立仓库,仓库名为Github用户.github.io, 更多详情请参考官方文档

2. Node.js安装
mac电脑可以直接通过brew安装

#安装命令
brew install node  #如果我没记错的话,最新版的node.js的包中已经集成了npm包管理工具

使用以下命令验证是否安装成功
node -v
npm -v

文／Andrew_liu（简书作者）
原文链接：http://www.jianshu.com/p/858ecf233db9
著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。
</code></pre>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>postcss-pxtorem的使用</title>
    <url>/2020/11/11/postcss-pxtorem%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>最近公司要开发一个H5的项目，这里用postcss-pxtorem来处理自适应的问题；</p>
<blockquote>
<p>postcss-pxtorem是PostCSS的插件，用于将像素单元生成rem单位。前端开发还原设计稿的重要性毋庸置疑，目前应用的单位最多还是rem,然而每次在制作过程中需要自己计算rem值，为了能够直接按照设计图的尺寸开发，并且能自动编译转换成rem，下面就来分享下postcss-pxtorem的使用。</p>
</blockquote>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install postcss-pxtorem -D</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="设置规则"><a href="#设置规则" class="headerlink" title="设置规则"></a>设置规则</h2><p>更改postcss.config.js,该文件为使用vue-cli3自动创建的文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    &#x27;autoprefixer&#x27;: &#123; // autoprefixer 是自动补全代码用的</span><br><span class="line">      browsers: [&#x27;Android &gt;= 4.0&#x27;, &#x27;iOS &gt;= 7&#x27;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x27;postcss-pxtorem&#x27;: &#123;</span><br><span class="line">      rootValue: 16,//结果为：设计稿元素尺寸/16，比如元素宽320px,最终页面会换算成 20rem</span><br><span class="line">      propList: [&#x27;*&#x27;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="设置根节点"><a href="#设置根节点" class="headerlink" title="设置根节点"></a>设置根节点</h2><p>首先我们要在src目录下，新建 assets/js/rem.js文件；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> e = <span class="built_in">document</span>.documentElement || <span class="built_in">document</span>.body,</span><br><span class="line">    a = <span class="string">&quot;orientationchange&quot;</span> <span class="keyword">in</span> <span class="built_in">window</span> ? <span class="string">&quot;orientationchange&quot;</span> : <span class="string">&quot;resize&quot;</span>,</span><br><span class="line">    b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> f = e.clientWidth;</span><br><span class="line">      <span class="comment">// 320 默认大小16px; 320px = 20rem ;每个元素px基础上/16</span></span><br><span class="line">      e.style.fontSize = f / <span class="number">20</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  b();</span><br><span class="line">  c.addEventListener(a, b, <span class="literal">false</span>);</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后在main.js中引入rem.js就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;@assets/js/rem&quot;</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>vue</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>六、JavaScript之this理解</title>
    <url>/2019/08/06/this/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在前面我们已经知道，当JavaScript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。<br>对于每个执行上下文，都有三个重要属性：</p>
<ul>
<li>变量对象(Variable object，VO)</li>
<li>作用域链(Scope chain)</li>
<li>this<span id="more"></span></li>
</ul>
<p>前面我们已经讨论了变量对象和作用域链，本文主要说说对this的理解。<br>this与上下文的可执行代码类型直接相关。该值在进入上下文时确定，并且在代码在上下文中运行时是不可变的。</p>
<h2 id="全局代码中This的值"><a href="#全局代码中This的值" class="headerlink" title="全局代码中This的值"></a>全局代码中This的值</h2><p>在全局代码中，this值始终是全局对象本身。因此，可以间接引用它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显式定义全局对象</span></span><br><span class="line"><span class="built_in">this</span>.a = <span class="number">10</span>; <span class="comment">// global.a = 10</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过赋值隐式定义</span></span><br><span class="line">b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.b); <span class="comment">// 20</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 全局上下文变量声明</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.c); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
<h2 id="函数代码中This的值"><a href="#函数代码中This的值" class="headerlink" title="函数代码中This的值"></a>函数代码中This的值</h2><p>this的第一个（可能也是主要的）特征是在这种类型代码中的值没有静态绑定到函数。</p>
<p>如上所述，this值是在进入上下文时确定的，如果使用功能代码，则每次的值都可能完全不同。<br>所以，在代码运行时this值是不可变的，即无法为其分配新值，因为它不是变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">x</span>: <span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">test</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> === bar); <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x); <span class="comment">// 20</span></span><br><span class="line">    <span class="comment">// this = foo; // error, Invalid left-hand side in assignment</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x); <span class="comment">// 如果不报错这里将会是10,</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">bar.test(); <span class="comment">// true, 20</span></span><br><span class="line">foo.test = bar.test;</span><br><span class="line"><span class="comment">//现在this的值将指向“foo”——即使我们正在调用相同的函数  </span></span><br><span class="line">foo.test(); <span class="comment">// false, 10</span></span><br></pre></td></tr></table></figure>
<p>那么是什么影响了this函数代码中值的变化呢？有几个因素。</p>
<p>首先，在通常的函数调用中，this是由激活上下文代码的调用者来提供的，即调用函数的父上下文(parent context )。this取决于调用函数的方式。</p>
<p>理解和记住这重要的一点能帮助我们在任何情况下准确无误的确定this值。正是调用函数的方式影响了调用的上下文中的this值，所以，即使是正常的全局函数也会被调用方式的不同形式激活，这些不同的调用方式导致了不同的this值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">foo(); <span class="comment">// global</span></span><br><span class="line"><span class="built_in">console</span>.log(foo === foo.prototype.constructor); <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 但是同一个function的不同的调用表达式，this是不同的</span></span><br><span class="line">foo.prototype.constructor(); <span class="comment">// foo.prototype</span></span><br></pre></td></tr></table></figure>
<p>有可能作为一些对象定义的方法来调用函数，但是this将不会设置为这个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  <span class="attr">bar</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> === foo);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">foo.bar(); <span class="comment">// foo, true</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> exampleFunc = foo.bar;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(exampleFunc === foo.bar); <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 再一次，同一个function的不同的调用表达式，this是不同的</span></span><br><span class="line"> </span><br><span class="line">exampleFunc(); <span class="comment">// global, false</span></span><br></pre></td></tr></table></figure>
<p>为了充分理解this值的确定,我们需要知道在 ECMAScript 规范中还有一种只存在于规范中的类型，它们的作用是用来描述语言底层行为逻辑。<br>本文主要讨论下其中的 Reference 类型。它与 this 的指向有着密切的关联。</p>
<h2 id="引用类型（Reference-type）"><a href="#引用类型（Reference-type）" class="headerlink" title="引用类型（Reference type）"></a>引用类型（Reference type）</h2><p>那么什么是Reference？<a href="https://262.ecma-international.org/6.0/#sec-reference-specification-type">ECMAScript</a>中6.2.3章有介绍：</p>
<blockquote>
<p>The Reference type is used to explain the behaviour of such operators as deletedelete, typeoftypeof, the assignment operators, the supersuper keyword and other language features. For example, the lefthand operand of an assignment is expected to produce a reference.</p>
</blockquote>
<p>翻译一下，Reference 类型用于解释诸如delete、typeof、赋值运算符、super关键字和其他语言功能等运算符的行为 。例如，赋值的左侧操作数预计会产生一个引用<br>再看接下来的这段具体介绍 Reference 的内容:</p>
<blockquote>
<ul>
<li>A Reference is a resolved name or property binding. </li>
<li>A Reference consists of three components, the base value component, the referenced name component, and the Boolean-valued strict reference flag. </li>
<li>The base value component is either undefined, an Object, a Boolean, a String, a Symbol, a Number, a BigInt, or an Environment Record.</li>
<li>A base value component of undefined indicates that the Reference could not be resolved to a binding.</li>
<li>The referenced name component is a String or Symbol value.<br>简单来说，Reference 的构成，由三个组成部分，分别是：</li>
</ul>
</blockquote>
<ul>
<li>base value</li>
<li>referenced name</li>
<li>strict reference</li>
</ul>
<p>base value 就是属性所在的对象或者就是 EnvironmentRecord，它的值只可能是 undefined, an Object, a Boolean, a String, a Number, or an environment record 其中的一种。<br>referenced name 就是属性的名称，它的值可能是 a String or Symbol value。<br>使用伪代码可以将Reference type的值表示为具有三个属性的对象：base（即属性所属的对象）、base中的propertyName和strict reference(如果use strict有效则为真)：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> valueOfReferenceType = &#123;</span><br><span class="line">  <span class="attr">base</span>: &lt;base object&gt;,</span><br><span class="line">  propertyName: &lt;property name&gt;,</span><br><span class="line">  strick: &lt;strict reference&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这里我们需要明白一个很重要的东西，返回引用类型的值只有两种情况：</p>
<ol>
<li>标识符的处理</li>
<li>一个属性访问器</li>
</ol>
<h3 id="标识符的处理"><a href="#标识符的处理" class="headerlink" title="标识符的处理"></a>标识符的处理</h3><p>标示符的处理（标识符的解析）过程，用来确定一个变量（或函数声明）属于哪个变量对象。<br>这个算法的返回值中，总是一个<strong>引用类型的值</strong>，它的base组件是相应的变量对象（或若未找到则为null）,属性名组件是向上查找的标示符的名称。<br>标识符是变量名，函数名，函数参数名和全局对象中未识别的属性名。例如，下面标识符的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在操作的中间结果中，引用类型对应的值如下：</span></span><br><span class="line"><span class="keyword">var</span> fooReference = &#123;</span><br><span class="line">  <span class="attr">base</span>: <span class="built_in">global</span>,</span><br><span class="line">  <span class="attr">propertyName</span>: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">  <span class="attr">strick</span>: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> barReference = &#123;</span><br><span class="line">  <span class="attr">base</span>: <span class="built_in">global</span>,</span><br><span class="line">  <span class="attr">propertyName</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">  <span class="attr">strick</span>: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了从引用类型中得到一个对象真正的值，伪代码中的GetValue方法可以做如下描述：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetValue</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Type(value) != Reference) &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> base = GetBase(value);</span><br><span class="line">  <span class="keyword">if</span> (base === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> base.[[Get]](GetPropertyName(value));</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部的[[Get]]方法返回对象属性真正的值(base.[[Get]] === global)，包括对原型链中继承的属性分析。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GetValue(fooReference); <span class="comment">// 10 </span></span><br><span class="line">GetValue(barReference); <span class="comment">// function object &quot;bar&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="属性访问器"><a href="#属性访问器" class="headerlink" title="属性访问器"></a>属性访问器</h3><p>属性访问器都应该熟悉。它有两种变体：点（.）语法（此时属性名是正确的标示符，且事先知道），或括号语法（[]）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo.bar();</span><br><span class="line">foo[<span class="string">&#x27;bar&#x27;</span>]();</span><br></pre></td></tr></table></figure>
<p>在中间计算的返回值中，引用类型的值如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fooBarReference = &#123;</span><br><span class="line">  <span class="attr">base</span>: foo,</span><br><span class="line">  <span class="attr">propertyName</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">  <span class="attr">strick</span>: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">GetValue(fooBarReference); <span class="comment">// function object &quot;bar&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="引用类型的值与This的关系"><a href="#引用类型的值与This的关系" class="headerlink" title="引用类型的值与This的关系"></a>引用类型的值与This的关系</h3><p>引用类型的值与函数上下文中的this值如何相关？——从最重要的意义上来说。 这个关联的过程是这篇文章的核心。 一个函数上下文中确定this值的通用规则如下：</p>
<p><strong>在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用括号()的左边是引用类型的值，this将设为引用类型值的base对象（base object），在其他情况下（与引用类型不同的任何其它属性），这个值为null。不过，实际不存在this的值为null的情况，因为当this的值为null的时候，其值会被隐式转换为全局对象。</strong><br>注：第5版的ECMAScript中，已经不强迫转换成全局变量了，而是赋值为undefined。</p>
<p>我们看看这个例子中的表现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">foo(); <span class="comment">// global</span></span><br></pre></td></tr></table></figure>
<p>我们看到在调用括号的左边是一个引用类型值（因为foo是一个标示符）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fooReference = &#123;</span><br><span class="line">  <span class="attr">base</span>: <span class="built_in">global</span>,</span><br><span class="line">  <span class="attr">propertyName</span>: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">  <span class="attr">strick</span>: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>相应地，this也设置为引用类型的base对象。即全局对象。</p>
<p>同样，使用属性访问器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  <span class="attr">bar</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">foo.bar(); <span class="comment">// foo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们再次拥有一个引用类型，其base是foo对象，在函数bar激活时用作this。</span></span><br><span class="line"><span class="keyword">var</span> fooBarReference = &#123;</span><br><span class="line">  <span class="attr">base</span>: foo,</span><br><span class="line">  <span class="attr">propertyName</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是，用另外一种形式激活相同的函数，我们得到其它的this值。</span></span><br><span class="line"><span class="keyword">var</span> test = foo.bar;</span><br><span class="line">test(); <span class="comment">// global</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为test作为标示符，生成了引用类型的其他值，其base（全局对象）用作this 值。</span></span><br><span class="line"><span class="keyword">var</span> testReference = &#123;</span><br><span class="line">  <span class="attr">base</span>: <span class="built_in">global</span>,</span><br><span class="line">  <span class="attr">propertyName</span>: <span class="string">&#x27;test&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在，我们可以很明确的告诉你，为什么用表达式的不同形式激活同一个函数会不同的this值，答案在于引用类型（type Reference）不同的中间值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">foo(); <span class="comment">// global, because</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> fooReference = &#123;</span><br><span class="line">  <span class="attr">base</span>: <span class="built_in">global</span>,</span><br><span class="line">  <span class="attr">propertyName</span>: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(foo === foo.prototype.constructor); <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 另外一种形式的调用表达式</span></span><br><span class="line"> </span><br><span class="line">foo.prototype.constructor(); <span class="comment">// foo.prototype, because</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> fooPrototypeConstructorReference = &#123;</span><br><span class="line">  <span class="attr">base</span>: foo.prototype,</span><br><span class="line">  <span class="attr">propertyName</span>: <span class="string">&#x27;constructor&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="函数调用和非引用类型"><a href="#函数调用和非引用类型" class="headerlink" title="函数调用和非引用类型"></a>函数调用和非引用类型</h2><p>正如我们已经指出，当调用括号的左边不是引用类型而是其它类型，这个值自动设置为null，结果为全局对象。<br>让我们再思考这种表达式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// null =&gt; global</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们有一个函数对象但不是引用类型的对象（它不是标示符，也不是属性访问器），相应地，this值最终设为全局对象。</p>
<p>更多复杂的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  <span class="attr">bar</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">foo.bar(); <span class="comment">// Reference, OK =&gt; foo</span></span><br><span class="line">(foo.bar)(); <span class="comment">// Reference, OK =&gt; foo</span></span><br><span class="line"> </span><br><span class="line">(foo.bar = foo.bar)(); <span class="comment">// global?</span></span><br><span class="line">(<span class="literal">false</span> || foo.bar)(); <span class="comment">// global?</span></span><br><span class="line">(foo.bar, foo.bar)(); <span class="comment">// global?</span></span><br></pre></td></tr></table></figure>
<p>为什么我们有一个属性访问器，它的中间值应该为引用类型的值，在某些调用中我们得到的this值不是base对象，而是global对象？</p>
<p>问题在于后面的三个调用，在应用一定的运算操作之后，在调用括号的左边的值不再是引用类型。</p>
<p>第一个例子很明显———明显的引用类型，结果是，this为base对象，即foo。<br>在第二个例子中，组运算符并不适用，想想上面提到的，从引用类型中获得一个对象真正的值的方法，如GetValue。相应的，在组运算的返回中———我们得到仍是一个引用类型。这就是this值为什么再次设为base对象，即foo。<br>第三个例子中，与组运算符不同，赋值运算符调用了GetValue方法。返回的结果是函数对象（但不是引用类型），这意味着this设为null，结果是global对象。<br>第四个和第五个也是一样——逗号运算符和逻辑运算符（OR）调用了GetValue 方法，相应地，我们失去了引用而得到了函数。并再次设为global。</p>
<h2 id="作为构造器调用的函数中的this"><a href="#作为构造器调用的函数中的this" class="headerlink" title="作为构造器调用的函数中的this"></a>作为构造器调用的函数中的this</h2><p>还有一个与this值相关的情况是在函数的上下文中，这是一个构造函数的调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// &quot;a&quot;对象下创建一个新属性</span></span><br><span class="line">  <span class="built_in">this</span>.x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="built_in">console</span>.log(a.x); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，new运算符调用“A”函数的内部的[[Construct]] 方法，接着，在对象创建后，调用内部的[[Call]] 方法。 所有相同的函数“A”都将this的值设置为新创建的对象。</p>
<h2 id="函数调用中手动设置this"><a href="#函数调用中手动设置this" class="headerlink" title="函数调用中手动设置this"></a>函数调用中手动设置this</h2><p>在函数原型中定义的两个方法（因此所有的函数都可以访问它）允许去手动设置函数调用的this值。它们是.apply和.call方法。他们用接受的第一个参数作为this值，this 在调用的作用域中使用。这两个方法的区别很小，对于.apply，第二个参数必须是数组（或者是类似数组的对象，如arguments，反过来，.call能接受任何参数。两个方法必须的参数是第一个——this。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.b);</span><br><span class="line">  <span class="built_in">console</span>.log(c);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">a(<span class="number">20</span>); <span class="comment">// this === global, this.b == 10, c == 20</span></span><br><span class="line"> </span><br><span class="line">a.call(&#123;<span class="attr">b</span>: <span class="number">20</span>&#125;, <span class="number">30</span>); <span class="comment">// this === &#123;b: 20&#125;, this.b == 20, c == 30</span></span><br><span class="line">a.apply(&#123;<span class="attr">b</span>: <span class="number">30</span>&#125;, [<span class="number">40</span>]) <span class="comment">// this === &#123;b: 30&#125;, this.b == 30, c == 40</span></span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-3-this/">http://dmitrysoshnikov.com/ecmascript/ru-chapter-3-this/</a></li>
<li><a href="https://javascript.info/reference-type">https://javascript.info/reference-type</a></li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>事件冒泡</title>
    <url>/2016/06/25/%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1/</url>
    <content><![CDATA[<h3 id="什么是JS事件冒泡？"><a href="#什么是JS事件冒泡？" class="headerlink" title="什么是JS事件冒泡？"></a>什么是JS事件冒泡？</h3><p>在一个对象上触发某类事件（比如单击onclick事件），如果此对象定义了此事件的处理程序，那么此事件就会调用这个处理程序，如果没有定义此事件处理程序或者事件返回true，那么这个事件会向这个对象的父级对象传播，从里到外，直至它被处理（父级对象所有同类事件都将被激活），或者它到达了对象层次的最顶层，即document对象（有些浏览器是window）。</p>
<span id="more"></span>

<ol>
<li><p>event.stopPropagation();<br>事件处理过程中，阻止了事件冒泡，但不会阻击默认行为（它就执行了超链接的跳转）</p>
</li>
<li><p>return false;<br>事件处理过程中，阻止了事件冒泡，也阻止了默认行为（比如刚才它就没有执行超链接的跳转）</p>
</li>
<li><p>event.preventDefault();<br>如果把它放在头部A标签的click事件中点击“点击我”。<br>会发现它依次弹出：我是最里层—-&gt;我是中间层—-&gt;我是最外层，但最后却没有跳转到百度<br>它的作用是：事件处理过程中，不阻击事件冒泡，但阻击默认行为（它只执行所有弹框，却没有执行超链接跳转）</p>
</li>
</ol>
<hr>
<h3 id="事件周期"><a href="#事件周期" class="headerlink" title="事件周期:"></a>事件周期:</h3><blockquote>
<p>DOM: 3个阶段:</p>
<blockquote>
<ul>
<li>捕获: 由最外层元素向内，逐级记录绑定的事件处理函数，只是记录，而不触发</li>
</ul>
</blockquote>
</blockquote>
<ul>
<li>目标触发: 首先触发实际发生事件的元素上绑定的处理函数（目标元素: 实际发生事件的元素）</li>
<li>冒泡: 由内层向外层依次执行各级绑定的处理函数<blockquote>
<p>鄙视:能否修改事件触发的顺序: ——能！</p>
<pre><code> elem.addEventListener(“事件名”,函数对象,false/true);
</code></pre>
<p>第三个参数: 是否在捕获阶段提前触发，<br>默认false，只能在冒泡阶段顺序触发<br>改为true，可在捕获阶段提前触发！<br>在捕获阶段提前触发的处理函数，冒泡阶段不会重复触发。<br>IE8: 2个阶段: 没有捕获！——不能修改事件触发的顺序<br>elem.attachEvent(“on事件名”,函数对象)</p>
</blockquote>
</li>
</ul>
<h3 id="取消冒泡"><a href="#取消冒泡" class="headerlink" title="取消冒泡"></a>取消冒泡</h3><blockquote>
<p>取消冒泡: 一般用于事件处理函数的末尾</p>
<pre><code>DOM: e.stopPropagation();
IE8: e.cancelBubble=true;
</code></pre>
<p>兼容: </p>
<pre><code>if(e.stopPropagation!==undefined)&#123;
    e.stopPropagation();
&#125;else&#123;
    e.cancelBubble=true;
&#125;
</code></pre>
<p>利用冒泡:<br>优化: 如果多个平级子元素都绑定了相同的事件处理函数，则只需要在父元素上绑定一次即可。不必反复绑定！<br>为什么: 绑定的事件处理函数越多，页面的执行效率越低。应尽量减少页面中绑定的事件处理函数个数。<br>核心问题：如何获得目标元素:</p>
<pre><code>var target=e.target||e.srcElement
</code></pre>
</blockquote>
<h3 id="DOM-IE8"><a href="#DOM-IE8" class="headerlink" title="DOM IE8"></a>DOM IE8</h3><blockquote>
<p>取消事件: 在事件处理函数执行过程中，发生了异常或错误，希望事件不再继续触发。<br>如何取消:<br>   js动态绑定事件处理函数: </p>
<pre><code>DOM: e.preventDefault();
IE8: e.returnValue=false;
</code></pre>
<p>兼容: </p>
<pre><code>if(e.preventDefault!==undefined)&#123;
    e.preventDefault();
&#125;else&#123;
    e.returnValue=false;
&#125; 
</code></pre>
</blockquote>
<p>参考网址：<a href="http://www.jb51.net/article/32792.htm">事件冒泡</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>二、JavaScript之作用域</title>
    <url>/2019/06/15/%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h2><p>作用域是指程序源代码中定义变量的区域。</p>
<p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p>
<p>JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。</p>
<span id="more"></span>
<h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>在你不知道的javascript上卷中是这样定义的：</p>
<blockquote>
<p>词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变(大部分情况下是这样的)。</p>
</blockquote>
<p>在JS中词法作用域的规则：<a href="https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/scope%20%26%20closures/ch1.md">点这里</a></p>
<p>请看下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var value = 1;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar() &#123;</span><br><span class="line">    var value = 2;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); // ???</span><br></pre></td></tr></table></figure>
<p>假设JavaScript采用静态作用域，让我们分析下执行过程：<br>执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。</p>
<p>假设JavaScript采用动态作用域，让我们分析下执行过程：<br>执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。</p>
<p>前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1。<br>再看下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function foo(a) &#123;</span><br><span class="line"></span><br><span class="line">	var b = a * 2;</span><br><span class="line"></span><br><span class="line">	function bar(c) &#123;</span><br><span class="line">		console.log( a, b, c );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bar(b * 3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo( 2 ); // 2 4 12</span><br></pre></td></tr></table></figure>
<p>在这个代码示例中有三个固有的嵌套作用域：</p>
<ul>
<li>包围着全局作用域，只有一个标识符：foo。</li>
<li>包围着作用域 foo，它含有三个标识符：a，bar 和 b。</li>
<li>包围着作用域 bar，它里面只包含一个标识符：c。</li>
</ul>
<p>当我们执行console.log(…)语句的时候，开始查找三个被引用的变量 a，b 和 c。它首先从最内部的作用域气泡开始，也就是 bar(…) 函数的作用域。在这里它找不到 a，所以它向上走一层，到外面下一个最近的作用域气泡，foo(…) 的作用域。它在这里找到了 a，于是它就使用这个 a。同样的事情也发生在 b 身上。但是对于 c，它在 bar(..) 内部就找到了。</p>
<p>如果在 foo(..) 内部定义一个变量 c，console.log(…) 语句也仍然会找到并使用 bar(…) 中的那一个，而不会使用 foo(…) 中的那一个。</p>
<p><strong>一旦找到第一个匹配，作用域查询就停止了。</strong>相同的标识符名称可以在嵌套作用域的多个层中被指定，这称为“遮蔽（shadowing）”（内部的标识符“遮蔽”了外部的标识符）。无论如何遮蔽，作用域查询总是从当前被执行的最内侧的作用域开始，向外/向上不断查找，直到第一个匹配才停止。</p>
<p><strong>注意：</strong>全局变量也自动地是全局对象（在浏览器中是 window，等等）的属性，所以不直接通过全局变量的词法名称，而通过将它作为全局对象的一个属性引用来间接地引用，是可能的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 5;</span><br><span class="line">function foo(a) &#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">  console.log(window.a)</span><br><span class="line">&#125;</span><br><span class="line">foo(2) // 2,5</span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://github.com/mqyqingfeng/Blog/issues/3">https://github.com/mqyqingfeng/Blog/issues/3</a></p>
]]></content>
      <categories>
        <category>深入理解JavaScript系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>五、JavaScript之作用域链</title>
    <url>/2019/07/18/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
    <content><![CDATA[<p>在上一篇的文章中，我们了解到执行上下文数据（变量、函数声明和函数的所有形参）是由这个变量对象的属性存储的，另外，我们知道每次进入上下文时都会创建变量对象并填充初始化值，并且在执行上下文代码时会发生它的修改。</p>
<p>下面我们叫了解执行上下文相关的另一个概念：作用域链。</p>
<span id="more"></span>

<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>作用域链（Scope，Scope chain，缩写 SC）是与执行上下文相关联的变量对象链，在解析标识符名称时在其中搜索变量。</p>
</blockquote>
<p>简而言之，作用域链更多的是关于嵌套函数。</p>
<p>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">20</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(x + y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line">foo()(); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p>同时，我们知道每个上下文都有自己的变量对象：对于全局上下文，这是全局对象本身，对于函数，这是活动对象。<br>作用域链是嵌套上下文的这些（父）变量对象的列表。该链用于搜索变量。那些。从上面的例子来看，“bar”上下文的作用域链将包括 AO (bar)、AO (foo) 和 VO (global)。</p>
<p>函数的作用域链是在执行时创建的，由一个活动对象和一个内部[[Scope]]函数属性组成。我们将在下面讨论 [[Scope]] 属性。</p>
<p>前面我们写了执行上下文的组称代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ExecutionContextObj = &#123;</span><br><span class="line">  <span class="attr">VO</span>: <span class="built_in">window</span>, <span class="comment">// 变量对象</span></span><br><span class="line">  <span class="attr">Scope</span>: &#123;&#125;, <span class="comment">// 作用域链</span></span><br><span class="line">  <span class="attr">this</span>: <span class="built_in">window</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中 Scope 的定义是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Scope = AO + [[Scope]];</span><br></pre></td></tr></table></figure>

<p>如果我们将 Scope 和 [[Scope]] 以普通 JavaScript 数组的形式表示——这样会更清晰。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Scope = [VO1, VO2, ..., VOn]; <span class="comment">// scope chain</span></span><br></pre></td></tr></table></figure>

<p>换种说法[[scope]] 就是所有父变量对象的层级链。</p>
<h2 id="函数声明周期"><a href="#函数声明周期" class="headerlink" title="函数声明周期"></a>函数声明周期</h2><p>函数的生命周期分为创建阶段和激活（调用）阶段。现在我们从这两个方面来详细地分析它们。</p>
<h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><p>我们知道，函数声明在进入上下文阶段就属于变量对象（VO）/激活对象（AO）。思考一个在全局上下文中声明变量和函数的示例（其中变量对象是全局对象本身）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p>执行之后我们看到了符合预期的结果：30，但是这里有一个很重要特性。<br>到目前为止，我们只讨论了同一上下文中的变量对象。这里我们看到变量“y”是在函数“foo”中定义的（也就是说它在函数“foo”的上下文的 AO 中），但是变量“x”在进入上下文的时候是没有在任何地方定义（因此，在 AO 中没有添加；“在表面上”，对于“foo”函数来说，“x”变量根本不存在，但是，正如我们将在下面看到的，只有“在表面上” ）。函数上下文活动对象“foo”只包含一个属性——“y”属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fooContext.AO = &#123;</span><br><span class="line">  <span class="attr">y</span>: <span class="literal">undefined</span>, <span class="comment">// undefined - 进入执行上下文时, 20 - 执行时</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么函数“foo”是如何取到变量“x”的值？实际上它是通过函数内部的[[scope]]属性来实现的。<br><img src="/images/scope.png" alt="(流程图)"><br>我们声明了一个函数 foo,需要查看 foo 的原型对象才能看到[[scopes]]属性，因为 foo.prototype.constructor===foo，所以展开 constructor 选项。<br>可以看到[[scopes]]属性是一个数组，里面只有一个元素 Global,也就是全局对象。<br>需要注意的一点－－[[scope]]在函数创建时被存储－－静态（不变的），直至函数销毁。即：函数可以永不调用，但[[scope]]属性已经写入，并存储在函数对象中，同时[[scope]] 并不代表完整的作用域链。<br>所以上面列子函数“foo”的[[scope]]如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo[[Scope]] = [</span><br><span class="line">  globalContext.VO, <span class="comment">// === Global</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h3 id="函数激活"><a href="#函数激活" class="headerlink" title="函数激活"></a>函数激活</h3><p>当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端，作为作用域数组的第一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Scope = [AO].concat([[Scope]]);</span><br></pre></td></tr></table></figure>

<p>至此，作用域链创建完毕。</p>
<p>下面我们用一个例子，结合着之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">20</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> z = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x + y + z);</span><br><span class="line">  &#125;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// 60</span></span><br></pre></td></tr></table></figure>

<p>执行过程如下：</p>
<ol>
<li>全局上下文的变量对象是：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">globalContext.VO === Global = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">10</span></span><br><span class="line">  <span class="attr">foo</span>: <span class="xml"><span class="tag">&lt;<span class="name">reference</span> <span class="attr">to</span> <span class="attr">function</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>foo 函数被创建，保存作用域链到内部属性[[scope]]:</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo.[[scope]] = [globalContext.VO];</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>执行 foo 函数，创建 foo 函数执行上下文，foo 函数执行上下文被压入执行上下文栈:</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ECStack = [fooContext, globalContext];</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>foo 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链:</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fooContext = &#123;</span><br><span class="line">  <span class="attr">Scope</span>: foo.[[scope]],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fooContext = &#123;</span><br><span class="line">    <span class="attr">AO</span>: &#123;</span><br><span class="line">        <span class="attr">arguments</span>: &#123;</span><br><span class="line">            <span class="attr">length</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">y</span>: <span class="literal">undefined</span>,</span><br><span class="line">        <span class="attr">bar</span>: reference to <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    &#125;，</span><br><span class="line">    <span class="attr">Scope</span>: foo.[[scope]],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>第三步：将活动对象压入 foo 作用域链顶端</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fooContext = &#123;</span><br><span class="line">    <span class="attr">AO</span>: &#123;</span><br><span class="line">        <span class="attr">arguments</span>: &#123;</span><br><span class="line">            <span class="attr">length</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">y</span>: <span class="literal">undefined</span>,</span><br><span class="line">        <span class="attr">bar</span>: reference to <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">Scope</span>: [fooContext.AO, foo.[[Scope]]] <span class="comment">// 等同于 [fooContext.AO, globalContext.VO]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>执行函数 foo ，修改 AO 的属性值</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fooContext = &#123;</span><br><span class="line">    <span class="attr">AO</span>: &#123;</span><br><span class="line">        <span class="attr">arguments</span>: &#123;</span><br><span class="line">            <span class="attr">length</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">y</span>: <span class="number">20</span>,</span><br><span class="line">        <span class="attr">bar</span>: reference to <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">Scope</span>: [fooContext.AO, foo.[[Scope]]] <span class="comment">// 等同于 [fooContext.AO, globalContext.VO]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>修改y值后，内部函数 bar 开始创建：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其[[scope]]为：</span></span><br><span class="line">bar.[[Scope]] = [</span><br><span class="line">  fooContext.AO,</span><br><span class="line">  globalContext.VO</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行上下文栈</span></span><br><span class="line">ECStack = [barContext, fooContext, globalContext];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制函数[[scope]]属性创建作用域链</span></span><br><span class="line">barContext = &#123;</span><br><span class="line">  <span class="attr">Scope</span>: bar.[[Scope]],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并初始化 bar 上下文活动对象</span></span><br><span class="line">barContext = &#123;</span><br><span class="line">    <span class="attr">AO</span>: &#123;</span><br><span class="line">        <span class="attr">arguments</span>: &#123;</span><br><span class="line">            <span class="attr">length</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">z</span>: <span class="literal">undefined</span>,</span><br><span class="line">    &#125;，</span><br><span class="line">    <span class="attr">Scope</span>: bar.[[scope]],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将活动对象压入 bar 作用域链顶端</span></span><br><span class="line">barContext = &#123;</span><br><span class="line">    <span class="attr">AO</span>: &#123;</span><br><span class="line">        <span class="attr">arguments</span>: &#123;</span><br><span class="line">            <span class="attr">length</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">z</span>: <span class="literal">undefined</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">Scope</span>: [barContext.AO, bar.[[Scope]]] <span class="comment">// 等同于 [barContext.AO, fooContext.AO, globalContext.VO]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行函数 bar ，修改bar.AO 的属性值</span></span><br><span class="line">barContext = &#123;</span><br><span class="line">    <span class="attr">AO</span>: &#123;</span><br><span class="line">        <span class="attr">arguments</span>: &#123;</span><br><span class="line">            <span class="attr">length</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">z</span>: <span class="number">30</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">Scope</span>: [barContext.AO, bar.[[Scope]]] <span class="comment">// 等同于 [barContext.AO, fooContext.AO, globalContext.VO]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>执行console.log语句，对“x”、“y”、“z”的标识符解析如下：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">- <span class="string">&quot;x&quot;</span></span><br><span class="line">-- barContext.AO <span class="comment">// not found</span></span><br><span class="line">-- fooContext.AO <span class="comment">// not found</span></span><br><span class="line">-- globalContext.VO <span class="comment">// found - 10</span></span><br><span class="line"></span><br><span class="line">- <span class="string">&quot;y&quot;</span></span><br><span class="line">-- barContext.AO <span class="comment">// not found</span></span><br><span class="line">-- fooContext.AO <span class="comment">// found - 20</span></span><br><span class="line"></span><br><span class="line">- <span class="string">&quot;z&quot;</span></span><br><span class="line">-- barContext.AO <span class="comment">// found - 30</span></span><br></pre></td></tr></table></figure>
<ol start="9">
<li>打印x,y,z的之后，函数执行完毕，函数上下文从执行上下文栈中依次弹出</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bar函数出栈</span></span><br><span class="line">ECStack = [fooContext, globalContext];</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo函数出栈</span></span><br><span class="line">ECStack = [globalContext];</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-4-scope-chain/">http://dmitrysoshnikov.com/ecmascript/ru-chapter-4-scope-chain/</a></p>
]]></content>
      <categories>
        <category>深入理解JavaScript系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>八、JavaScript之参数按值传递</title>
    <url>/2019/09/11/%E5%80%BC%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在《JavaScript 高级程序设计》中讲到传递参数：</p>
<blockquote>
<p>ECMAScript 中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。对很多开发者来说，这一块可能会不好理解，毕竟变量有按值和按引用访问，而传参则只有按值传递。</p>
</blockquote>
<span id="more"></span>

<h2 id="按值传递"><a href="#按值传递" class="headerlink" title="按值传递"></a>按值传递</h2><blockquote>
<p>在按值传递参数时，值会被复制到一个局部变量（即一个命名参数，或者用 ECMAScript 的话说，就是 arguments 对象中的一个槽位）。<br>来看一个例子：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  num += <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(num); <span class="comment">// 30</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">20</span>;</span><br><span class="line">foo(count);</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 20，没有变化</span></span><br></pre></td></tr></table></figure>

<p>这里，函数 foo()有一个参数 num，它其实是一个局部变量。在调用时，变量 count 作为参数传入。count 的值 20 被复制给参数 num 。在函数内部，参数 num 的值被加上了 10，但这不会影响函数外部的变量 count。参数 num 和变量 count 互不干扰，它们只不过碰巧保存了一样的值。</p>
<h2 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h2><blockquote>
<p>众所周知按引用传递接收的不是值拷贝，而是对象的隐式引用，如该对象在外部的直接引用地址。函数内部对参数的任何改变都是影响该对象在函数外部的值，因为两者引用的是同一个对象，也就是说：这时候参数就相当于外部对象的一个别名。<br>伪代码：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  o.value = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(o.value); <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line">foo(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.value); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>哪ECMAScript 中函数传递引用数据类型参数是引用传递吗？然而并不是，除了上面两种策略以外，我们看看第三种策略。</p>
<h2 id="共享传递"><a href="#共享传递" class="headerlink" title="共享传递"></a>共享传递</h2><p>共享传递策略还有一些代名词：“按对象传递”或“按对象共享传递”。该策略是1974年由Barbara Liskov为CLU编程语言提出的，策略的要点是：</p>
<blockquote>
<p>函数接收的是对象引用的拷贝（副本），该引用拷贝和形参以及其值相关联。<br>这里出现的引用，我们不能称之为“按引用传递”，因为函数接收的参数不是直接的对象别名，而是该引用地址的拷贝。</p>
</blockquote>
<p>最重要的区别就是：函数内部给参数重新赋新值不会影响到外部的对象（和上例按引用传递的case），但是因为该参数是一个地址拷贝，所以在外面访问和里面访问的都是同一个对象,改变该参数对象的属性值将会影响到外部的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">num</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  obj.num = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(person);</span><br><span class="line"><span class="built_in">console</span>.log(person.num); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>这里，我们创建了一个对象 person 并这个对象被传给 foo 方法，并被复制到参数 obj 中。在函数内部，obj 和 person 都指向同一个对象。个人觉得引用数据类型传递的也是值, 不过这个值是一个地址指针，<br>我们再来看看下面这个修改后的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; <span class="attr">num</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  obj.num = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 将obj引用指针指向了新的一个对象上</span></span><br><span class="line">  obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  obj.num = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.num); <span class="comment">// 1</span></span><br><span class="line">foo(person);</span><br><span class="line"><span class="comment">// 如果这里是按照引用传递，那么，下面的输出应该是3</span></span><br><span class="line"><span class="built_in">console</span>.log(person.num); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>当 person 传入 foo()时，其 num 属性被设置为 2。然后变量 obj 被设置为一个新对象且 num 属性被设置为 3。如果 person 是按引用传递的，那么 person 应该自动将指针改为指向 num 为 3 的对象。可是，当我们再次访问 person.num 时，它的值是 2，这表明函数中参数的值改变之后，原始的引用仍然没变。当 obj 在函数内部被重写时，它变成了一个指向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>如果参数是基本类型，那么是按值传递。</li>
<li>如果参数是引用数据类型，传递的还是值，但是这个值是引用数据类型地址的拷贝。</li>
</ol>
]]></content>
      <categories>
        <category>深入理解JavaScript系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>关于CSS hacks的使用</title>
    <url>/2016/07/10/%E5%85%B3%E4%BA%8ECSS%20hack/</url>
    <content><![CDATA[<h4 id="讨论CSS-hacks，条件引用或者其他。"><a href="#讨论CSS-hacks，条件引用或者其他。" class="headerlink" title="讨论CSS hacks，条件引用或者其他。"></a>讨论CSS hacks，条件引用或者其他。</h4><span id="more"></span>
<pre><code>background-color:#f1ee18;/*所有识别*/

background-color:#00deff\9; /*IE6、7、8识别*/

+background-color:#a200ff;/*IE6、7识别*/

_background-color:#1e0bd1;/*IE6识别*/

:root#test&#123;background-color:purple\9;&#125;:root是给ie9的，

@media screen and (-webkit-min-device-pixel-ratio:0)&#123;
    .bb&#123;background-color:#f1ee18&#125;/* Safari(Chrome) 有效 */
&#125;&#123;&#125; 
@media all and (min-width: 0px)&#123; 
    .bb&#123;
        background-color:#f1ee18;/*opera and Safari(Chrome) and firefox*/ 
        background-color:#4cac70\0;/* 仅 Opera 有效 */ 
    &#125;
&#125;&#123;&#125; 

.bb, x:-moz-any-link, x:default&#123;
    background-color:#4eff00;/*IE7、Firefox3.5及以下 识别 */
&#125; 
@-moz-document url-prefix()&#123;
    .bb&#123;
        background-color:#4eff00;/*仅 Firefox 识别 */
    &#125;
&#125; 
* +html .bb&#123;background-color:#a200ff;&#125;/* 仅IE7 识别 */&lt;!-- more --&gt;    
</code></pre>
<p><img src="/uploads/CSS_hack.png" alt="GitHub Logo"></p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>关于vue中mixins混入的用法</title>
    <url>/2020/06/22/%E5%85%B3%E4%BA%8Emixins%E6%B7%B7%E5%85%A5%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>最近项目中要用到很多eCharts图表组件，需要在窗口尺寸发生变化时，重置图表的大小，此时如果在每个组件里面都去实现一段监听代码，代码重复太多了，此时就可以使用混入来解决这个问题，mixins是Vue提供的一种混合机制，用来更高效的实现组件内容的复用。</p>
<span id="more"></span>

<h1 id="JS代码："><a href="#JS代码：" class="headerlink" title="JS代码："></a>JS代码：</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 混入代码</span></span><br><span class="line"><span class="keyword">import</span> &#123; debounce &#125; <span class="keyword">from</span> <span class="string">&quot;lodash&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> resizeChartMethod = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 在组件内部将图表init的引用映射到chart属性上</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">myChart</span>: <span class="literal">null</span>,</span><br><span class="line">      [resizeChartMethod]: <span class="literal">null</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="built_in">this</span>;</span><br><span class="line">    <span class="built_in">this</span>[resizeChartMethod] = debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (_this.myChart) &#123;</span><br><span class="line">        _this.myChart.resize();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, <span class="built_in">this</span>[resizeChartMethod]);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">beforeDestroy</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">&quot;reisze&quot;</span>, <span class="built_in">this</span>[resizeChartMethod]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="图表组件代码"><a href="#图表组件代码" class="headerlink" title="图表组件代码"></a>图表组件代码</h1><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;chart&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> echartMixins <span class="keyword">from</span> <span class="string">&#x27;./echarts-mixins&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// mixins属性用于导入混入，是一个数组，数组可以传入多个混入对象</span></span><br><span class="line">  <span class="attr">mixins</span>: [echartMixins],</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">chart</span>: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.chart = echarts.init(<span class="built_in">this</span>.$el)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title>八、JavaScript专题之函数柯里化</title>
    <url>/2020/03/15/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    <content><![CDATA[<p>函数式编程是一种编程风格，它尝试将函数作为参数传递（回调）并返回没有副作用的函数。因此带来了一些其他东西，比如纯函数、柯里化、高阶函数。<br>这里我们主要讨论函数柯里化的实现与应用场景。</p>
<span id="more"></span>

<h2 id="什么是柯里化"><a href="#什么是柯里化" class="headerlink" title="什么是柯里化"></a>什么是柯里化</h2><p>柯里化是函数式编程中的一个过程，我们可以将具有多个参数的函数转换为一系列嵌套函数。它返回一个新函数，该函数能接受下一个参数。</p>
<blockquote>
<p>柯里化是将具有多元数的函数变成具有较少元数的函数的过程 - <a href="https://medium.com/@kbrainwave">Kristina Brainwave</a></p>
</blockquote>
<p>举个例子:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b * c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行multiply方法，传入三个参数</span></span><br><span class="line">multiply(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>现在我们创建一个柯里化函数版本：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a * b * c;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">multiply(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>我们已经把 multiply(1,2,3) 函数调用变成了 multiply(1)(2)(3)多个函数的调用。</p>
<p>而对于 Javascript 语言来说，我们通常说的柯里化函数的概念，与数学和计算机科学中的柯里化的概念并不完全一样。<br>在数学和计算机科学中的柯里化函数，一次只能传递一个参数；<br>而我们 Javascript 实际应用中的柯里化函数，可以传递一个或多个参数。<br>来看这个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b, c, d, e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b, c, d, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生成的柯里化函数</span></span><br><span class="line"><span class="keyword">let</span> _fn = curry(fn);</span><br><span class="line"></span><br><span class="line">_fn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// print: 1,2,3,4,5</span></span><br><span class="line">_fn(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// print: 1,2,3,4,5</span></span><br><span class="line">_fn(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>)(<span class="number">5</span>); <span class="comment">// print: 1,2,3,4,5</span></span><br><span class="line">_fn(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>); <span class="comment">// print: 1,2,3,4,5</span></span><br></pre></td></tr></table></figure>

<p>对于已经柯里化后的 _fn 函数来说，当接收的参数数量与原函数的形参数量相同时，执行原函数；<br>当接收的参数数量小于原函数的形参数量时，返回一个函数用于接收剩余的参数，直至接收的参数数量与形参数量一致，执行原函数。<br>当我们知道柯里化是什么了的时候，我们来看看柯里化到底有什么用？</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>柯里化实际是把简答的问题复杂化了，但是复杂化的同时，我们在使用函数时拥有了更加多的自由度，而这里对于函数参数的自由处理，正是柯里化的核心所在。<br>柯里化本质上是降低通用性，提高适用性。来看一个例子：<br>我们工作中会遇到各种需要通过正则检验的需求，比如校验电话号码、校验邮箱、校验身份证号、校验密码等，<br>这时我们会封装一个通用函数 checkByRegExp ,接收两个参数，校验的正则对象和待校验的字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkByRegExp</span>(<span class="params">regExp, string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> regExp.test(string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkByRegExp(<span class="regexp">/^1\d&#123;10&#125;$/</span>, <span class="string">&quot;18642838455&quot;</span>); <span class="comment">// 校验电话号码</span></span><br><span class="line">checkByRegExp(<span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/</span>, <span class="string">&quot;test@163.com&quot;</span>); <span class="comment">// 校验邮箱</span></span><br></pre></td></tr></table></figure>

<p>我们每次进行校验的时候都需要输入一串正则，再校验同一类型的数据时，相同的正则我们需要写多次，<br>这就导致我们在使用的时候效率低下，并且由于 checkByRegExp 函数本身是一个工具函数并没有任何意义，<br>一段时间后我们重新来看这些代码时，如果没有注释，我们必须通过检查正则的内容，<br>我们才能知道我们校验的是电话号码还是邮箱，还是别的什么。<br>此时，我们可以借助柯里化对 checkByRegExp 函数进行封装，以简化代码书写，提高代码可读性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进行柯里化</span></span><br><span class="line"><span class="keyword">let</span> _check = curry(checkByRegExp);</span><br><span class="line"><span class="comment">//生成工具函数，验证电话号码</span></span><br><span class="line"><span class="keyword">let</span> checkCellPhone = _check(<span class="regexp">/^1\d&#123;10&#125;$/</span>);</span><br><span class="line"><span class="comment">//生成工具函数，验证邮箱</span></span><br><span class="line"><span class="keyword">let</span> checkEmail = _check(<span class="regexp">/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/</span>);</span><br><span class="line"></span><br><span class="line">checkCellPhone(<span class="string">&quot;18642838455&quot;</span>); <span class="comment">// 校验电话号码</span></span><br><span class="line">checkCellPhone(<span class="string">&quot;13109840560&quot;</span>); <span class="comment">// 校验电话号码</span></span><br><span class="line">checkCellPhone(<span class="string">&quot;13204061212&quot;</span>); <span class="comment">// 校验电话号码</span></span><br><span class="line"></span><br><span class="line">checkEmail(<span class="string">&quot;test@163.com&quot;</span>); <span class="comment">// 校验邮箱</span></span><br><span class="line">checkEmail(<span class="string">&quot;test@qq.com&quot;</span>); <span class="comment">// 校验邮箱</span></span><br><span class="line">checkEmail(<span class="string">&quot;test@gmail.com&quot;</span>); <span class="comment">// 校验邮箱</span></span><br></pre></td></tr></table></figure>

<p>经过柯里化后，我们生成了两个函数 checkCellPhone 和 checkEmail，<br>checkCellPhone 函数只能验证传入的字符串是否是电话号码，<br>checkEmail 函数只能验证传入的字符串是否是邮箱，<br>它们与 原函数 checkByRegExp 相比，从功能上通用性降低了，但适用性提升了。<br>柯里化的这种用途可以被理解为：参数复用。</p>
<p>我们再来看一个例子，比如我们有这样一段数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = [&#123; <span class="attr">name</span>: <span class="string">&quot;lilei&quot;</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&quot;hanmeimei&quot;</span> &#125;];</span><br></pre></td></tr></table></figure>

<p>如果我们要获取那么属性，我们可以这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = person.map(<span class="function">(<span class="params">item</span>) =&gt;</span> item.name);</span><br></pre></td></tr></table></figure>

<p>如果我们有 curry 函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> prop = curry(<span class="function"><span class="keyword">function</span> (<span class="params">key, obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = person.map(prop(<span class="string">&quot;name&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>这里我们为了获取 name 属性编写一个 prop 函数，你可能会觉得太麻烦了。<br>但是要注意，prop 函数编写一次后，以后可以多次使用，我们在考虑代码复杂的的时候，是可以将 prop 函数的实现去掉的，实际上代码从原本的三行精简成了一行。</p>
<h2 id="柯里化工具函数封装"><a href="#柯里化工具函数封装" class="headerlink" title="柯里化工具函数封装"></a>柯里化工具函数封装</h2><p>常见 curry 函数的实现为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> curry = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArgs = args.concat([].slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, newArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> addCurry = curry(add, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">addCurry(); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">var</span> addCurry = curry(add, <span class="number">1</span>);</span><br><span class="line">addCurry(<span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">var</span> addCurry = curry(add);</span><br><span class="line">addCurry(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>已经有柯里化的感觉了，但是还没有达到要求，不过我们可以把这个函数用作辅助函数，帮助我们写真正的 curry 函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub_curry</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, args.concat([].slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, length</span>) </span>&#123;</span><br><span class="line">  length = length || fn.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &lt; length) &#123;</span><br><span class="line">      <span class="keyword">var</span> combined = [fn].concat(slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">      <span class="keyword">var</span> sub_fn = sub_curry.apply(<span class="built_in">this</span>, combined);</span><br><span class="line">      <span class="keyword">return</span> curry(sub_fn, length - <span class="built_in">arguments</span>.length);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> fn = curry(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [a, b, c];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fn(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line">fn(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)(<span class="string">&quot;c&quot;</span>); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line">fn(<span class="string">&quot;a&quot;</span>)(<span class="string">&quot;b&quot;</span>)(<span class="string">&quot;c&quot;</span>); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line">fn(<span class="string">&quot;a&quot;</span>)(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>); <span class="comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure>

<p>如果上面的实现不好理解的话，我们换一种写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sun_curry</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, [...args, ...params]);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, length = fn.length</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (params.length &lt; length) &#123;</span><br><span class="line">      <span class="keyword">var</span> sub_fn = sub_curry.apply(<span class="built_in">this</span>, [fn, ...params]);</span><br><span class="line">      <span class="keyword">return</span> curry(sub_fn, length - params.length);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, params);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sun_curry 方法的作用在与接收一个函数和若干参数，然后返回一个函数，该函数能接收后续若干参数。<br>curry 方法的作用就是递归调用辅助函数 sub_curry，实现函数柯里化。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://juejin.cn/post/6844903882208837645">https://juejin.cn/post/6844903882208837645</a></p>
]]></content>
      <categories>
        <category>JavaScript专题系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Web前端资源分享</title>
    <url>/2016/07/04/%E5%89%8D%E7%AB%AF%E8%B5%84%E6%BA%90%E7%BD%91/</url>
    <content><![CDATA[<p>Web前端资源分享：</p>
<ul>
<li>官方：<ul>
<li>W3C：<a href="http://www.w3.org/">http://www.w3.org/</a></li>
<li>ECMA：<a href="http://www.ecmascript.org/">http://www.ecmascript.org/</a></li>
<li>Mozilla：<a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a></li>
</ul>
</li>
<li>微软提供的H5实验室：<br><a href="http://html5labs.interoperabilitybridges.com/">http://html5labs.interoperabilitybridges.com/</a><span id="more"></span></li>
<li>第三方国内：<ul>
<li>前端网：<a href="http://www.w3cfuns.com/portal.php">http://www.w3cfuns.com/portal.php</a></li>
<li>H5基地：<a href="http://html5.360.cn/">http://html5.360.cn/</a></li>
<li>前端里：<a href="http://www.yyyweb.com/">http://www.yyyweb.com</a></li>
</ul>
</li>
<li>国内各大公司前端团队博客：<ul>
<li>携程：<a href="http://ued.ctrip.com/blog/">http://ued.ctrip.com/blog/</a></li>
<li>网易：<a href="http://uedc.163.com/">http://uedc.163.com</a></li>
<li>腾讯：<ul>
<li><a href="http://isux.tencent.com/">http://isux.tencent.com</a></li>
<li><a href="http://www.alloyteam.com/">http://www.alloyteam.com</a></li>
</ul>
</li>
<li>百度：<ul>
<li><a href="http://fex.baidu.com/">http://fex.baidu.com</a></li>
<li><a href="http://efe.baidu.com/">http://efe.baidu.com</a></li>
<li><a href="http://mweb.baidu.com/">http://mweb.baidu.com</a></li>
</ul>
</li>
<li>淘宝：<a href="http://ued.taobao.org/blog/">http://ued.taobao.org/blog/</a></li>
<li>360：<a href="http://www.75team.com/">http://www.75team.com</a></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title>【加载更多】插件</title>
    <url>/2017/08/15/%E5%8A%A0%E8%BD%BD%E6%9B%B4%E5%A4%9A%E6%8F%92%E4%BB%B6%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<p>关于如何实现『加载更多』功能，网上有插件可用，例如比较著名的使用iscroll.js实现的上拉加载更多、下拉刷新功能。</p>
<p>但实际用起来却是很麻烦。由于是第三方插件，要按照对方定义的方法使用，用起来总感觉很不顺心。再加上iscroll.js本身并没有集成加载更多的功能，需要进行自行扩展。想继续使用iscroll.js实现加载更多功能的，上面给的链接可以看看。</p>
<p>h5项目里需要实现简单的分页功能，由于是移动端，考虑用『加载更多』会更好，而不是PC端的翻页。</p>
<hr>
<span id="more"></span>
<p><strong>JS代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * loadmore.js</span></span><br><span class="line"><span class="comment"> * 加载更多</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @time 2017-7-08 15:40:25</span></span><br><span class="line"><span class="comment"> * @author munachar</span></span><br><span class="line"><span class="comment"> * 可以传的参数默认有：size,scroll 可以自定义</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">w,$</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">var</span> loadmore = &#123;</span><br><span class="line">         <span class="comment">/*单页加载更多 通用方法</span></span><br><span class="line"><span class="comment">          *</span></span><br><span class="line"><span class="comment">          * @param callback 回调方法</span></span><br><span class="line"><span class="comment">          * @param config 自定义参数</span></span><br><span class="line"><span class="comment">          * */</span></span><br><span class="line">         <span class="attr">get</span> : <span class="function"><span class="keyword">function</span>(<span class="params">callback, config</span>)</span>&#123;</span><br><span class="line">             <span class="keyword">var</span> config = config ? config : &#123;&#125;; <span class="comment">/*防止未传参数报错*/</span></span><br><span class="line">             <span class="keyword">var</span> counter = <span class="number">1</span>; <span class="comment">/*计数器*/</span></span><br><span class="line">             <span class="keyword">var</span> pageStart = config.size ? config.size : <span class="number">10</span>;</span><br><span class="line">             <span class="keyword">var</span> pageSize = config.size ? config.size : <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">             <span class="comment">/*通过自动监听滚动事件加载更多,可选支持*/</span></span><br><span class="line">             config.isEnd = <span class="literal">false</span>; <span class="comment">/*结束标志*/</span></span><br><span class="line">             config.isAjax = <span class="literal">false</span>; <span class="comment">/*防止滚动过快，服务端没来得及响应造成多次请求*/</span></span><br><span class="line">             $(config.ele).scroll(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                 <span class="comment">/*是否开启滚动加载*/</span></span><br><span class="line">                 <span class="keyword">if</span>(!config.scroll)&#123;</span><br><span class="line">                     <span class="keyword">return</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">/*滚动加载时如果已经没有更多的数据了、正在发生请求时，不能继续进行*/</span></span><br><span class="line">                 <span class="keyword">if</span>(config.isEnd == <span class="literal">true</span> || config.isAjax == <span class="literal">true</span>)&#123;</span><br><span class="line">                     <span class="keyword">return</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">/*当滚动到最底部以上100像素时， 加载新内容*/</span></span><br><span class="line">                 <span class="keyword">if</span> ($(<span class="built_in">this</span>).find(<span class="string">&quot;ul&quot;</span>).height() - $(<span class="built_in">this</span>).scrollTop() - $(<span class="built_in">this</span>).height()&lt;<span class="number">100</span>)&#123;</span><br><span class="line">                     counter ++;</span><br><span class="line">                     pageStart = counter * pageSize;</span><br><span class="line">                     callback &amp;&amp; callback.call( $(config.ele),config, pageStart, pageSize);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">             <span class="comment">/*第一次自动加载*/</span></span><br><span class="line">             callback &amp;&amp; callback.call( $(config.ele),config, pageStart, pageSize);</span><br><span class="line">         &#125;,</span><br><span class="line">     &#125;</span><br><span class="line">     $.loadmore = loadmore;</span><br><span class="line"> &#125;)(<span class="built_in">window</span>, <span class="built_in">window</span>.jQuery || <span class="built_in">window</span>.Zepto);</span><br></pre></td></tr></table></figure>
<p><strong>如何调用：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.loadmore.get(getData, &#123;</span><br><span class="line">                <span class="attr">ele</span>:<span class="built_in">window</span>,  <span class="comment">// 绑定滚动监听元素 默认是window</span></span><br><span class="line">                <span class="attr">scroll</span>: <span class="literal">true</span>,  <span class="comment">//默认是false,是否支持滚动加载</span></span><br><span class="line">                <span class="attr">size</span>:<span class="number">10</span>,  <span class="comment">//默认是10</span></span><br><span class="line">                <span class="attr">flag</span>: <span class="number">1</span>, <span class="comment">//自定义参数，可选，示例里没有用到</span></span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>
<p>第一个参数是回调函数，即我们的业务逻辑。我把我的业务逻辑方法贴出来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">config, offset,size</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    config.isAjax = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&#x27;json/blog.json&#x27;</span>,</span><br><span class="line">        <span class="attr">dataType</span>: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">        <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">reponse</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">            config.isAjax = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> data = reponse.list;</span><br><span class="line">            <span class="keyword">var</span> sum = reponse.list.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/************业务逻辑块：实现拼接html内容并append到页面*****************/</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//console.log(offset , size, sum);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*如果剩下的记录数不够分页，就让分页数取剩下的记录数</span></span><br><span class="line"><span class="comment">            * 例如分页数是5，只剩2条，则只取2条</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * 实际MySQL查询时不写这个</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(sum - offset &lt; size )&#123;</span><br><span class="line">                size = sum - offset;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*使用for循环模拟SQL里的limit(offset,size)*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i=offset; i&lt; (offset+size); i++)&#123;</span><br><span class="line">                result +=<span class="string">&#x27;&lt;div class=&quot;weui_media_box weui_media_text&quot;&gt;&#x27;</span>+</span><br><span class="line">                        <span class="string">&#x27;&lt;a href=&quot;&#x27;</span>+ data[i].url +<span class="string">&#x27;&quot; target=&quot;_blank&quot;&gt;&lt;h4 class=&quot;weui_media_title&quot;&gt;&#x27;</span>+ data[i].title +<span class="string">&#x27;&lt;/h4&gt;&lt;/a&gt;&#x27;</span>+</span><br><span class="line">                        <span class="string">&#x27;&lt;p class=&quot;weui_media_desc&quot;&gt;&#x27;</span>+ data[i].desc +<span class="string">&#x27;&lt;/p&gt;&#x27;</span>+</span><br><span class="line">                    <span class="string">&#x27;&lt;/div&gt;&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $(<span class="string">&#x27;.js-blog-list&#x27;</span>).append(result);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*******************************************/</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*隐藏more*/</span></span><br><span class="line">            <span class="keyword">if</span> ( (offset + size) &gt;= sum)&#123;</span><br><span class="line">                $(<span class="string">&quot;.js-load-more&quot;</span>).hide();</span><br><span class="line">                config.isEnd = <span class="literal">true</span>; <span class="comment">/*停止滚动加载请求*/</span></span><br><span class="line">                <span class="comment">//提示没有了</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                $(<span class="string">&quot;.js-load-more&quot;</span>).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">xhr, type</span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">&#x27;Ajax error!&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上仅贴出核心代码，详细案列：<a href="https://github.com/hedahang/loadingMoreUp">@Munachar</a></p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>一、JavaScript之原型和原型链</title>
    <url>/2019/06/11/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>首先创建一个构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line">var person = new Person();</span><br><span class="line">person.name = &#x27;lilei&#x27;;</span><br><span class="line">console.log(person.name) // lilei</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。</p>
<h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p>每个函数都有一个prototype属性，那这个属性到底是指向哪里呢？是这个函数的原型吗？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line">Person.prototype.name = &#x27;lilei&#x27;;</span><br><span class="line">var person1 = new Person();</span><br><span class="line">var person2 = new Person();</span><br><span class="line">console.log(person1.name) // lilei</span><br><span class="line">console.log(person2.name) // lilei</span><br></pre></td></tr></table></figure>
<p>从这里可以看出，函数Person的prototype熟悉指向了一个对象，这个对象就是正在调用该构造函数而创建的实例的原型，也就是这个例子中的person的原型。<br>那什么是原型呢？可以这样理解，每个JavaScript对象（null除外）在创建的时候都会关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型继承属性。</p>
<h3 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h3><p>每一个JavaScript对象（null除外）都具有的一个属性叫 ‘<strong>proto</strong>‘ , 这个属性指向该对象的原型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line">var person = new Person();</span><br><span class="line">console.log(person.__proto__ === Person.prototype); // true</span><br></pre></td></tr></table></figure>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>前面我们已经知道实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？<br>因为一个构造函数可以生成多个实例，所以原型没有指向实例的属性，，但是原型可以指向构造函数，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line">console.log(Person === Person.prototype.constructor); // true</span><br></pre></td></tr></table></figure>
<p>综上我们已经得出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person();</span><br><span class="line"></span><br><span class="line">console.log(person.__proto__ == Person.prototype) // true</span><br><span class="line">console.log(Person.prototype.constructor == Person) // true</span><br><span class="line">// 顺便学习一个ES5的方法,可以获得对象的原型</span><br><span class="line">console.log(Object.getPrototypeOf(person) === Person.prototype) // true</span><br></pre></td></tr></table></figure>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>在前面，我们已经知道什么是原型，下面我们说说原型链。<br>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。<br>那么原型的最顶层是什么呢？请看下面的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(Object.prototype.__proto__ === null) // true</span><br></pre></td></tr></table></figure>
<blockquote>
<p>null字面意思：空值，这个值的语义是，希望表示一个对象被人为的重置为空对象，而非一个变量最原始的状态 。<br>所以 Object.prototype.<strong>proto</strong> 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。<br>所以查找属性的时候查到 Object.prototype 就可以停止查找了，所以原型的最顶层就是null。<br>最后用一张图来表示之间的关系：<br><img src="/images/prototype.png" alt="(原型图)"><br>图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。</p>
</blockquote>
]]></content>
      <categories>
        <category>深入理解JavaScript系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>双飞翼布局和圣杯布局</title>
    <url>/2017/06/23/%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80%E5%92%8C%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="双飞翼布局和圣杯布局"><a href="#双飞翼布局和圣杯布局" class="headerlink" title="双飞翼布局和圣杯布局"></a>双飞翼布局和圣杯布局</h1><p><br><strong>圣杯布局和双飞翼布局</strong>基本上是一致的，都是两边固定宽度，中间自适应的三栏布局，其中，中间栏放到文档流前面，保证先行渲染。解决方案大体相同，都是三栏全部float:left浮动，区别在于解决中间栏div的内容不被遮挡上，圣杯布局是中间栏在添加相对定位，并配合left和right属性，效果上表现为三栏是单独分开的（如果可以看到空隙的话），而双飞翼布局是在中间栏的div中嵌套一个div，内容写在嵌套的div里，然后对嵌套的div设置margin-left和margin-right，效果上表现为左右两栏在中间栏的上面，中间栏还是100%宽度，只不过中间栏的内容通过margin的值显示在中间。</p>
<hr>
<span id="more"></span>

<h2 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h2><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">200px</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span>,<span class="selector-class">.left</span>,<span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#C899FF</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">60px</span> <span class="number">0</span> <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#EBAD5A</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#348F26</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">60px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>mainmainmainmain<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><h3 id="CSS-1"><a href="#CSS-1" class="headerlink" title="CSS"></a>CSS</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#hd</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#666</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#bd</span>&#123;</span><br><span class="line">    <span class="comment">/*左右栏通过添加负的margin放到正确的位置了，此段代码是为了摆正中间栏的位置*/</span></span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0</span> <span class="number">200px</span> <span class="number">0</span> <span class="number">180px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#middle</span>&#123;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;<span class="comment">/*左栏上去到第一行*/</span></span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>:blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span>&#123;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">180px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>:-<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>:<span class="number">#0c9</span>;</span><br><span class="line">    <span class="comment">/*中间栏的位置摆正之后，左栏的位置也相应右移，通过相对定位的left恢复到正确位置*/</span></span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">    <span class="attribute">left</span>:-<span class="number">180px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span>&#123;</span><br><span class="line">    <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>:-<span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>:<span class="number">#0c9</span>;</span><br><span class="line">    <span class="comment">/*中间栏的位置摆正之后，右栏的位置也相应左移，通过相对定位的right恢复到正确位置*/</span></span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">    <span class="attribute">right</span>:-<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#footer</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#666</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HTML-1"><a href="#HTML-1" class="headerlink" title="HTML"></a>HTML</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;hd&quot;</span>&gt;</span>header<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;bd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;middle&quot;</span>&gt;</span>middle<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;left&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;right&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>布局</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>四、JavaScript之变量对象</title>
    <url>/2019/07/12/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>在前面的文章<a href="https://hedahang.github.io/2019/06/26/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/">《JavaScript之执行上下文栈》</a>中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。</p>
<span id="more"></span>
<p>执行上下文的组成代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const ExecutionContextObj = &#123;</span><br><span class="line">    VO: window, // 变量对象</span><br><span class="line">    Scope: &#123;&#125;, // 作用域链</span><br><span class="line">    this: window</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本文主要记录创建变量对象的过程。</p>
<h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><p>变量对象是与执行上下文相关的数据作用域，存储了上下文中定义的变量和函数声明。<br>变量对象式一个抽象的概念，在不同的上下文中，表示不同的对象:</p>
<h3 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h3><p>全局执行上下文的变量对象</p>
<ul>
<li>全局执行上下文中，变量对象就是全局对象。</li>
<li>在顶层js代码中，this指向全局对象，全局变量会作为该对象的属性来被查询。在浏览器中，window就是全局对象。</li>
</ul>
<p>这样我们就能理解为什么，在全局上下文中声明一个变量时，我们能够通过全局对象的一个​​属性来间接引用它（例如，当变量的名称事先不知道时）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// &quot;test&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>[<span class="string">&#x27;a&#x27;</span>]); <span class="comment">// &quot;test&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(a === <span class="built_in">this</span>.a); <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> aKey = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>[aKey]); <span class="comment">//  &quot;test&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h3><p>函数执行上下文的变量对象</p>
<ul>
<li>函数上下文中，变量对象VO就是活动对象AO。</li>
<li>初始化时，带有arguments属性。</li>
</ul>
<p>Arguments 对象（简称 ArgO）是一个位于函数上下文的激活对象中的对象，包含以下属性：</p>
<p>callee - 链接到正在执行的函数；<br>length -实际传递的参数数量；<br>properties-indexes（数字，缩减为字符串），其中的值是函数的形参（在参数列表中从左到右）。这些索引属性的数量 == arguments.length。arguments 对象的 index 属性值和存在的形参是可以互换的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 描述函数参数的数量(x, y, z)  </span></span><br><span class="line">  <span class="built_in">console</span>.log(foo.length); <span class="comment">// 3</span></span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 实际传输参数的数量,只有(x, y)  </span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length); <span class="comment">// 2</span></span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 函数本身的引用  </span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee === foo); <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// arguments对象的index属性值和存在的形参是可以互换</span></span><br><span class="line">  <span class="built_in">console</span>.log(x === <span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// 10</span></span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// 20</span></span><br><span class="line">  x = <span class="number">30</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// 30</span></span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 然而，对于未指定的z参数,是无法和arguments的值进行互换的</span></span><br><span class="line">  z = <span class="number">40</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">2</span>]); <span class="comment">// undefined</span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">2</span>] = <span class="number">50</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(z); <span class="comment">// 40</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">foo(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><p>执行上下文的代码会分成两个阶段进行处理：分析(进入执行上下文)和执行(代码执行)：</p>
<h3 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h3><p>当进入执行上下文时，这时候还没有执行代码，<br>变量对象会包括：</p>
<ol>
<li>函数的所有形参 (如果是函数上下文)</li>
</ol>
<ul>
<li>由名称和对应值组成的一个变量对象的属性被创建</li>
<li>没有实参，属性值设为 undefined</li>
</ul>
<ol start="2">
<li>函数声明</li>
</ol>
<ul>
<li>由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</li>
<li>如果变量对象已经存在相同名称的属性，则完全替换这个属性</li>
</ul>
<ol start="3">
<li>变量声明</li>
</ol>
<ul>
<li>由名称和对应值（undefined）组成一个变量对象的属性被创建；</li>
<li>如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</li>
</ul>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> e = <span class="function"><span class="keyword">function</span> <span class="title">_e</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>在进入执行上下文后，这时候的 AO 是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="attr">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">length</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">d</span>: reference to <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    <span class="attr">e</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，AO 中不包含“x”函数。这是因为，“x”是不是一个函数声明，而是一个FunctionExpression（函数表达式）是不影响VO。然而，函数“_e”也是一个表达式函数，但是，正如我们将在下面看到的，通过将对其的引用分配给变量“e”，它可以通过“e”使用。您其他帖子中阅读 FunctionDeclaration 和 FunctionExpression 之间的区别。</p>
<h3 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h3><p>在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值</p>
<p>还是上面的例子，当代码执行完后，这时候的 AO 是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    <span class="attr">arguments</span>: &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">length</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="number">10</span></span><br><span class="line">    <span class="attr">d</span>: reference to <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    <span class="attr">e</span>: reference to FunctionExpression <span class="string">&quot;_e&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次注意 FunctionExpression_e仅以变量为代价保留在内存中e。FunctionExpressionx没有进入 AO/VO：也就是说，如果你试图在代码中x声明之前或之后调用一个函数，就会出现“x未定义”错误。未保存的 FunctionExpression 只能与声明一起调用，或递归调用。</p>
<p>来看一个示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// function</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 10</span></span><br><span class="line"> </span><br><span class="line">x = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<p>为什么第一个输出中的“x”是一个函数，甚至在申明之前可用？为什么不是 10 或 20？因为，根据规则——VO在进入上下文时填充了函数声明，在同一个地方，进入时声明了变量“x”，但VO中的变量的优先级低于函数声明，因此，在进入时，VO填充会以如下方式发生：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">VO = &#123;&#125;;</span><br><span class="line"> </span><br><span class="line">VO[<span class="string">&#x27;x&#x27;</span>] = reference to <span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 发现 var x = 10;</span></span><br><span class="line"><span class="comment">// 由于之前已经填充了函数声明，变量‘x’不会覆盖函数的值</span></span><br><span class="line"> </span><br><span class="line">VO[<span class="string">&#x27;x&#x27;</span>] = reference to <span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>但是已经在执行代码时，VO被修改成这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">VO[<span class="string">&#x27;x&#x27;</span>] = <span class="number">10</span>;</span><br><span class="line">VO[<span class="string">&#x27;x&#x27;</span>] = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>再看一个示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// undefined, 而不是 &quot;b is not defined&quot;</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们看到变量在进入上下文时就会进入 VO（例如，永远不会执行 else 块，但是，变量“b”仍然存在于 VO 中）</p>
<h2 id="关于变量"><a href="#关于变量" class="headerlink" title="关于变量"></a>关于变量</h2><p>在JavaScript中，使用var申明和不适用var申明是有区别，请记住：变量仅使用 var 关键字声明。<br>比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// b is not defined</span></span><br><span class="line">b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>这里我们看到”b is not defined”，因为 这不是一个变量，“b”只会在代码执行时创建;<br>关于变量的另一个重点，与简单属性不同，变量接收{DontDelete}属性，这意味着无法使用delete运算符删除：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> a); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// undefined</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> b); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b); <span class="comment">// 任然是20</span></span><br></pre></td></tr></table></figure>

<p>到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说：</p>
<ul>
<li><p>全局上下文的变量对象初始化是全局对象</p>
</li>
<li><p>函数上下文的变量对象初始化只包括 Arguments 对象</p>
</li>
<li><p>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</p>
</li>
<li><p>在代码执行阶段，会再次修改变量对象的属性值</p>
</li>
<li><p>在进入执行上下文时,var声明的变量才会被添加并赋初始值</p>
</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://dmitrysoshnikov.com/ecmascript/ru-chapter-2-variable-object/">http://dmitrysoshnikov.com/ecmascript/ru-chapter-2-variable-object/</a></p>
]]></content>
      <categories>
        <category>深入理解JavaScript系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Vue项目开发中遇到的坑及总结</title>
    <url>/2017/08/10/%E5%9F%BA%E4%BA%8EVue%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%E5%8F%8A%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>项目在5月底启动，属于创业公司的业务扩展吧，IOS和安卓都有成型的版本，所以要做一个对应的移动端H5版的达人、KTV、派对预订，入口是微信公众号，当然少不了jssdk的使用，以及balabala的授权处理等。</p>
<span id="more"></span>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><hr>最初是考虑用React+Redux+Webpack，前后端完全分离，但考虑到人手不足，前后端暂时做不了完全分离，然后还有对React也不熟悉，项目时间等问题，然后就被Boss否了。
最终用了更熟悉的Vue+Vuex+Webpack。主要还是因为更轻，API更加友好，上手速度更快，可以马上开工。
比较遗憾的是因为各种原因前后端分离还不是很彻底，前端用的是smarty模板加js渲染页面。好处是首屏数据可以放到script标签里面直出，在进度条读完的时候页面就能够渲染出来了，提高首屏渲染时间。但是调试的时候十分麻烦，因为没有Node做中间层，每次都要在本地完整地跑个服务器，不然拿不到数据。
Vue，Vuex，Vue-router，Webpack这些不了解的同学就去看看<a href="https://cn.vuejs.org/v2/guide/installation.html" target="_blank" rel="external">文档</a>。MV*框架用好了真的是极大地解放生产力，特别是页面的交互十分复杂的时候。

<h2 id="项目过程中遇到的坑"><a href="#项目过程中遇到的坑" class="headerlink" title="项目过程中遇到的坑"></a>项目过程中遇到的坑</h2><hr>
1. 遇到的第一个的坑就是transition。首页有一个滑动的banner，我是直接用css3的transition配合js定时改变transform实现的。滑动在chrome中模拟没问题，ios中没问题，但是安卓中就没有滑动，百思不得其解。起初还以为是兼容性问题，搞了好久才发现需要在css中先增加一个transform: translateX(0)，像下面一样，不然之后再通过js更改transform是没法在安卓中触发transition的。
<pre>
.slide-wp{
    transform:  translateX(0);
    -webkit-transform:  translateX(0);
    transition: transform  1.5s ease;
    -webkit-transition: transform 1.5s ease;
}
</pre>大家知道，transition的作用是令CSS的属性值在一定的时间区间内平滑地过渡。
所以个人猜测，在安卓中，当没有初始值时，translateX的改动没有被平滑地过渡，就是说transition并不知道translateX是从什么地方开始过渡的，所以也就没有平滑之说，也就没有动画了。
<hr>2. 第二个就是ES6。既然用了Webpack，当然就要配合Bebel用上ES6啦。写的时候还是很爽的。let，const，模块，箭头函数，字符串模版，对象属性简写，解构等等…但帅不过3秒，在chrome上模拟地跑一点问题都没有，一到移动端就直接白屏，页面都没有渲染出来。
排查了好久，才发现是某些扩展运算符...，某些解构和for...of...循环的问题。因为这些ES6的特性（其实不指这些）在Bebel中转换是要用到[Symbol.iterator]接口的。如下面这样。
转码前:
<pre>1.const [a, b, c, d, e] = 'hello';
2.console.log(a, b, c, d, e);//'h','e','l','l','o'</pre>
转码后:
<pre>1.'use strict';
2.var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();
3.
4.var _hello = 'hello';
5.
6.var _hello2 = _slicedToArray(_hello, 5);
7.
8.var a = _hello2[0];
9.var b = _hello2[1];
10.var c = _hello2[2];
11.var d = _hello2[3];
12.var e = _hello2[4];
13.
14.console.log(a, b, c, d, e);//'h','e','l','l','o'</pre>
第一行先声明的_slicedToArray函数用到了[Symbol.iterator]接口，然而浏览器对这个接口的支持还很有限，特别是移动端，只有Firefox Mobile36版本以上才支持，其它清一色挂掉。
所以说ES6虽好，但真要用到实际项目中的话，还不能太激进，有些特性经过Bebel转码后性能上可能还会有所下降，所以还是应该合理地使用ES6。如果是自己折腾倒无所谓，Symbol，Class，Generator，Promise这些就随便炫技吧
<hr>3. 第三个坑就是Vue使用的问题。如其说是坑，还是不如说是我自身还不够熟悉Vue。先看一下官方说明：
<br><code>受 ES5 的限制，Vue.js 不能检测到对象属性的添加或删除。因为 Vue.js 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue.js 转换它，才能让它是响应的。</code>
<br>当时需要在props传来的某些对象数据中增加一个是否可视属性，用来控制一个与其关联的弹出框。增加后点击视图上一点反应都没有，但是用console.log打印出来发现值的确的有变化的。
也就是说，<b>数据的变化不能触发视图更新。</b>原因就是如上面所说，因为这个属性是我后来添加的，不能被Vuejs检测到。这时候需要使用$set(key, value)这个API。
话说里面的语法需要注意下，第一个参数key是一个字符串，是一个keypath，如果假如你的数据是这样:<pre>data(){
            visitors : [{
                    "id": 1,
                    ...
                }, {
                    "id": 2,
                    ...
                }, {
                    "id": 3,
                    ...
                }],
        }
    </pre>
你需要在某次操作后为visitiors里面的每个对象增加一个show属性,则需要这样写：<pre>let str;
         for (let i = 0 , len = this.visitors.length ; i < len; i++) {
             str = "visitors[" + i + "].show";
             this.$set(str,true);
         }
    </pre>
之前真的被这东西搞了很久，明明数据变化了，视图却不更新。个人感觉新手刚使用Vue时很难发现这个问题。也怪自己对Vue，对ES5<code>getter/setter</code>的理解还不够吧。
<hr>4. IOS上CSS3动画的问题。在对img或者设置了background-image的DOM元素设置CSS动画时，动画在刚进入页面的时候有可能不被触发，需要滑动一下屏幕动画才动，安卓下则没有问题。
刚开始还以为是没有设置初始值的问题，但感觉不应该会是这样的。后来在stackoverflow上找到了解决办法(<a href="http://stackoverflow.com/questions/29219534/css-animation-not-always-starting-in-ios-8-safari" target="_blank" rel="external">戳这里</a>)。
给动画加个0.1s秒的延时<pre>animation: slide 1.5s 0.1s linear infinite;
    webkit-animation: slide 1.5s 0.1s linear infinite;
</pre>

<h2 id="关于Vuex"><a href="#关于Vuex" class="headerlink" title="关于Vuex"></a>关于Vuex</h2><hr>
Vuex 之于 vue，就相当于 Redux 之于 React。它是一套数据管理架构实现，用于解决在大型前端应用时数据流动，数据管理等问题。

<p>因为组件一旦多起来，不同组件之间的通信和数据流动会变得十分繁琐及难以追踪，特别是在子组件向同级子组件通信时，你可能需要先$dispatch到父组件，再$broadcast给子组件，整个事件流十分繁杂，也很难调试。<br>Vuex就是用来解决这些问题的。更具体的说明可以看文档，我就不过多叙述了。我就说一下我对Vuex的一些理解。</p>
<p>Vuex里面的数据流是单向的,就像官方说的那样：</p>
<ol>
<li>用户在组件中的输入操作触发 action 调用；</li>
<li>Actions 通过分发 mutations 来修改 store 实例的状态；</li>
<li>Store 实例的状态变化反过来又通过 getters 被组件获知。</li>
</ol>
<p>而且为了保证数据是单向流动，并且是可监控和可预测的，除了在mutation handlers 外，其它地方不允许直接修改 store 里面的 state。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>如何共享一个原型对象</title>
    <url>/2016/07/08/%E5%A6%82%E4%BD%95%E5%85%B1%E4%BA%AB%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>我们想创建一个Student构造函数：</p>
<pre><code>function Student(props) &#123;
    this.name = props.name || &#39;Unnamed&#39;;
&#125;
Student.prototype.hello = function () &#123;
    alert(&#39;Hello, &#39; + this.name + &#39;!&#39;);
&#125;
</code></pre>
<p>现在，我们要基于Student扩展出PrimaryStudent，可以先定义出PrimaryStudent：</p>
<pre><code>function PrimaryStudent(props) &#123;
    // 调用Student构造函数，绑定this变量:
    Student.call(this, props);
    this.grade = props.grade || 1;
&#125;
</code></pre>
<span id="more"></span>    
<p>但是，调用了Student构造函数不等于继承了Student，PrimaryStudent创建的对象的原型是：</p>
<pre><code>new PrimaryStudent() ----&gt; PrimaryStudent.prototype ----&gt; Object.prototype ----&gt; null
</code></pre>
<p>必须想办法把原型链修改为：</p>
<pre><code>new PrimaryStudent() ----&gt; PrimaryStudent.prototype ----&gt; Student.prototype ----&gt; Object.prototype ----&gt; null
</code></pre>
<p>这样，原型链对了，继承关系就对了。新的基于PrimaryStudent创建的对象不但能调用PrimaryStudent.prototype定义的方法，也可以调用Student.prototype定义的方法。</p>
<p>如果你想用最简单粗暴的方法这么干：</p>
<pre><code>PrimaryStudent.prototype = Student.prototype;
</code></pre>
<p>是不行的！如果这样的话，PrimaryStudent和Student共享一个原型对象，那还要定义PrimaryStudent干啥？</p>
<p>我们必须借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向Student.prototype。为了实现这一点，参考道爷（就是发明JSON的那个道格拉斯）的代码，中间对象可以用一个空函数F来实现：</p>
<pre><code>// PrimaryStudent构造函数:
function PrimaryStudent(props) &#123;
    Student.call(this, props);
    this.grade = props.grade || 1;
&#125;

// 空函数F:
function F() &#123;
&#125;

// 把F的原型指向Student.prototype:
F.prototype = Student.prototype;

// 把PrimaryStudent的原型指向一个新的F对象，F对象的原型正好指向Student.prototype:
PrimaryStudent.prototype = new F();

// 把PrimaryStudent原型的构造函数修复为PrimaryStudent:
PrimaryStudent.prototype.constructor = PrimaryStudent;

// 继续在PrimaryStudent原型（就是new F()对象）上定义方法： (可以省略)
PrimaryStudent.prototype.getGrade = function () &#123;
    return this.grade;
&#125;;

// 创建xiaoming:
var xiaoming = new PrimaryStudent(&#123;
    name: &#39;小明&#39;,
    grade: 2
&#125;);
xiaoming.name; // &#39;小明&#39;
xiaoming.grade; // 2

// 验证原型:
xiaoming.__proto__ === PrimaryStudent.prototype; // true
xiaoming.__proto__.__proto__ === Student.prototype; // true

// 验证继承关系:
xiaoming instanceof PrimaryStudent; // true
xiaoming instanceof Student; // true
</code></pre>
<p>注意，函数F仅用于桥接，我们仅创建了一个new F()实例，而且，没有改变原有的Student定义的原型链。</p>
<p>如果把继承这个动作用一个inherits()函数封装起来，还可以隐藏F的定义，并简化代码：</p>
<pre><code>function inherits(Child, Parent) &#123;
    var F = function () &#123;&#125;;
    F.prototype = Parent.prototype;
    Child.prototype = new F();
    Child.prototype.constructor = Child;
&#125;
</code></pre>
<p>这个inherits()函数可以复用：</p>
<pre><code>function Student(props) &#123;
    this.name = props.name || &#39;Unnamed&#39;;
&#125;

Student.prototype.hello = function () &#123;
    alert(&#39;Hello, &#39; + this.name + &#39;!&#39;);
&#125;

function PrimaryStudent(props) &#123;
    Student.call(this, props);
    this.grade = props.grade || 1;
&#125;

// 实现原型继承链:
inherits(PrimaryStudent, Student);

// 绑定其他方法到PrimaryStudent原型:
PrimaryStudent.prototype.getGrade = function () &#123;
    return this.grade;
&#125;;
</code></pre>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>JavaScript的原型继承实现方式就是：</li>
<li>定义新的构造函数，并在内部用call()调用希望“继承”的构造函数，并绑定this；</li>
<li>借助中间函数F实现原型链继承，最好通过封装的inherits函数完成；</li>
<li>继续在新的构造函数的原型上定义新方法。</li>
</ul>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>如何处理信息过载</title>
    <url>/2016/05/04/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BF%A1%E6%81%AF%E8%BF%87%E8%BD%BD/</url>
    <content><![CDATA[<h3 id="一、俯瞰全景"><a href="#一、俯瞰全景" class="headerlink" title="一、俯瞰全景"></a>一、俯瞰全景</h3><blockquote>
<p>用断舍离的自在力俯瞰信息输入全景<br>微信：群、订阅号、朋友圈<br>微博、日报、新闻等APP<br>书籍、杂志<br>音频<br>其他</p>
</blockquote>
<h3 id="二、正本清源"><a href="#二、正本清源" class="headerlink" title="二、正本清源"></a>二、正本清源</h3><blockquote>
<p>梳理反思，及时清理对你造成困扰的信息源头。<br>以下是我的使用习惯，供参考<br>微信清退规则<br>群：没有群规，且超过一个月不曾发言<br>订阅号：未读数超 30<br>朋友圈：固定时间查阅<br>APP：关掉推送通知，关不掉就卸掉</p>
</blockquote>
<span id="more"></span>
<h3 id="三、书籍"><a href="#三、书籍" class="headerlink" title="三、书籍"></a>三、书籍</h3><blockquote>
<p>尽量阅读纸质书，不读杂志<br>读「元学科」相关的著作<br>阅读经典与诚意之作<br>阅读器存放的书不超过四本</p>
</blockquote>
<h3 id="四、音频"><a href="#四、音频" class="headerlink" title="四、音频"></a>四、音频</h3><blockquote>
<p>只在通勤时收听</p>
</blockquote>
<h3 id="五、社交"><a href="#五、社交" class="headerlink" title="五、社交"></a>五、社交</h3><blockquote>
<p>远离社交媒体<br>尽可能独立思考地输出代表作<br>有可追溯的记录平台<br>让自己变得优秀，方可与优秀的人相聚</p>
</blockquote>
<blockquote>
<p>会当凌绝顶，一览众山小。当你攀爬上思想巅峰，你便知，所谓信息过载，便如山边之行云，待一一退去，方可领略真知的雄伟。</p>
</blockquote>
<p>作者：陈素封<br>链接：<a href="http://www.zhihu.com/question/19685050/answer/71453024">http://www.zhihu.com/question/19685050/answer/71453024</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>关于IOS、安卓与原生JS交互的总结</title>
    <url>/2016/11/03/%E5%AE%89%E5%8D%93IOS%E4%B8%8EJS%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<p>最近在App中需要做一些页面，其中涉及到了与原生APP交互的问题，现在做下总结方便以后查询</p>
<span id="more"></span>
<p><strong>Android与JS交互</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> browser=&#123;</span><br><span class="line">    <span class="attr">versions</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> u = navigator.userAgent, app = navigator.appVersion;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="comment">//移动终端浏览器版本信息</span></span><br><span class="line">            <span class="attr">trident</span>: u.indexOf(<span class="string">&#x27;Trident&#x27;</span>) &gt; -<span class="number">1</span>, <span class="comment">//IE内核</span></span><br><span class="line">            <span class="attr">presto</span>: u.indexOf(<span class="string">&#x27;Presto&#x27;</span>) &gt; -<span class="number">1</span>, <span class="comment">//opera内核</span></span><br><span class="line">            <span class="attr">webKit</span>: u.indexOf(<span class="string">&#x27;AppleWebKit&#x27;</span>) &gt; -<span class="number">1</span>, <span class="comment">//苹果、谷歌内核</span></span><br><span class="line">            <span class="attr">gecko</span>: u.indexOf(<span class="string">&#x27;Gecko&#x27;</span>) &gt; -<span class="number">1</span> &amp;&amp; u.indexOf(<span class="string">&#x27;KHTML&#x27;</span>) == -<span class="number">1</span>, <span class="comment">//火狐内核</span></span><br><span class="line">            <span class="attr">mobile</span>: !!u.match(<span class="regexp">/AppleWebKit.*Mobile.*/</span>)||!!u.match(<span class="regexp">/AppleWebKit/</span>), <span class="comment">//是否为移动终端</span></span><br><span class="line">            <span class="attr">ios</span>: !!u.match(<span class="regexp">/\(i[^;]+;( U;)? CPU.+Mac OS X/</span>), <span class="comment">//ios终端</span></span><br><span class="line">            <span class="attr">android</span>: u.indexOf(<span class="string">&#x27;Android&#x27;</span>) &gt; -<span class="number">1</span> || u.indexOf(<span class="string">&#x27;Linux&#x27;</span>) &gt; -<span class="number">1</span>, <span class="comment">//android终端或者uc浏览器</span></span><br><span class="line">            <span class="attr">iPhone</span>: u.indexOf(<span class="string">&#x27;iPhone&#x27;</span>) &gt; -<span class="number">1</span> || u.indexOf(<span class="string">&#x27;Mac&#x27;</span>) &gt; -<span class="number">1</span>, <span class="comment">//是否为iPhone或者QQHD浏览器</span></span><br><span class="line">            <span class="attr">iPad</span>: u.indexOf(<span class="string">&#x27;iPad&#x27;</span>) &gt; -<span class="number">1</span>, <span class="comment">//是否iPad</span></span><br><span class="line">            <span class="attr">webApp</span>: u.indexOf(<span class="string">&#x27;Safari&#x27;</span>) == -<span class="number">1</span> <span class="comment">//是否web应该程序，没有头部与底部</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;(),</span><br><span class="line">    <span class="attr">language</span>:(navigator.browserLanguage || navigator.language).toLowerCase()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showToast</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">android.showToast(<span class="string">&quot;&#x27;title: Money+Funny，这可能是全成都最适合你的兼职！&#x27;,&#x27;content:拼K高校首席体验官公开招募！底薪1000元多玩多赚！速来！速来！速来！&#x27;,&#x27;urlId:http://www.tanshikeji.com/Home/Active/special_form.html&#x27;&quot;</span>);</span><br><span class="line"><span class="comment">//    android.showToast(&quot;&#123;\&quot;title\&quot;:\&quot; 我报名了拼K高校首席体验官！ 你也快来！\&quot;,\&quot;content\&quot;:\&quot;拼K高校首席体验官公开招募！底薪1000元多玩多赚！速来！速来！速来！\&quot;,\&quot;urlId:http://www.tanshikeji.com/Home/Active/special\&quot;&#125;&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showClick</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>( navigator.userAgent.indexOf(<span class="string">&#x27;Android&#x27;</span>) &gt; -<span class="number">1</span> ||  navigator.userAgent.indexOf(<span class="string">&#x27;Linux&#x27;</span>) &gt; -<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//        e.preventDefault();</span></span><br><span class="line">    &#125;</span><br><span class="line">    android.showClick(<span class="string">&quot;http://www.tanshikeji.com/Home/Active/special_form.html&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;android_share&#x27;</span>).onclick = showToast;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;from_click&#x27;</span>).onclick = showClick;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><strong>IOS与JS交互:</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">/*这段代码是固定的，必须要放到js中*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupWebViewJavascriptBridge</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.WebViewJavascriptBridge) &#123; <span class="keyword">return</span> callback(WebViewJavascriptBridge); &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.WVJBCallbacks) &#123; <span class="keyword">return</span> <span class="built_in">window</span>.WVJBCallbacks.push(callback); &#125;</span><br><span class="line">    <span class="built_in">window</span>.WVJBCallbacks = [callback];</span><br><span class="line">    <span class="keyword">var</span> WVJBIframe = <span class="built_in">document</span>.createElement(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">    WVJBIframe.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    WVJBIframe.src = <span class="string">&#x27;wvjbscheme://__BRIDGE_LOADED__&#x27;</span>;</span><br><span class="line">    <span class="built_in">document</span>.documentElement.appendChild(WVJBIframe);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">document</span>.documentElement.removeChild(WVJBIframe) &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*与OC交互的所有JS方法都要放在此处注册，才能调用通过JS调用OC或者让OC调用这里的JS*/</span></span><br><span class="line">setupWebViewJavascriptBridge(<span class="function"><span class="keyword">function</span>(<span class="params">bridge</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*我们在这注册一个js调用OC的方法，不带参数，且不用ObjC端反馈结果给JS：打开本demo对应的博文*/</span></span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&#x27;ios_share&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        bridge.callHandler(<span class="string">&#x27;getShareObjC&#x27;</span>, &#123;</span><br><span class="line">            <span class="string">&#x27;title&#x27;</span>: <span class="string">&#x27;Money+Funny，这可能是全成都最适合你的兼职！&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;content&#x27;</span>:<span class="string">&#x27;拼K高校首席体验官公开招募！底薪1000元多玩多赚！速来！速来！速来！&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;urlId&#x27;</span>:<span class="string">&#x27;http://www.tanshikeji.com/Home/Active/special_form.html&#x27;</span></span><br><span class="line">        &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line"><span class="comment">//            alert(&quot;success&quot;+response);</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>IOS</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>常用正则表达式</title>
    <url>/2016/07/06/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>正则表达式，一个十分古老而又强大的文本处理工具，仅仅用一段非常简短的表达式语句，便能够快速实现一个非常复杂的业务逻辑。熟练地掌握正则表达式的话，能够使你的开发效率得到极大的提升。</p>
<p>正则表达式经常被用于字段或任意字符串的校验，如下面这段校验基本日期格式的JavaScript代码：</p>
<pre><code>var reg = /^(\\d&#123;1,4&#125;)(-|\\/)(\\d&#123;1,2&#125;)\\2(\\d&#123;1,2&#125;)$/; 
var r = fieldValue.match(reg);             
if(r==null)alert(&#39;Date format error!&#39;);
</code></pre>
<p>下面是技匠整理的，在前端开发中经常使用到的20个正则表达式。</p>
<hr>
<span id="more"></span>
<h3 id="校验密码强度"><a href="#校验密码强度" class="headerlink" title="校验密码强度"></a>校验密码强度</h3><p>密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。</p>
<pre><code>^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$
</code></pre>
<h3 id="校验中文"><a href="#校验中文" class="headerlink" title="校验中文"></a>校验中文</h3><p>字符串仅能是中文。</p>
<pre><code>^[\\u4e00-\\u9fa5]&#123;0,&#125;$
</code></pre>
<h3 id="由数字、26个英文字母或下划线组成的字符串"><a href="#由数字、26个英文字母或下划线组成的字符串" class="headerlink" title="由数字、26个英文字母或下划线组成的字符串"></a>由数字、26个英文字母或下划线组成的字符串</h3><pre><code>^\\w+$
</code></pre>
<h3 id="校验E-Mail-地址"><a href="#校验E-Mail-地址" class="headerlink" title="校验E-Mail 地址"></a>校验E-Mail 地址</h3><p>同密码一样，下面是E-mail地址合规性的正则检查语句。</p>
<pre><code>[\\w!#$%&amp;&#39;*+/=?^_`&#123;|&#125;~-]+(?:\\.[\\w!#$%&amp;&#39;*+/=?^_`&#123;|&#125;~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?
</code></pre>
<h3 id="校验身份证号码"><a href="#校验身份证号码" class="headerlink" title="校验身份证号码"></a>校验身份证号码</h3><p>下面是身份证号码的正则校验。15 或 18位。</p>
<p>15位：</p>
<pre><code>^[1-9]\\d&#123;7&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;$
</code></pre>
<p>18位：</p>
<pre><code>^[1-9]\\d&#123;5&#125;[1-9]\\d&#123;3&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;([0-9]|X)$
</code></pre>
<h3 id="校验日期"><a href="#校验日期" class="headerlink" title="校验日期"></a>校验日期</h3><p>“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。</p>
<pre><code>^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$
</code></pre>
<h3 id="校验金额"><a href="#校验金额" class="headerlink" title="校验金额"></a>校验金额</h3><p>金额校验，精确到2位小数。</p>
<pre><code>^[0-9]+(.[0-9]&#123;2&#125;)?$
</code></pre>
<h3 id="校验手机号"><a href="#校验手机号" class="headerlink" title="校验手机号"></a>校验手机号</h3><p>下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码）</p>
<pre><code>^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$
</code></pre>
<h3 id="判断IE的版本"><a href="#判断IE的版本" class="headerlink" title="判断IE的版本"></a>判断IE的版本</h3><p>IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。</p>
<pre><code>^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\/[5-9]\\.0).*$
</code></pre>
<h3 id="校验IP-v4地址"><a href="#校验IP-v4地址" class="headerlink" title="校验IP-v4地址"></a>校验IP-v4地址</h3><p>IP4 正则语句。</p>
<pre><code>\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b
</code></pre>
<h3 id="校验IP-v6地址"><a href="#校验IP-v6地址" class="headerlink" title="校验IP-v6地址"></a>校验IP-v6地址</h3><p>IP6 正则语句。</p>
<pre><code>(([0-9a-fA-F]&#123;1,4&#125;:)&#123;7,7&#125;[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,7&#125;:|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,6&#125;:[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,5&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,2&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,3&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,3&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,2&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,5&#125;|[0-9a-fA-F]&#123;1,4&#125;:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,6&#125;)|:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,7&#125;|:)|fe80:(:[0-9a-fA-F]&#123;0,4&#125;)&#123;0,4&#125;%[0-9a-zA-Z]&#123;1,&#125;|::(ffff(:0&#123;1,4&#125;)&#123;0,1&#125;:)&#123;0,1&#125;((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;:((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9]))
</code></pre>
<h3 id="检查URL的前缀"><a href="#检查URL的前缀" class="headerlink" title="检查URL的前缀"></a>检查URL的前缀</h3><p>应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。</p>
<pre><code>if (!s.match(/^[a-zA-Z]+:\\/\\//))
&#123;
    s = &#39;http://&#39; + s;
&#125;
</code></pre>
<h3 id="提取URL链接"><a href="#提取URL链接" class="headerlink" title="提取URL链接"></a>提取URL链接</h3><p>下面的这个表达式可以筛选出一段文本中的URL。</p>
<pre><code>^(f|ht)&#123;1&#125;(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&amp;=]*)?
</code></pre>
<h3 id="文件路径及扩展名校验"><a href="#文件路径及扩展名校验" class="headerlink" title="文件路径及扩展名校验"></a>文件路径及扩展名校验</h3><p>验证windows下文件路径和扩展名（下面的例子中为.txt文件）</p>
<pre><code>^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?&quot;&lt;&gt;|]+\\.txt(l)?$
</code></pre>
<h3 id="提取Color-Hex-Codes"><a href="#提取Color-Hex-Codes" class="headerlink" title="提取Color Hex Codes"></a>提取Color Hex Codes</h3><p>有时需要抽取网页中的颜色代码，可以使用下面的表达式。</p>
<pre><code>^#([A-Fa-f0-9]&#123;6&#125;|[A-Fa-f0-9]&#123;3&#125;)$
</code></pre>
<h3 id="提取网页图片"><a href="#提取网页图片" class="headerlink" title="提取网页图片"></a>提取网页图片</h3><p>假若你想提取网页中所有图片信息，可以利用下面的表达式。</p>
<pre><code>\\&lt; *[img][^\\\\&gt;]*[src] *= *[\\&quot;\\&#39;]&#123;0,1&#125;([^\\&quot;\\&#39;\\ &gt;]*)
</code></pre>
<h3 id="提取页面超链接"><a href="#提取页面超链接" class="headerlink" title="提取页面超链接"></a>提取页面超链接</h3><p>提取html中的超链接。</p>
<pre><code>(&lt;a\\s*(?!.*\\brel=)[^&gt;]*)(href=&quot;https?:\\/\\/)((?!(?:(?:www\\.)?&#39;.implode(&#39;|(?:www\\.)?&#39;, $follow_list).&#39;))[^&quot;]+)&quot;((?!.*\\brel=)[^&gt;]*)(?:[^&gt;]*)&gt;
</code></pre>
<h3 id="查找CSS属性"><a href="#查找CSS属性" class="headerlink" title="查找CSS属性"></a>查找CSS属性</h3><p>通过下面的表达式，可以搜索到相匹配的CSS属性。</p>
<pre><code>^\\s*[a-zA-Z\\-]+\\s*[:]&#123;1&#125;\\s[a-zA-Z0-9\\s.#]+[;]&#123;1&#125;
</code></pre>
<h3 id="抽取注释"><a href="#抽取注释" class="headerlink" title="抽取注释"></a>抽取注释</h3><p>如果你需要移除HMTL中的注释，可以使用如下的表达式。</p>
<pre><code>&lt;!--(.*?)--&gt;
</code></pre>
<h3 id="匹配HTML标签"><a href="#匹配HTML标签" class="headerlink" title="匹配HTML标签"></a>匹配HTML标签</h3><p>通过下面的表达式可以匹配出HTML中的标签属性。</p>
<pre><code>&lt;\\/?\\w+((\\s+\\w+(\\s*=\\s*(?:&quot;.*?&quot;|&#39;.*?&#39;|[\\^&#39;&quot;&gt;\\s]+))?)+\\s*|\\s*)\\/?&gt;
</code></pre>
<p>文／技匠（简书签约作者）<br>原文链接：<a href="http://www.jianshu.com/p/e7bb97218946">http://www.jianshu.com/p/e7bb97218946</a></p>
]]></content>
      <tags>
        <tag>Expression</tag>
      </tags>
  </entry>
  <entry>
    <title>七、JavaScript之执行上下文</title>
    <url>/2019/08/26/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>每次当控制器转到 ECMAScript 可执行代码的时候，即会进入到一个执行上下文。执行上下文(简称-EC)是 ECMA-262 标准里的一个抽象概念，用于同可执行代码(executable code)概念进行区分。</p>
<p>标准规范没有从技术实现的角度定义 EC 的准确类型和结构，这应该是具体实现 ECMAScript 引擎时要考虑的问题。</p>
<p>活动的执行上下文组在逻辑上组成一个堆栈。堆栈底部永远都是全局上下文(global context)，而顶部就是当前(活动的)执行上下文。堆栈在 EC 类型进入和退出上下文的时候被修改（推入或弹出）。</p>
<span id="more"></span>

<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>这里我们结合前面几篇文章来看看执行上下文的具体处理过程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&quot;global scope&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope = <span class="string">&quot;local scope&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scope;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure>

<p>执行过程如下： 1.执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈；全局上下文初始化；创建 checkscope 函数，并保存作用域链到函数的内部属性[[scope]]。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ECStack = [globalContext];</span><br><span class="line"></span><br><span class="line">globalContext = &#123;</span><br><span class="line">  <span class="attr">VO</span>: [<span class="built_in">global</span>],</span><br><span class="line">  <span class="attr">Scope</span>: [globalContext.VO],</span><br><span class="line">  <span class="attr">this</span>: globalContext.VO,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">checkscope[[scope]] = [globalContext.VO];</span><br></pre></td></tr></table></figure>

<p>2.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ECStack = [checkscopeContext, globalContext];</span><br></pre></td></tr></table></figure>

<p>4.checkscope 函数执行上下文初始化：</p>
<ul>
<li>复制函数 [[scope]] 属性创建作用域链，</li>
<li>用 arguments 创建活动对象，</li>
<li>初始化活动对象，即加入形参、函数声明、变量声明，</li>
<li>将活动对象压入 checkscope 作用域链顶端。</li>
<li>同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">  <span class="attr">AO</span>: &#123;</span><br><span class="line">    <span class="attr">arguments</span>: &#123;</span><br><span class="line">      <span class="attr">length</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">scope</span>: <span class="literal">undefined</span>,</span><br><span class="line">    <span class="attr">f</span>: reference to <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">Scope</span>: [AO, globalContext.VO],</span><br><span class="line">  <span class="attr">this</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ECStack = [fContext, checkscopeContext, globalContext];</span><br></pre></td></tr></table></figure>

<p>6.f 函数执行上下文初始化, 以下跟第 4 步相同：</p>
<ul>
<li>复制函数 [[scope]] 属性创建作用域链</li>
<li>用 arguments 创建活动对象</li>
<li>初始化活动对象，即加入形参、函数声明、变量声明</li>
<li>将活动对象压入 f 作用域链顶端</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fContext = &#123;</span><br><span class="line">  <span class="attr">AO</span>: &#123;</span><br><span class="line">    <span class="attr">arguments</span>: &#123;</span><br><span class="line">      <span class="attr">length</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">Scope</span>: [AO, checkscopeContext.AO, globalContext.VO],</span><br><span class="line">  <span class="attr">this</span>: <span class="literal">undefined</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>7.f 函数执行，沿着作用域链查找 scope 值，返回 scope 值</p>
<p>8.f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ECStack = [checkscopeContext, globalContext];</span><br></pre></td></tr></table></figure>

<p>9.checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ECStack = [globalContext];</span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://github.com/mqyqingfeng/Blog/issues/8">https://github.com/mqyqingfeng/Blog/issues/8</a></p>
]]></content>
      <categories>
        <category>深入理解JavaScript系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>三、JavaScript之执行上下文栈</title>
    <url>/2019/06/26/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/</url>
    <content><![CDATA[<p>由于JS是单线程的，每次只能做一件事情，其他的事情会放在指定的上下文栈中排队等待执行，所以执行上下文栈的作用是用来跟踪代码的，。</p>
<p>JS解释器在初始化代码的时候，首先会创建一个新的全局执行上下文到执行上下文栈顶中，然后随着每次函数的调用都会创建一个新的执行上下文放入到栈顶中，随着函数执行完毕后被执行上下文栈顶弹出，直到回到全局的执行上下文中。（栈：一种数据结构，遵循后进先出的原则）。下面我们说说执行上下文栈是如何工作的。</p>
<span id="more"></span>
<p>为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ECStack = [];</span><br></pre></td></tr></table></figure>
<p>当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">    globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>现在我们执行下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var color = &#x27;blue&#x27;;</span><br><span class="line">function changeColor() &#123;</span><br><span class="line">    var anotherColor = &#x27;red&#x27;;</span><br><span class="line">    function swapColors() &#123;</span><br><span class="line">        var tempColor = anotherColor;</span><br><span class="line">        anotherColor = color;</span><br><span class="line">        color = tempColor;</span><br><span class="line">    &#125;</span><br><span class="line">    swapColors();</span><br><span class="line">&#125;</span><br><span class="line">changeColor();</span><br></pre></td></tr></table></figure>
<p>上述代码运行按照如下步骤：</p>
<ul>
<li>当上述代码在浏览器中加载时，JavaScript 引擎会创建一个全局执行上下文并且将它推入当前的执行栈</li>
<li>调用 changeColor函数时，此时changeColor函数内部代码还未执行，js执行引擎立即创建一个changeColor的执行上下文（简称EC），然后把这执行上下文压入到执行栈（简称ECStack）中。</li>
<li>执行changeColor函数过程中，调用swapColors函数，同样地，swapColors函数执行之前也创建了一个swapColors的执行上下文，并压入到执行栈中。</li>
<li>swapColors函数执行完成，swapColors函数的执行上下文出栈，并且被销毁。</li>
<li>changeColor函数执行完成，changeColor函数的执行上下文出栈，并且被销毁。<br><img src="/images/esstack.png" alt="(流程图)"></li>
</ul>
]]></content>
      <categories>
        <category>深入理解JavaScript系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>二、JavaScript专题之数组去重</title>
    <url>/2020/01/14/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
    <content><![CDATA[<p>在面试中，我们常常会遇到数组去重的问题，这里整理一下。</p>
<span id="more"></span>

<h2 id="双重循环去重"><a href="#双重循环去重" class="headerlink" title="双重循环去重"></a>双重循环去重</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>, len = res.length; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[i] === res[j]) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j === len) res.push(array[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;1&quot;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(uniq(arr)); <span class="comment">//[1, 2, &quot;3&quot;, &quot;2&quot;, &quot;1&quot;]</span></span><br></pre></td></tr></table></figure>

<h2 id="双循环去重优化"><a href="#双循环去重优化" class="headerlink" title="双循环去重优化"></a>双循环去重优化</h2><p>思路：获取没重复的最右一值放入新数组(判断值得右侧有无重复)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 推荐的方法</span></span><br><span class="line"><span class="comment"> * 效率较高</span></span><br><span class="line"><span class="comment"> * 实现思路：获取没重复的最右一值放入新数组。</span></span><br><span class="line"><span class="comment"> * （检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断）*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = [],</span><br><span class="line">    len = array.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[i] === array[j]) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        j = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(array[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IndexOf"><a href="#IndexOf" class="headerlink" title="IndexOf"></a>IndexOf</h2><p>利用 IndexOf 简化内层循环：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 新建一新数组，遍历传入数组，值不在新数组就push进该新数组中</span></span><br><span class="line"><span class="comment"> * IE8以下不支持数组的indexOf方法</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.indexOf(array[i]) === -<span class="number">1</span>) &#123;</span><br><span class="line">      res.push(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="排序后相邻去除法"><a href="#排序后相邻去除法" class="headerlink" title="排序后相邻去除法"></a>排序后相邻去除法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 给传入数组排序，排序后相同值相邻，</span></span><br><span class="line"><span class="comment"> * 然后遍历时,新数组只加入不与前一值重复的值。</span></span><br><span class="line"><span class="comment"> * 会打乱原来数组的顺序</span></span><br><span class="line"><span class="comment"> * [2, &quot;2&quot;, 2, &quot;2&quot;]排序会有问题</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  array.sort();</span><br><span class="line">  <span class="keyword">let</span> res = [array[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] !== array[i - <span class="number">1</span>]) &#123;</span><br><span class="line">      res.push(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象键值去重"><a href="#对象键值去重" class="headerlink" title="对象键值去重"></a>对象键值去重</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 速度最快， 占空间最多（空间换时间）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该方法执行的速度比其他任何方法都快， 就是占用的内存大一些。</span></span><br><span class="line"><span class="comment"> * 现思路：新建一js对象以及新数组，遍历传入数组时，判断值是否为js对象的键，</span></span><br><span class="line"><span class="comment"> * 不是的话给对象新增该键并放入新数组。</span></span><br><span class="line"><span class="comment"> * 注意点：判断是否为js对象键时，会自动对传入的键执行“toString()”，</span></span><br><span class="line"><span class="comment"> * 不同的键可能会被误认为一样，例如n[val]-- n[1]、n[&quot;1&quot;]；</span></span><br><span class="line"><span class="comment"> * 解决上述问题还是得调用“indexOf”。*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = [],</span><br><span class="line">    temp = &#123;&#125;;</span><br><span class="line">  array.forEach(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> type = <span class="keyword">typeof</span> val;</span><br><span class="line">    <span class="keyword">if</span> (!temp[val]) &#123;</span><br><span class="line">      temp[val] = [type];</span><br><span class="line">      res.push(val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp[val].indexOf(type) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      temp[val].push(type);</span><br><span class="line">      res.push(val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组下标法"><a href="#数组下标法" class="headerlink" title="数组下标法"></a>数组下标法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 实现思路：如果当前数组的第i项在当前数组中第一次出现的位置不是i，</span></span><br><span class="line"><span class="comment"> * 那么表示第i项是重复的，忽略掉。否则存入结果数组。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = [];</span><br><span class="line">  array.forEach(<span class="function">(<span class="params">v, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.indexOf(v) === i) &#123;</span><br><span class="line">      res.push(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>ES5 提供了 filter 方法，我们可以用来简化外层循环</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = array.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.indexOf(item) === index;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="利用-ES6-的-set"><a href="#利用-ES6-的-set" class="headerlink" title="利用 ES6 的 set"></a>利用 ES6 的 set</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用Array.from将Set结构转换成数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...new <span class="built_in">Set</span>(array)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>去重的方式有很多，我们需要知道在合适的场景要选择合适的方法，这样才能达到最优。</p>
]]></content>
      <categories>
        <category>JavaScript专题系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>六、JavaScript专题之数组取最大值和最小值</title>
    <url>/2020/03/06/%E6%95%B0%E7%BB%84%E5%8F%96%E6%9C%80%E5%80%BC/</url>
    <content><![CDATA[<p>数组取最大值、最小值的常用实现方式：</p>
<span id="more"></span>

<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">22</span>, <span class="number">15</span>, <span class="number">76</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr));</span><br></pre></td></tr></table></figure>

<h2 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">22</span>, <span class="number">15</span>, <span class="number">76</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  result = <span class="built_in">Math</span>.max(result, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>

<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">22</span>, <span class="number">15</span>, <span class="number">76</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...arr));</span><br></pre></td></tr></table></figure>

<h2 id="排序取值"><a href="#排序取值" class="headerlink" title="排序取值"></a>排序取值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">22</span>, <span class="number">15</span>, <span class="number">76</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">    .sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line">    .slice()</span><br><span class="line">    .pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(max(arr));</span><br></pre></td></tr></table></figure>

<h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">22</span>, <span class="number">15</span>, <span class="number">76</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>(<span class="params">prev, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(prev, next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr.reduce(max));</span><br></pre></td></tr></table></figure>

<h2 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">22</span>, <span class="number">15</span>, <span class="number">76</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">eval</span>(<span class="string">&quot;Math.max(&quot;</span> + arr + <span class="string">&quot;)&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(max);</span><br></pre></td></tr></table></figure>

<p>暂时总结到这里，后续再补充。</p>
]]></content>
      <categories>
        <category>JavaScript专题系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>七、JavaScript专题之数组扁平化</title>
    <url>/2020/03/12/%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/</url>
    <content><![CDATA[<p>数组的扁平化，就是将一个嵌套多层的数组 array (嵌套可以是任何层数)转换为只有一层的数组。换句话说就是把多维数组转化成一维数组。</p>
<span id="more"></span>

<p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>,[<span class="string">&#x27;b&#x27;</span>,[<span class="string">&#x27;c&#x27;</span>]]]<span class="comment">//3 维数组</span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>,[<span class="string">&#x27;b&#x27;</span>,[<span class="string">&#x27;c&#x27;</span>,[.....]]]]<span class="comment">//n 维数组</span></span><br><span class="line"><span class="comment">// 转化为：</span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,...]</span><br></pre></td></tr></table></figure>

<p>通常我们都会用递归的方式来实现。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(arr[i])) &#123;</span><br><span class="line">      result = result.concat(flatten(arr[i]));</span><br><span class="line">      <span class="comment">// result.push(...flatten(arr[i]))</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>

<p>利用 for 循环遍历数组的每一项并加以判断，如果不是数组，就执行 push 操作，是数组的化，就再次执行该函数（递归），直至遍历完整个数组。<br>ps: …和 concat()可以进行替换，所以完全可以算是 2 种方法。</p>
<h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (arr.some(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">    <span class="comment">// arr = [].concat(...arr);</span></span><br><span class="line">    arr = <span class="built_in">Array</span>.prototype.concat.apply([], arr);</span><br><span class="line">    <span class="built_in">console</span>.log(arr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>

<p>同理，利用 while 判断加上 some 的遍历来实现扁平化。</p>
<h2 id="reduce-方法"><a href="#reduce-方法" class="headerlink" title="reduce 方法"></a>reduce 方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> acc.concat(<span class="built_in">Array</span>.isArray(cur) ? flatten(cur) : cur);</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>

<h2 id="stack-方法"><a href="#stack-方法" class="headerlink" title="stack 方法"></a>stack 方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [...arr];</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">    <span class="keyword">let</span> first = stack.shift();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(first)) &#123;</span><br><span class="line">      stack.unshift(...first);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(first);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>

<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><p>如果全是数字，可以用 toString 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">    .toString()</span><br><span class="line">    .split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    .map(<span class="function">(<span class="params">item</span>) =&gt;</span> +item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>

<h2 id="flat"><a href="#flat" class="headerlink" title="flat"></a>flat</h2><p>es6 提供的新方法 flat(depth),参数 depth，代表展开嵌套数组的深度，默认是 1。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line">arr.flat(); <span class="comment">// [1, 2, 3, 4, [5, 6]]</span></span><br><span class="line">arr.flat(<span class="literal">Infinity</span>); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<p>depth 的值设置为 Infinity，无需知道数组的维度，直接将目标数组变成 1 维数组。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://juejin.cn/post/6844903805876699150">https://juejin.cn/post/6844903805876699150</a></p>
]]></content>
      <categories>
        <category>JavaScript专题系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>五、JavaScript专题之深浅拷贝</title>
    <url>/2020/02/26/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<p>本文主要记录一下深拷贝和浅拷贝的一些常用实现方式。</p>
<span id="more"></span>

<p>浅拷贝和深拷贝都只针对于引用数据类型，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存；但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象；<br>区别：浅拷贝只复制对象的第一层属性、深拷贝可以对对象的属性进行递归复制；</p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>常用方式：</p>
<ol>
<li>Object.assign 方法</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line">obj1.a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>for in 方法</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只复制第一层的浅拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleCopy</span>(<span class="params">obj1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj2 = <span class="built_in">Array</span>.isArray(obj1) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj1) &#123;</span><br><span class="line">    obj2[i] = obj1[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: &#123;</span><br><span class="line">    <span class="attr">d</span>: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = simpleCopy(obj1);</span><br><span class="line">obj2.a = <span class="number">3</span>;</span><br><span class="line">obj2.c.d = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// &#123;a:1, b:2, c:&#123;d:4&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>除了以上方法外，数组还有 slice, concat, 以及 ES6 提供的“…”运算符。当然这不是重点，重点是下面要说的深拷贝。</p>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><ol>
<li>通过 JSON 的序列化和反序列化来实现：parse、stringify:</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;张三&quot;</span>, <span class="attr">dog</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;小黑&quot;</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(obj, newObj); <span class="comment">//&#123;name:&quot;张三&quot;,dog:&#123;name:&quot;小黑&quot;&#125;&#125; &#123;name:&quot;张三&quot;,dog:&#123;name:&quot;小黑&quot;&#125;&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj == newObj); <span class="comment">//false</span></span><br><span class="line">newObj.dog.name = <span class="string">&quot;小花&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj, newObj); <span class="comment">//&#123;name:&quot;张三&quot;,dog:&#123;name:&quot;小黑&quot;&#125;&#125; &#123;name:&quot;张三&quot;,dog:&#123;name:&quot;小花&quot;&#125;&#125;;</span></span><br></pre></td></tr></table></figure>

<p>上面这种方式能满足我们日常业务需要，但是他有一个缺点，就是会忽略 undefined、任意的函数、symbol 值，因为 JSON 不支持这些数据类型；</p>
<ol start="2">
<li>递归调用</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否是&quot;纯粹的对象&quot;：</span></span><br><span class="line"><span class="comment"> * 该对象是通过 &quot;&#123;&#125;&quot; 或 &quot;new Object&quot; 创建的，该对象含有零个或者多个键值对</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> class2type = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> toString = class2type.toString;</span><br><span class="line"><span class="keyword">var</span> hasOwn = class2type.hasOwnProperty;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPlainObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> proto, Ctor;</span><br><span class="line">  <span class="keyword">if</span> (!obj || toString.call(obj) !== <span class="string">&quot;[object Object]&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  proto = <span class="built_in">Object</span>.getPrototypeOf(obj);</span><br><span class="line">  <span class="keyword">if</span> (!proto) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Ctor = hasOwn.call(proto, <span class="string">&quot;constructor&quot;</span>) &amp;&amp; proto.constructor;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="keyword">typeof</span> Ctor === <span class="string">&quot;function&quot;</span> &amp;&amp;</span><br><span class="line">    hasOwn.toString.call(Ctor) === hasOwn.toString.call(<span class="built_in">Object</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * extend</span></span><br><span class="line"><span class="comment"> * 内部方法：用户合并一个或多个对象到第一个对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;object&#125;</span> </span>target 目标对象  对象都合并到target里</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;source&#125;</span> </span>source 合并对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;boolean&#125;</span> </span>deep 是否执行深度合并</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">target, source, deep</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">    <span class="keyword">if</span> (deep &amp;&amp; (isPlainObject(source[key]) || <span class="built_in">Array</span>.isArray(source[key]))) &#123;</span><br><span class="line">      <span class="comment">// source[key] 是对象，而 target[key] 不是对象， 则 target[key] = &#123;&#125; 初始化一下，否则递归会出错的</span></span><br><span class="line">      <span class="keyword">if</span> (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key]))</span><br><span class="line">        target[key] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// source[key] 是数组，而 target[key] 不是数组，则 target[key] = [] 初始化一下，否则递归会出错的</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(source[key]) &amp;&amp; !<span class="built_in">Array</span>.isArray(target[key]))</span><br><span class="line">        target[key] = [];</span><br><span class="line">      <span class="comment">// 执行递归</span></span><br><span class="line">      extend(target[key], source[key], deep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不满足以上条件，说明 source[key] 是一般的值类型，直接赋值给 target 就是了</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (source[key] !== <span class="literal">undefined</span>) target[key] = source[key];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> deepClone = <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> deep,</span><br><span class="line">    args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第一个参数为boolean值时，表示是否深度合并</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target == <span class="string">&quot;boolean&quot;</span>) &#123;</span><br><span class="line">    deep = target;</span><br><span class="line">    <span class="comment">//target取第二个参数</span></span><br><span class="line">    target = args.shift();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历后面的参数，都合并到target上</span></span><br><span class="line">  args.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    extend(target, arg, deep);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="number">123</span>,<span class="attr">age</span>:<span class="number">123</span>,<span class="attr">c</span>:&#123;<span class="attr">d</span>:<span class="number">3</span>&#125;,<span class="attr">e</span>:&#123;<span class="attr">f</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;&#125;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = deepClone(<span class="literal">true</span>,&#123;&#125;, obj);</span><br><span class="line">obj2.c.d = <span class="number">12312</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj2);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript专题系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>清除浮动</title>
    <url>/2016/07/01/%E6%B8%85%E6%A5%9A%E6%B5%AE%E5%8A%A8/</url>
    <content><![CDATA[<h4 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h4><pre><code>.order_con:after&#123;
    content: ‘.’;
    display: block;
    visibility: hidden;
    width: 0px;
    height: 0px;
    clear: both;
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端的长按事件</title>
    <url>/2017/01/13/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E9%95%BF%E6%8C%89%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p><strong>Demo代码：</strong></p>
<span id="more"></span> 
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://lib.sinaapp.com/js/jquery/1.9.1/jquery-1.9.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:100%;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;touchArea&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:90%; height:200px; background-color:#CCC;font-size:100px&quot;</span>&gt;</span>长按我<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">var</span> timeOutEvent=<span class="number">0</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	$(<span class="string">&quot;#touchArea&quot;</span>).on(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="attr">touchstart</span>: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			timeOutEvent = <span class="built_in">setTimeout</span>(<span class="string">&quot;longPress()&quot;</span>,<span class="number">500</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		 	e.preventDefault();</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		&#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="attr">touchmove</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            		<span class="built_in">clearTimeout</span>(timeOutEvent);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		    	timeOutEvent = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		&#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		<span class="attr">touchend</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	   		<span class="built_in">clearTimeout</span>(timeOutEvent);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="keyword">if</span>(timeOutEvent!=<span class="number">0</span>)&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			    alert(<span class="string">&quot;你这是点击，不是长按&quot;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">			<span class="keyword">return</span> <span class="literal">false</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">		&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	&#125;)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="function"><span class="keyword">function</span> <span class="title">longPress</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    timeOutEvent = <span class="number">0</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    alert(<span class="string">&quot;长按事件触发发&quot;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端软键盘挡住输入框</title>
    <url>/2016/12/13/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%BD%AF%E9%94%AE%E7%9B%98%E6%8C%A1%E4%BD%8F%E8%BE%93%E5%85%A5%E6%A1%86/</url>
    <content><![CDATA[<p>在IOS端不需要加这一段代码，在软键盘出来的时候页面会自动被顶上去，但是Android不会，所以加一些条件判断，代码如下：</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> u = navigator.userAgent;</span><br><span class="line"><span class="keyword">var</span> isAndroid = u.indexOf(<span class="string">&#x27;Android&#x27;</span>) &gt; -<span class="number">1</span> || u.indexOf(<span class="string">&#x27;Adr&#x27;</span>) &gt; -<span class="number">1</span>; <span class="comment">//android终端</span></span><br><span class="line"><span class="keyword">var</span> isiOS = !!u.match(<span class="regexp">/\(i[^;]+;( U;)? CPU.+Mac OS X/</span>); <span class="comment">//ios终端</span></span><br><span class="line"><span class="comment">//处理isAndroid问题</span></span><br><span class="line"><span class="keyword">if</span> (isAndroid) &#123;</span><br><span class="line">     $(<span class="built_in">window</span>).on(<span class="string">&#x27;resize&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">document</span>.activeElement.tagName == <span class="string">&quot;INPUT&quot;</span> || <span class="built_in">document</span>.activeElement.tagName == <span class="string">&quot;TEXTAREA&quot;</span>) &#123;</span><br><span class="line">               <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　　　　　　　　<span class="built_in">document</span>.activeElement.scrollIntoViewIfNeeded();</span><br><span class="line">　　　　　　&#125;, <span class="number">0</span>);</span><br><span class="line">　　　&#125;</span><br><span class="line">　　  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title>不用0，1，2，以及加减乘除来进行运算</title>
    <url>/2016/07/03/%E7%A8%8B%E5%BA%8F%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>很久很久以前，有个叫阿隆佐·邱奇，发现只需要用函数，就可以用计算机实现运算，而不需要0、1、2、3这些数字和+、-、*、/这些符号。</p>
<p>JavaScript支持函数，所以可以通过JavaScript用函数来写这些计算。来试试：</p>
<span id="more"></span>
<pre><code>&#39;use strict&#39;;
// 定义数字0:
var zero = function (f) &#123;
    return function (x) &#123;
        return x;
    &#125;
&#125;;
// 定义数字1:
var one = function (f) &#123;
    return function (x) &#123;
        return f(x);
    &#125;
&#125;;
// 定义加法:
function add(n, m) &#123;
    return function (f) &#123;
        return function (x) &#123;
            return m(f)(n(f)(x));
        &#125;
    &#125;
&#125;
// 计算数字2 = 1 + 1:
var two = add(one, one);
// 计算数字3 = 1 + 2:
var three = add(one, two);
// 计算数字5 = 2 + 3:
var five = add(two, three);

// 你说它是3就是3，你说它是5就是5，你怎么证明？
// 给3传一个函数,会打印3次:
(three(function () &#123;
    console.log(&#39;print 3 times&#39;);
&#125;))();

// 给5传一个函数,会打印5次:
(five(function () &#123;
    console.log(&#39;print 5 times&#39;);
&#125;))();
</code></pre>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>三、JavaScript专题之类型判断(上)</title>
    <url>/2020/02/14/%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E4%B8%8A/</url>
    <content><![CDATA[<p>在项目开发中，我们经常会进行类型判断，这里对JS类型判断的方式进行一下总结。</p>
<span id="more"></span>
<p>在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures">MDN</a>中根据最新的 ECMAScript 标准定义了 8 种数据类型:</p>
<blockquote>
<p>基本类型（7种）：String, Number, Boolean, null, undefined, Bigint, Symbol。<br>引用类型（1种）：Object<br>下面我们来对这些类型进行检测。</p>
</blockquote>
<h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>typeof 操作符的唯一目的就是检查数据类型，但是如果我们希望检查任何从 Object 派生出来的结构类型，使用 typeof 是不起作用的，因为总是会得到 “object”。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>undefined</td>
<td>“undefined”</td>
</tr>
<tr>
<td>Boolean</td>
<td>“boolean”</td>
</tr>
<tr>
<td>Number</td>
<td>“number”</td>
</tr>
<tr>
<td>String</td>
<td>“string”</td>
</tr>
<tr>
<td>BigInt</td>
<td>“bigint”</td>
</tr>
<tr>
<td>Symbol</td>
<td>“symbol”</td>
</tr>
<tr>
<td>null</td>
<td>“object”</td>
</tr>
<tr>
<td>Function</td>
<td>“function”</td>
</tr>
<tr>
<td>其他任何对象</td>
<td>“object”</td>
</tr>
</tbody></table>
<p>注意：</p>
<ul>
<li>typeof Function: 结果是”function”，因为Function是一个构造函数，可以通过new操作符来构造对象</li>
<li>typeof null：结果是”object”，null是一个只有一个值的特殊类型。表示一个空对象引用。</li>
<li>typeof无法区分各种内置的对象，如Array, Date等。</li>
</ul>
<p>综上，typeof操作符能能返回的类型：</p>
<ul>
<li>string number boolean undefined symbol bigint</li>
<li>object 、(typeof null === ‘object’)</li>
<li>function</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>JS是动态类型的变量，每个变量在存储时除了存储变量值外，还需要存储变量的类型。JS里使用32位（bit）存储变量信息。低位的1~3个bit存储变量类型信息，叫做类型标签(type tag)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.... XXXX X000 <span class="comment">// object</span></span><br><span class="line">.... XXXX XXX1 <span class="comment">// int</span></span><br><span class="line">.... XXXX X010 <span class="comment">// double</span></span><br><span class="line">.... XXXX X100 <span class="comment">// string</span></span><br><span class="line">.... XXXX X110 <span class="comment">// boolean</span></span><br></pre></td></tr></table></figure>
<ul>
<li>只有int类型的type tag使用1个bit，并且取值为1，其他都是3个bit, 并且低位为0。这样可以通过type tag低位取值判断是否为int数据；</li>
<li>为了区分int，还剩下2个bit，相当于使用2个bit区分这四个类型：object, double, string, boolean；</li>
<li>但是null，undefined和Function并没有分配type tag。</li>
</ul>
<h4 id="如何识别Function"><a href="#如何识别Function" class="headerlink" title="如何识别Function"></a>如何识别Function</h4><p>函数并没有单独的type tag，因为函数也是对象。typeof内部判断如果一个对象实现了[[call]]内部方法则认为是函数。</p>
<h4 id="如何识别undefined"><a href="#如何识别undefined" class="headerlink" title="如何识别undefined"></a>如何识别undefined</h4><p>undefined变量存储的是个特殊值JSVAL_VOID（0-2^30），typeof内部判断如果一个变量存储的是这个特殊值，则认为是undefined。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#define JSVAL_VOID INT_TO_JSVAL(<span class="number">0</span> - JSVAL_INT_POW2(<span class="number">30</span>))</span><br></pre></td></tr></table></figure>
<h4 id="如何识别null"><a href="#如何识别null" class="headerlink" title="如何识别null"></a>如何识别null</h4><p>null变量存储的也是个特殊值JSVAL_NULL，并且恰巧取值是空指针机器码(0)，正好低位bit的值跟对象的type tag是一样的，这也是 <em>typeof null === ‘object’</em> 的原因。</p>
<h2 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>前面已经知道typeof Object 只会返回’object’,无法区分 Object 下细分的类型呐，如 Array、Function、Date、RegExp、Error 等。<br>所以我们一般使用Object.prototype.toString区分各种内置对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>)); <span class="comment">// [object Number]，隐式类型转换</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="string">&#x27;&#x27;</span>)); <span class="comment">// [object String]，隐式类型转换</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>)); <span class="comment">// [object Null]，特殊处理</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>)); <span class="comment">// [object Undefined]，特殊处理</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>)); <span class="comment">// [object Boolean]，隐式类型转换</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call( &#123;&#125;)); <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call([])); <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)); <span class="comment">// [object Function]</span></span><br></pre></td></tr></table></figure>
<ol>
<li>如果实参是个基本类型，会自动转成对应的引用类型;<blockquote>
<p>Object.prototype.toString不能区分基本类型的，只是用于区分各种对象；</p>
</blockquote>
</li>
<li>null和undefined不存在对应的引用类型，内部特殊处理了;</li>
</ol>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>每个对象都有个内部属性[[Class]]，内置对象的[[Class]]的值都是不同的（”Arguments”, “Array”, “Boolean”, “Date”, “Error”, “Function”, “JSON”, “Math”, “Number”, “Object”, “RegExp”, “String”），并且目前[[Class]]属性值只能通过Object.prototype.toString访问。</p>
<h4 id="Symbol-toStringTag属性"><a href="#Symbol-toStringTag属性" class="headerlink" title="Symbol.toStringTag属性"></a>Symbol.toStringTag属性</h4><p>其实Object.prototype.toString内部先访问对象的Symbol.toStringTag属性值拼接返回值的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(a)); <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改Symbol.toStringTag值</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">String</span>.prototype, <span class="built_in">Symbol</span>.toStringTag, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;MyString&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(a)); <span class="comment">// &quot;[object MyString]&quot;</span></span><br></pre></td></tr></table></figure>
<p>所以不要轻易修改内置对象的Symbol.toStringTag属性值，否则Object.prototype.toString就不能正常使用。</p>
<h4 id="Object-prototype-toString内部逻辑"><a href="#Object-prototype-toString内部逻辑" class="headerlink" title="Object.prototype.toString内部逻辑"></a>Object.prototype.toString内部逻辑</h4><p>在<a href="https://262.ecma-international.org/6.0/#sec-object.prototype.tostring">ECMA-262</a>规范中，第19.1.3.6 Object.prototype.toString ( )条介绍：</p>
<blockquote>
<p>When the toString toString method is called, the following steps are taken:</p>
<ol>
<li>If the this value is undefined, return “[object Undefined]”.</li>
<li>If the this value is null, return “[object Null]”.</li>
<li>Let O be ToObject(this value).</li>
<li>Let isArray be IsArray(O).</li>
<li>ReturnIfAbrupt(isArray).</li>
<li>If isArray is true, let builtinTag be “Array”.</li>
<li>Else, if O is an exotic String object, let builtinTag be “String”.</li>
<li>Else, if O has an [[ParameterMap]] internal slot, let builtinTag be “Arguments”.</li>
<li>Else, if O has a [[Call]] internal method, let builtinTag be “Function”.</li>
<li>Else, if O has an [[ErrorData]] internal slot, let builtinTag be “Error”.</li>
<li>Else, if O has a [[BooleanData]] internal slot, let builtinTag be “Boolean”.</li>
<li>Else, if O has a [[NumberData]] internal slot, let builtinTag be “Number”.</li>
<li>Else, if O has a [[DateValue]] internal slot, let builtinTag be “Date”.</li>
<li>Else, if O has a [[RegExpMatcher]] internal slot, let builtinTag be “RegExp”.</li>
<li>Else, let builtinTag be “Object”.</li>
<li>Let tag be Get (O, @@toStringTag).</li>
<li>ReturnIfAbrupt(tag).</li>
<li>If Type(tag) is not String, let tag be builtinTag.</li>
<li>Return the String that is the result of concatenating “[object “, tag, and “]”.</li>
</ol>
</blockquote>
<h2 id="Instanceof"><a href="#Instanceof" class="headerlink" title="Instanceof"></a>Instanceof</h2><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">object <span class="keyword">instanceof</span> <span class="title">constructorFunc</span></span><br></pre></td></tr></table></figure>
<p>instanceof 操作符判断构造函数constructorFunc的prototype属性是否在对象object的原型链上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create(&#123;&#125;) <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ol>
<li>作为类型判断的一种方式，instanceof 操作符不会对变量object进行隐式类型转换<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// false，基本类型不会转成对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;&#x27;</span>) <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li>对于没有原型的对象或则基本类型直接返回false<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
<li>constructorFunc必须是个对象。并且大部分情况要求是个构造函数（即要具有prototype属性）<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TypeError: Right-hand side of &#x27;instanceof&#x27; is not an object</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">instanceof</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeError: Right-hand side of &#x27;instanceof&#x27; is not callable</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">instanceof</span> (&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeError: Function has non-object prototype &#x27;undefined&#x27; in instanceof check</span></span><br><span class="line">(&#123;&#125;) <span class="keyword">instanceof</span> (<span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>参照<a href="https://tc39.es/ecma262/#sec-instanceofoperator">ECMA</a>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 如果constructorFunc不是个对象，或则是null，直接抛TypeError异常；</span><br><span class="line">2. 如果constructorFunc[Symbole.hasInstance]方法，则返回!!constructorFunc[Symbole.hasInstance](object )</span><br><span class="line">3. 如果constructorFunc不是函数，直接抛TypeError异常；</span><br><span class="line">4. 遍历object的原型链，逐个跟constructorFunc.prototype属性比较：</span><br><span class="line">   - 如果object没有原型，则直接返回false;</span><br><span class="line">   - 如果constructorFunc.prototype不是对象，则直接抛TypeError异常。</span><br></pre></td></tr></table></figure>

<h2 id="内置的类型判断方法"><a href="#内置的类型判断方法" class="headerlink" title="内置的类型判断方法"></a>内置的类型判断方法</h2><h3 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray"></a>Array.isArray</h3><p>ES5引入了方法Array.isArray专门用于数组类型判断。Object.prototype.toString和instanceof都不够严格</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Array</span>.prototype, <span class="built_in">Symbol</span>.toStringTag, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;myArray&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arr)); <span class="comment">// [object myArray]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arr)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(<span class="built_in">Array</span>.prototype)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>不过现实情况下基本都是利用Object.prototype.toString作为Array.isArray的polyfill:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.isArray = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(arg) === <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://bbs.huaweicloud.com/blogs/238951">https://bbs.huaweicloud.com/blogs/238951</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/28">https://github.com/mqyqingfeng/Blog/issues/28</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript专题系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>四、JavaScript专题之类型判断(下)</title>
    <url>/2020/02/18/%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E4%B8%8B/</url>
    <content><![CDATA[<p>上一篇文章中我们总结了类型判断的几种方式（typeof、Object.prototype.toString、Instanceof、isArray），这里我们写一个 type 函数来帮我们区分识别各种类型的值。</p>
<span id="more"></span>

<h2 id="基础函数-type"><a href="#基础函数-type" class="headerlink" title="基础函数 type"></a>基础函数 type</h2><p>首先，列出我们需要判断的常用类型（11 种）：Boolean Number String Function Array Date RegExp Object Error Null Undefined；<br>我们的目标是：type(123) // 得到：number;<br>这里我们通过 typeof 和 Object.prototype.toString 来分别处理基础类型和引用类型，由于 null 和 undefined 会被 Object.prototype.toString 识别成 [object Object]，所以它俩需要单独处理，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> class2type = &#123;&#125;;</span><br><span class="line"><span class="string">&quot;Boolean Number String Function Array Date RegExp Object Error&quot;</span></span><br><span class="line">  .split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">  .map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    class2type[<span class="string">&quot;[object &quot;</span> + item + <span class="string">&quot;]&quot;</span>] = item.toLowerCase();</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj + <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> obj === <span class="string">&quot;function&quot;</span></span><br><span class="line">    ? class2type[<span class="built_in">Object</span>.prototype.toString.call(obj)] || <span class="string">&quot;object&quot;</span> <span class="comment">// 这里主要处理新增的类型：Set Map等等</span></span><br><span class="line">    : <span class="keyword">typeof</span> obj;</span><br><span class="line">&#125;</span><br><span class="line">type(<span class="number">123</span>); <span class="comment">// &quot;number&quot;</span></span><br><span class="line">type(class2type); <span class="comment">// &quot;object&quot;</span></span><br><span class="line">type(type); <span class="comment">// &quot;function&quot;</span></span><br><span class="line">type(<span class="literal">null</span>); <span class="comment">// &quot;null&quot;</span></span><br><span class="line">type(<span class="regexp">/^\d+$/</span>); <span class="comment">// &quot;regexp&quot;</span></span><br><span class="line">type(<span class="keyword">new</span> <span class="built_in">Error</span>()); <span class="comment">// &quot;error&quot;</span></span><br><span class="line">type(<span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">// &quot;date&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="常用函数封装"><a href="#常用函数封装" class="headerlink" title="常用函数封装"></a>常用函数封装</h2><p>有了 type 函数后，我们就可以直接对常用函数进行封装</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> type(obj) === <span class="string">&quot;function&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isDate</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> type(obj) === <span class="string">&quot;date&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">var</span> isArray =</span><br><span class="line">  <span class="built_in">Array</span>.isArray ||</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> type(obj) === <span class="string">&quot;array&quot;</span>;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="isEmptyObject"><a href="#isEmptyObject" class="headerlink" title="isEmptyObject"></a>isEmptyObject</h2><p>判断是否是空对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEmptyObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(isEmptyObject(&#123;&#125;)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isEmptyObject([])); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isEmptyObject(<span class="literal">null</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isEmptyObject(<span class="literal">undefined</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isEmptyObject(<span class="number">1</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isEmptyObject(<span class="string">&quot;&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isEmptyObject(<span class="literal">true</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="isWindow"><a href="#isWindow" class="headerlink" title="isWindow"></a>isWindow</h2><p>Window 对象作为客户端 JavaScript 的全局对象，它有一个 window 属性指向自身，基于这个特性来判断是否是 Window 对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isWindow</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj != <span class="literal">null</span> &amp;&amp; obj === obj.window;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="isElement"><a href="#isElement" class="headerlink" title="isElement"></a>isElement</h2><p>判断是否是 DOM 节点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isElement</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!(obj &amp;&amp; obj.nodeType === <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/30">https://github.com/mqyqingfeng/Blog/issues/30</a></li>
<li><a href="https://github.com/jquery/jquery/blob/ac9e3016645078e1e42120822cfb2076151c8cbe/src/core.js#L269">https://github.com/jquery/jquery/blob/ac9e3016645078e1e42120822cfb2076151c8cbe/src/core.js#L269</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript专题系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>素数算法</title>
    <url>/2016/06/21/%E7%B4%A0%E6%95%B0%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="找出数组中的素数"><a href="#找出数组中的素数" class="headerlink" title="找出数组中的素数"></a>找出数组中的素数</h3><p>例如    shu([1,2,5,9,7,8,6,13,56,48,46]) = [2, 5, 7, 13];</p>
<pre><code>function shu(arr)&#123;
    return arr.filter(
        function(num) &#123;
          if (num == 1) &#123;
            return false;
          &#125;
          if (num == 2) &#123;
            return true;
          &#125;
          for (var i = 2; i &lt;= Math.sqrt(num); i++) &#123;
            if (num % i == 0) &#123;
              return false;
            &#125;
          &#125;
          return true;
        &#125;
    )
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>七、JavaScript之闭包</title>
    <url>/2019/09/01/%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>闭包在 MDN 中的定义：</p>
<blockquote>
<p>一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。</p>
</blockquote>
<p>这里只有一类函数除外，那就是通过 Function 构造器创建的函数，因为其[[Scope]]只包含全局对象。</p>
<span id="more"></span>

<p>为了更好的澄清该问题，我们对 ECMAScript 中的闭包给出 2 个正确的版本定义：</p>
<p>ECMAScript 中，闭包指的是：</p>
<ol>
<li>从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。</li>
<li>从实践角度：以下函数才算是闭包：</li>
<li>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</li>
<li>在代码中引用了自由变量</li>
</ol>
<p>下面我们主要讨论实践上的闭包。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这里我们需要注意的是：在 ECMAScript 中，同一个父上下文中创建的闭包是共用一个[[Scope]]属性的。也就是说，某个闭包对其中[[Scope]]的变量做修改会影响到其他闭包对其变量的读取：</p>
<p>这就是说：所有的内部函数都共享同一个父作用域</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> firstClosure;</span><br><span class="line"><span class="keyword">var</span> secondClosure;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  firstClosure = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++x;</span><br><span class="line">  &#125;;</span><br><span class="line">  secondClosure = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> --x;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  x = <span class="number">2</span>; <span class="comment">// 影响 AO[&quot;x&quot;], 在2个闭包公有的[[Scope]]中</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(firstClosure()); <span class="comment">// 3, 通过第一个闭包的[[Scope]]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstClosure()); <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(secondClosure()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>因为我们经常会遇到这样一个面试题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">  data[k] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>](); <span class="comment">// 3, 而不是0</span></span><br><span class="line">data[<span class="number">1</span>](); <span class="comment">// 3, 而不是1</span></span><br><span class="line">data[<span class="number">2</span>](); <span class="comment">// 3, 而不是2</span></span><br></pre></td></tr></table></figure>

<p>上述当执行到 data[0] 函数之前，此时全局上下文的 VO 为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">globalContext = &#123;</span><br><span class="line">    <span class="attr">VO</span>: &#123;</span><br><span class="line">        <span class="attr">data</span>: [...],</span><br><span class="line">        <span class="attr">k</span>: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当执行 data[0] 函数的时候，data[0] 函数的作用域链为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data[<span class="number">0</span>]Context = &#123;</span><br><span class="line">    <span class="attr">Scope</span>: [AO, globalContext.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>data[0]Context 的 AO 并没有 k 值，所以会从 globalContext.VO 中查找，k 为 3，所以打印的结果就是 3。data[1] 和 data[2] 是一样的道理。<br>如下所示，创建一个闭包就可以解决这个问题了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">  data[k] = (<span class="function"><span class="keyword">function</span> <span class="title">_helper</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(k); <span class="comment">// 传入&quot;k&quot;值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在结果是正确的了</span></span><br><span class="line">data[<span class="number">0</span>](); <span class="comment">// 0</span></span><br><span class="line">data[<span class="number">1</span>](); <span class="comment">// 1</span></span><br><span class="line">data[<span class="number">2</span>](); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>当执行到 data[0] 函数之前，此时全局上下文的 VO 为:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">globalContext = &#123;</span><br><span class="line">    <span class="attr">VO</span>: &#123;</span><br><span class="line">        <span class="attr">data</span>: [...],</span><br><span class="line">        <span class="attr">k</span>: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟之前一样，但是 data[0]的作用域链发生了变化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data[<span class="number">0</span>]Context = &#123;</span><br><span class="line">    <span class="attr">Scope</span>: [AO,_helperContext.AO, globalContext.VO]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 匿名函数执行上下文的 AO 为：</span></span><br><span class="line">_helperContext = &#123;</span><br><span class="line">  <span class="attr">VO</span>: &#123;</span><br><span class="line">         <span class="attr">arguments</span>: &#123;</span><br><span class="line">            <span class="number">0</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">length</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">k</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">Scope</span>: [AO, globalContext.VO]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>data[0]Context 的 AO 并没有 k 值，所以会沿着作用域链从_helperContenx.AO 中查找，这时候找到 k 为 0，找到了就不会往 globalContext.VO 中查找了，即使 globalContext.VO 也有 K 的值(值为 3)，所以打印的结果就是 0。同理 data[1]、data[2]的值就是 1 和 2。</p>
<h2 id="闭包用法实战"><a href="#闭包用法实战" class="headerlink" title="闭包用法实战"></a>闭包用法实战</h2><p>实际使用的时候，闭包可以创建出非常优雅的设计，允许对funarg上定义的多种计算方式进行定制。如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组排序,它接受一个排序条件函数作为参数</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  ... <span class="comment">// 排序条件</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的map方法是根据函数中定义的条件将原数组映射到一个新的数组中：</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> element * <span class="number">2</span>;</span><br><span class="line">&#125;); <span class="comment">// [2, 4, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的find方法实现一个搜索功能，并且可以支持无限制的搜索条件：</span></span><br><span class="line">someCollection.find(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> element.someProperty == <span class="string">&#x27;searchCondition&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还有应用函数，比如常见的forEach方法，将函数应用到每个数组元素：</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (element % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(element);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;); <span class="comment">// 1, 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺便提下，函数对象的 apply 和 call方法，在函数式编程中也可以用作应用函数。 apply和call已经在讨论“this”的时候介绍过了；这里，我们将它们看作是应用函数 —— 应用到参数中的函数（在apply中是参数列表，在call中是独立的参数）：</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert([].join.call(<span class="built_in">arguments</span>, <span class="string">&#x27;;&#x27;</span>)); <span class="comment">// 1;2;3</span></span><br><span class="line">&#125;).apply(<span class="built_in">this</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 闭包还有另外一个非常重要的应用 —— 延迟调用：</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(a); <span class="comment">// 10, after one second</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还有回调函数</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// only for example</span></span><br><span class="line">xmlHttpRequestObject.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当数据就绪的时候，才会调用;</span></span><br><span class="line">  <span class="comment">// 这里，不论是在哪个上下文中创建</span></span><br><span class="line">  <span class="comment">// 此时变量“x”的值已经存在了</span></span><br><span class="line">  alert(x); <span class="comment">// 10</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以创建封装的作用域来隐藏辅助对象：</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123;&#125;;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">object</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  object.getX = <span class="function"><span class="keyword">function</span> <span class="title">_getX</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;)(foo);</span><br><span class="line"></span><br><span class="line">alert(foo.getX()); <span class="comment">// 获得闭包 &quot;x&quot; – 10</span></span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures</a><br><a href="https://juejin.cn/post/6844903475998900237">https://juejin.cn/post/6844903475998900237</a><br><a href="http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/">http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/</a></p>
]]></content>
      <categories>
        <category>深入理解JavaScript系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Github打不开问题</title>
    <url>/2021/07/19/%E8%AE%B0%E5%BD%95GitHub%E7%BD%91%E9%A1%B5hosts%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>github 最近打不开，很久之前遇到过，但是忘记怎么解决了，查找相关资料后，今天记录在此，以备不时之需：</p>
<span id="more"></span>

<h2 id="确定-Github-网址-IP"><a href="#确定-Github-网址-IP" class="headerlink" title="确定 Github 网址 IP"></a>确定 Github 网址 IP</h2><p>打开网站：<a href="https://github.com.ipaddress.com/">https://github.com.ipaddress.com/</a><br>找到<strong>IP Address</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP Address	140.82.114.4</span><br></pre></td></tr></table></figure>

<h2 id="确定-Github-域名-IP"><a href="#确定-Github-域名-IP" class="headerlink" title="确定 Github 域名 IP"></a>确定 Github 域名 IP</h2><p>打开网站：<a href="https://fastly.net.ipaddress.com/github.global.ssl.fastly.net">https://fastly.net.ipaddress.com/github.global.ssl.fastly.net</a><br>找到<strong>IP Address</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IP Address	199.232.5.194</span><br></pre></td></tr></table></figure>

<h2 id="确定静态资源-IP"><a href="#确定静态资源-IP" class="headerlink" title="确定静态资源 IP"></a>确定静态资源 IP</h2><p>打开网站：<a href="https://github.com.ipaddress.com/assets-cdn.github.com">https://github.com.ipaddress.com/assets-cdn.github.com</a><br>找到<strong>IPv4 addresses</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IPv4 Addresses	185.199.108.153</span><br><span class="line">IPv4 Addresses	185.199.109.153</span><br><span class="line">IPv4 Addresses	185.199.110.153</span><br><span class="line">IPv4 Addresses	185.199.111.153</span><br></pre></td></tr></table></figure>

<h2 id="修改-hosts-文件"><a href="#修改-hosts-文件" class="headerlink" title="修改 hosts 文件"></a>修改 hosts 文件</h2><p>找到 hosts 文件：C:\Windows\System32\drivers\etc<br>修改 host 文件，在最后附上下面的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">140.82.114.4 github.com</span><br><span class="line">199.232.5.194 github.global.ssl.fastly.net</span><br><span class="line">185.199.108.153 assets-cdn.github.com</span><br><span class="line">185.199.109.153 assets-cdn.github.com</span><br><span class="line">185.199.110.153 assets-cdn.github.com</span><br><span class="line">185.199.111.153 assets-cdn.github.com</span><br></pre></td></tr></table></figure>

<p>最后还需要刷新 dns 缓存：cmd:ipconfig /flushdns</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/158938544">https://zhuanlan.zhihu.com/p/158938544</a></li>
</ul>
]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>一、JavaScript专题之防抖和节流</title>
    <url>/2020/01/12/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<p>在项目中，我们经常会绑定一些持续触发的事件，比如 resize、scroll、mousemove 等等，如果事件调用无限制，会加重浏览器负担，导致用户体验差，我们可以使用 debounce(防抖)和 throttle(节流)的方式来减少频繁的调用，同时也不会影响实际的效果。</p>
<span id="more"></span>

<h2 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖(debounce)"></a>防抖(debounce)</h2><p>防抖，顾名思义，防止抖动，指在一段时间内，不论触发多少次，都已最后一次为准。<br>换句话说，在触发事件后 n 秒后才执行函数，如果在 n 秒内再次触发了事件，则会重新计算函数执行时间。<br>总而言之，就是不管触发多少次，都要最后一次事件后 n 秒内不再触发事件，才会执行。<br>那么防抖有哪些应用场景呢？</p>
<ol>
<li>登录、发短信等按钮避免用户点击太快，以致于发送了多次请求，需要防抖；</li>
<li>调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖</li>
<li>文本编辑器实时保存，当无任何更改操作一秒后进行保存</li>
</ol>
<p>下面我们实现了一个简单的示例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">f, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      f(...args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> actionFun = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count++);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, debounce(actionFun, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>

<p>从上面代码可以看出<strong>防抖重在清零 clearTimeout(timer)</strong><br>接下来处理 this 的指向和 event 对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">f, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="built_in">this</span>;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      f.call(context, ...args);</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> actionFun = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count++); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">  <span class="built_in">console</span>.log(e); <span class="comment">// Event</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, debounce(actionFun, <span class="number">1000</span>));</span><br></pre></td></tr></table></figure>

<p>防抖函数可以分为立即执行和非立即执行版本：</p>
<ul>
<li>立即执行函数：立即执行就是触发事件后马上先执行一次，之后在设定 wait 时间内触犯的事件无效，不会执行，直到用户停止执行事件等待 wait 秒后才可以重新触发执行</li>
<li>非立即执行函数： 多次触发事件，只会在最后一次触发事件后等待设定的 wait 时间结束时执行一次。<br>下面我们增加一个参数 immediate 来判断是否立即执行：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc </span>函数防抖</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn 函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>wait 延迟执行毫秒数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>immediate true 表立即执行，false 表示非立即执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">f, wait, immediate = <span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer;</span><br><span class="line">  <span class="keyword">var</span> dobounced = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">      <span class="comment">// 如果已经执行过，则不再执行</span></span><br><span class="line">      <span class="keyword">var</span> callNow = !timer;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;, wait);</span><br><span class="line">      <span class="keyword">if</span> (callNow) f.call(context, ...args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        f.call(context, ...args);</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> actionFun = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count++); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">  <span class="built_in">console</span>.log(e); <span class="comment">// Event</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, debounce(actionFun, <span class="number">1000</span>, <span class="literal">true</span>));</span><br></pre></td></tr></table></figure>

<p>如过希望能取消 debounce 函数，比如说我 debounce 的时间间隔是 10 秒钟，immediate 为 true，这样的话，我只有等 10 秒后才能重新触发事件，现在我希望有一个按钮，点击后，取消防抖，这样我再去触发，就可以又立刻执行啦。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">f, wait, immediate = <span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer;</span><br><span class="line">  <span class="keyword">var</span> dobounced = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">      <span class="comment">// 如果已经执行过，则不再执行</span></span><br><span class="line">      <span class="keyword">var</span> callNow = !timer;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;, wait);</span><br><span class="line">      <span class="keyword">if</span> (callNow) f.call(context, ...args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        f.call(context, ...args);</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  dobounced.cancel = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    clearTimout(timer);</span><br><span class="line">    timer = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> dobounced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流 (throttle)"></a>节流 (throttle)</h2><p>节流，顾名思义，控制水的流量。控制事件发生的频率，如控制为 1s 发生一次，甚至 1 分钟发生一次。与服务端(server)及网关(gateway)控制的限流 (Rate Limit) 类似。<br>换句话说，连续触发事件但在 n 秒内只执行一次函数。<br>那么节流又有哪些应用场景呢？</p>
<ol>
<li>scroll 事件，每隔一秒计算一次位置信息等</li>
<li>浏览器播放事件，每个一秒计算一次进度信息等</li>
<li>input 框实时搜索并发送请求展示下拉列表，没隔一秒发送一次请求 (也可做防抖)</li>
</ol>
<p>关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。</p>
<h3 id="使用时间戳"><a href="#使用时间戳" class="headerlink" title="使用时间戳"></a>使用时间戳</h3><p>让我们来看第一种方法：使用时间戳，当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prev = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (now - prev &gt; wait) &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">      prev = now;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> actionFun = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count++); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">  <span class="built_in">console</span>.log(e); <span class="comment">// Event</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, throttle(actionFun, <span class="number">5000</span>));</span><br></pre></td></tr></table></figure>

<h3 id="使用定时器"><a href="#使用定时器" class="headerlink" title="使用定时器"></a>使用定时器</h3><p>接下来，我们讲讲第二种实现方式: 使用定时器,当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行结束，然后执行函数，清空定时器，这样就可以设置下个定时器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">        fn.apply(context, args);</span><br><span class="line">      &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> actionFun = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count++); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">  <span class="built_in">console</span>.log(e); <span class="comment">// Event</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, throttle(actionFun, <span class="number">5000</span>));</span><br></pre></td></tr></table></figure>

<p>所以比较两个方法：</p>
<ul>
<li>第一种事件会立刻执行，第二种事件会在 n 秒后第一次执行</li>
<li>第一种事件停止触发后没有办法再执行事件，第二种事件停止触发后依然会再执行一次事件</li>
</ul>
<h3 id="节流优化"><a href="#节流优化" class="headerlink" title="节流优化"></a>节流优化</h3><p>现在我们将上面两种方法合并，既可以立刻执行，又可以停止触发的时候还能再执行一次。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer, context, args, result;</span><br><span class="line">  <span class="keyword">var</span> prev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    prev = <span class="built_in">Date</span>.now();</span><br><span class="line">    timer = <span class="literal">null</span>;</span><br><span class="line">    fn.apply(context, args);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下次触发剩余时间</span></span><br><span class="line">    <span class="keyword">var</span> remaining = wait - (now - prev);</span><br><span class="line"></span><br><span class="line">    context = <span class="built_in">this</span>;</span><br><span class="line">    args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="comment">// 如果没有剩余的时间或者修改了系统时间</span></span><br><span class="line">    <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      prev = now;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">      <span class="keyword">if</span> (!timer) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(later, remaining);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> throttled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> actionFun = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count++); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">  <span class="built_in">console</span>.log(e); <span class="comment">// Event</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, throttle(actionFun, <span class="number">5000</span>));</span><br></pre></td></tr></table></figure>

<p>现在，我需要能够自定义是否立刻执行、和是否可以停止触发的时候还能再执行一次，现在增加第三个参数 options，然后根据传值判断如何执行：</p>
<ul>
<li>leading: fasle，表示禁用立刻执行；</li>
<li>trailing: false，表示禁用停止触发的回调</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer, context, args, result;</span><br><span class="line">  <span class="keyword">var</span> prev = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    prev = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : <span class="built_in">Date</span>.now();</span><br><span class="line">    timer = <span class="literal">null</span>;</span><br><span class="line">    fn.apply(context, args);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!prev &amp;&amp; options.leading === <span class="literal">false</span>) prev = now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下次触发剩余时间</span></span><br><span class="line">    <span class="keyword">var</span> remaining = wait - (now - prev);</span><br><span class="line"></span><br><span class="line">    context = <span class="built_in">this</span>;</span><br><span class="line">    args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="comment">// 如果没有剩余的时间或者修改了系统时间</span></span><br><span class="line">    <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">      <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      prev = now;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">      <span class="keyword">if</span> (!timer) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timer &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(later, remaining);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> throttled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> actionFun = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count++); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">  <span class="built_in">console</span>.log(e); <span class="comment">// Event</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, throttle(actionFun, <span class="number">5000</span>, &#123;</span><br><span class="line">  <span class="attr">leading</span>: <span class="literal">false</span> </span><br><span class="line">&#125;));</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>, throttle(actionFun, <span class="number">5000</span>, &#123;</span><br><span class="line">  <span class="attr">trailing</span>: <span class="literal">false</span> </span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>注意，这里leading和trailing不能同时设为false。<br>同样取消也是增加一个cancel函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">throttled.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    prev = <span class="number">0</span>;</span><br><span class="line">    timer = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://github.com/mqyqingfeng/Blog/issues/26">https://github.com/mqyqingfeng/Blog/issues/26</a></p>
]]></content>
      <categories>
        <category>JavaScript专题系列笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>模板引擎、字节转换、map函数</title>
    <url>/2016/06/23/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h5 id="1-模板引擎"><a href="#1-模板引擎" class="headerlink" title="1. 模板引擎"></a>1. 模板引擎</h5><pre><code>var reg = /\$\&#123;[a-zA-Z]+\&#125;/g;
var tpl = &quot;hello $&#123;who&#125;!&quot;;
var obj = &#123;who:&quot;world&quot;&#125;;
function template(tpl,obj)&#123;
        var s = reg.exec(tpl);
        var s1 = s[0].slice(2,-1);
        document.write(tpl.replace(reg,obj[s1]));
    &#125;
    //template(tpl,obj);
    template(&#39;Hello,$&#123;name&#125;&#39;,&#123;name:&quot;hedahang&quot;&#125;);
</code></pre>
<span id="more"></span>
<h5 id="2-字节转换"><a href="#2-字节转换" class="headerlink" title="2. 字节转换"></a>2. 字节转换</h5><pre><code>&lt;pre&gt;function bytesToSize(bytes) &#123;
    if (bytes === 0) return &#39;0 B&#39;;
    var k = 1024,
            sizes = [&#39;B&#39;, &#39;KB&#39;, &#39;MB&#39;, &#39;GB&#39;, &#39;TB&#39;, &#39;PB&#39;, &#39;EB&#39;, &#39;ZB&#39;, &#39;YB&#39;],
            i = Math.floor(Math.log(bytes) / Math.log(k));
    return (bytes / Math.pow(k, i)).toPrecision(3) + &#39; &#39; + sizes[i];
&#125;
console.log( bytesToSize(12345));&lt;/pre&gt;
</code></pre>
<h5 id="3-map函数"><a href="#3-map函数" class="headerlink" title="3. map函数"></a>3. map函数</h5><pre><code>&lt;pre&gt;function map(arr,fun)&#123;
    var array = [];
    for(var i = 0;i&lt;arr.length;i++)&#123;
        if( i == 0)&#123;
            array[i] = fun(0,arr[i]);
        &#125;else&#123;
            array[i] = fun(arr[i-1],arr[i])
        &#125;
    console.log(array);
    &#125;
&#125;
map([1,2,3,4,5],function(o,i)&#123;return o + i;&#125;)&lt;/pre&gt;
</code></pre>
]]></content>
      <categories>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown编辑器：马克飞象</title>
    <url>/2016/07/23/%E9%A9%AC%E5%85%8B%E9%A3%9E%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="欢迎使用马克飞象"><a href="#欢迎使用马克飞象" class="headerlink" title="欢迎使用马克飞象"></a>欢迎使用马克飞象</h1><p>@(示例笔记本)[马克飞象|帮助|Markdown]</p>
<p><strong>马克飞象</strong>是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述：</p>
<ul>
<li><strong>功能丰富</strong> ：支持高亮代码块、<em>LaTeX</em> 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手；</li>
<li><strong>得心应手</strong> ：简洁高效的编辑器，提供<a href="http://maxiang.info/client_zh">桌面客户端</a>以及<a href="https://chrome.google.com/webstore/detail/kidnkfckhbdkfgbicccmdggmpgogehop">离线Chrome App</a>，支持移动端 Web；</li>
<li><strong>深度整合</strong> ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。</li>
</ul>
<hr>
<span id="more"></span>
<p>[TOC]</p>
<h2 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h2><blockquote>
<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown">维基百科</a></p>
</blockquote>
<p>正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href="http://www.example.com/">链接</a>或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按<code>Ctrl + /</code>查看帮助。</p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span>(<span class="params">param1=<span class="string">&#x27;&#x27;</span>, param2=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;Greater&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="literal">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">&#x27;&#x27;&#x27;interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="LaTeX-公式"><a href="#LaTeX-公式" class="headerlink" title="LaTeX 公式"></a>LaTeX 公式</h3><p>可以创建行内公式，例如 $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。或者块级公式：</p>
<p>$$    x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table>
<thead>
<tr>
<th align="left">Item</th>
<th align="right">Value</th>
<th align="center">Qty</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Computer</td>
<td align="right">1600 USD</td>
<td align="center">5</td>
</tr>
<tr>
<td align="left">Phone</td>
<td align="right">12 USD</td>
<td align="center">12</td>
</tr>
<tr>
<td align="left">Pipe</td>
<td align="right">1 USD</td>
<td align="center">234</td>
</tr>
</tbody></table>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">e=&gt;end</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>

<p>以及时序图:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示：</strong>想了解更多，请查看<strong>流程图</strong><a href="http://adrai.github.io/flowchart.js/">语法</a>以及<strong>时序图</strong><a href="http://bramp.github.io/js-sequence-diagrams/">语法</a>。</p>
</blockquote>
<h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><p>使用 <code>- [ ]</code> 和 <code>- [x]</code> 语法可以创建复选框，实现 todo-list 等功能。例如：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 已完成事项</li>
<li><input disabled="" type="checkbox"> 待办事项1</li>
<li><input disabled="" type="checkbox"> 待办事项2</li>
</ul>
<blockquote>
<p><strong>注意：</strong>目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在<strong>马克飞象</strong>中修改 Markdown 原文才可生效。下个版本将会全面支持。</p>
</blockquote>
<h2 id="印象笔记相关"><a href="#印象笔记相关" class="headerlink" title="印象笔记相关"></a>印象笔记相关</h2><h3 id="笔记本和标签"><a href="#笔记本和标签" class="headerlink" title="笔记本和标签"></a>笔记本和标签</h3><p><strong>马克飞象</strong>增加了<code>@(笔记本)[标签A|标签B]</code>语法, 以选择笔记本和添加标签。 <strong>绑定账号后</strong>， 输入<code>(</code>自动会出现笔记本列表，请从中选择。</p>
<h3 id="笔记标题"><a href="#笔记标题" class="headerlink" title="笔记标题"></a>笔记标题</h3><p><strong>马克飞象</strong>会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 <code>欢迎使用马克飞象</code>。</p>
<h3 id="快捷编辑"><a href="#快捷编辑" class="headerlink" title="快捷编辑"></a>快捷编辑</h3><p>保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到<strong>马克飞象</strong>中打开并编辑该笔记。</p>
<blockquote>
<p><strong>注意：</strong>目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。</p>
</blockquote>
<h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><p><strong>马克飞象</strong>通过<strong>将Markdown原文以隐藏内容保存在笔记中</strong>的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。</p>
<blockquote>
<p><strong>隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。</strong></p>
</blockquote>
<h3 id="离线存储"><a href="#离线存储" class="headerlink" title="离线存储"></a>离线存储</h3><p><strong>马克飞象</strong>使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过<code>文档管理</code>打开。</p>
<blockquote>
<p><strong>注意：</strong>虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，<strong>请务必经常及时同步到印象笔记</strong>。</p>
</blockquote>
<h2 id="编辑器相关"><a href="#编辑器相关" class="headerlink" title="编辑器相关"></a>编辑器相关</h2><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>右侧系统菜单（快捷键<code>Ctrl + M</code>）的<code>设置</code>中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。</p>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>帮助    <code>Ctrl + /</code><br>同步文档    <code>Ctrl + S</code><br>创建文档    <code>Ctrl + Alt + N</code><br>最大化编辑器    <code>Ctrl + Enter</code><br>预览文档 <code>Ctrl + Alt + Enter</code><br>文档管理    <code>Ctrl + O</code><br>系统菜单    <code>Ctrl + M</code></p>
<p>加粗    <code>Ctrl + B</code><br>插入图片    <code>Ctrl + G</code><br>插入链接    <code>Ctrl + L</code><br>提升标题    <code>Ctrl + H</code></p>
<h2 id="关于收费"><a href="#关于收费" class="headerlink" title="关于收费"></a>关于收费</h2><p><strong>马克飞象</strong>为新用户提供 10 天的试用期，试用期过后需要<a href="maxiang.info/vip.html">续费</a>才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。</p>
<h2 id="反馈与建议"><a href="#反馈与建议" class="headerlink" title="反馈与建议"></a>反馈与建议</h2><ul>
<li>微博：<a href="http://weibo.com/u/2788354117">@马克飞象</a>，<a href="http://weibo.com/ggock" title="开发者个人账号">@GGock</a></li>
<li>邮箱：<a href="mailto:&#x68;&#117;&#115;&#116;&#103;&#x6f;&#99;&#x6b;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;">&#x68;&#117;&#115;&#116;&#103;&#x6f;&#99;&#x6b;&#64;&#x67;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#109;</a></li>
</ul>
<hr>
<p>感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。</p>
<p>[^demo]: 这是一个示例脚注。请查阅 <a href="https://github.com/fletcher/MultiMarkdown/wiki/MultiMarkdown-Syntax-Guide#footnotes">MultiMarkdown 文档</a> 关于脚注的说明。 <strong>限制：</strong> 印象笔记的笔记内容使用 <a href="https://dev.yinxiang.com/doc/articles/enml.php">ENML</a> 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致<code>脚注</code>和<code>TOC</code>无法正常点击。</p>
]]></content>
      <categories>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>编辑器</tag>
      </tags>
  </entry>
</search>
